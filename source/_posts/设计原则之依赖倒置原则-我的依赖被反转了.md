---
title: 设计原则之依赖倒置原则--我的依赖被反转了
date: 2020-05-01 18:45:05
tags: ['设计原则','设计模式']
category: 设计模式
article: 设计原则之依赖倒置原则--我的依赖被反转了
---

# 设计原则之依赖倒置原则--我的依赖被反转了

`依赖倒置原则（Dependency Inversion Principle）DIP`。这个原则的英文是`high-level modules shouldn't depend on low-level modules. both modules should depend on abstractions. In addition, abstractions shouldn't depend on details.Details depend on abstractions.`。意思是高层模块不要依赖底层模块。高层模块和底层模块都应该依赖抽象。抽象不要依赖具体实现，具体实现应该依赖抽象。

## 什么是依赖倒置原则

通常来说，调用者属于高层模块，被调用者就是低层模块。为什么叫依赖倒置或者依赖反转呢？正常开发来说类A调用类B，类A属于高层模块，类B是低层模块。高层模块依赖低层模块，需要调用低层模块的方法。直接和低层模块高度耦合。

如果这时候我们的低层模块需要适配不同的高层模块，那么就无法复用。因为低层模块和以前的高层模块耦合在一起，如果修改适配新模块可能会导致以前的高层模块出现问题。

依赖倒置原则就是把这个依赖关系进行反转。以前是高层模块依赖低层模块，现在我不依赖你了。咋俩都依赖抽象。我们使用抽象类或者接口。我们的实现都基于这个接口来进行，而不是产生直接的依赖关系。我们都依赖同样的接口，同样的抽象。

比如我们的电脑有CPU,键盘，鼠标，内存，硬盘，显示器这些东西，我们只要组装起来就是电脑，这些东西就像高内聚的程序。内聚在一起，他们依赖相同的接口进行调用，你的`罗技鼠标`和`雷蛇鼠标`都使用同一个接口。那么电脑就可以正常运转。

## 如何使用依赖倒置原则

我们进行软件设计的时候应该由上而下的设计，先进行抽象设计，然后来具体实现。如果先写出具体实现在进行抽象设计，那么抽象出来的东西就容易依赖具体实现。因为具体实现很可能会变，但是抽象一般不会改变。所以抽象使得程序更加稳定。

那么为什么抽象一般不会改变呢？这就是之前说的[里氏替换原则](https://blog.csdn.net/Thepatterraining/article/details/105880396)。子类可以替换父类，需要改变我们只需要扩展具体实现就可以而不是修改抽象。

```php

//电脑需要一个能插入usb接口的鼠标
class computer{
    public function __construct(USB $mouse) {
        $this->mouse = $mouse;
    }
}

interface USB{
    public function usb();
}

//雷蛇鼠标实现了usb接口
class snakeMouse implements USB{
    public function usb() {}
}

//罗技鼠标实现了usb接口
class luoMouse implements USB{
    public function usb() {}
}
```

在这里，不管是哪个鼠标都可以使用，如果我们依赖具体的鼠标，那么就无法灵活更换了。两边，调用者和被调用者，高层模块和低层模块都依赖抽象。


参考资料：

- 大话设计模式
- 极客时间设计模式之美