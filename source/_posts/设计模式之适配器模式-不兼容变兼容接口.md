---
title: 设计模式之适配器模式--不兼容变兼容接口
date: 2020-05-05 17:54:30
tags: ['设计原则','设计模式']
category: 设计模式
article: 设计模式之适配器模式--不兼容变兼容接口
---

# 设计模式之适配器模式--不兼容变兼容接口

`适配器模式`可以增加接口的易用性，使得不兼容的接口变得兼容。

> 将一个接口转换成另外的接口，使得原本不兼容的接口变得兼容。

## 为什么要使用适配器模式

比如你的接口设计存在缺点，不够易用，不能复用但又希望复用的时候。

比如你要对接多个平台的接口他们互不兼容的时候。

现实中也有很多适配器，比如安卓苹果的转换头，比如usb到type-c的转换头，都是因为两边的接口不同，不兼容所以需要一个适配器。

下面是一个手机类，现在需要充电，但是手机的充电需要typec接口。

```php
/**
 * 适配器模式
 * 手机类
 */
class mobile {
    
    /**
     * 给手机充电操作
     */
    public function charge(ITypec $typec) {
        dump('使用typec接口给手机充电');
        $typec->typec();
    }

}
```

现在只有一个usb接口可以充电。

```php
/**
 * 适配器模式
 * 需要适配的类
 * usb接口
 */
class usb {
    
    /**
     * 接口
     */
    public function usb() {
        dump('电脑usb接口');
    }

}
```

我们增加一个适配器，也就是typec转usb的头。

```php
/**
 * 适配器模式
 * 适配器接口
 * typec接口
 */
interface ITypec {
    /**
     * 接口
     */
    public function typec();

}

/**
 * 适配器模式
 * 适配器类，typec转换usb的适配器
 * typec接口
 */
class typec implements ITypec {
    
    private $usb;

    function __construct() {
        $this->usb = new usb;
    }

    /**
     * 接口
     */
    public function typec() {
        dump('接口适配器');
        $this->usb->usb();
    }

}
```

我们的客户端就可以使用这个适配器了。

```php

$mobile = new mobile();

$mobile->charge(new typec);
```

这是`对象适配器`，还有类适配器，类适配器的话需要继承要适配的类。

```php

/**
 * 适配器模式
 * 适配器类，typec转换usb的适配器
 * typec接口
 */
class typec extends usb implements ITypec {
    
    //不再需要存储对象，直接继承了

    /**
     * 接口
     */
    public function typec() {
        dump('接口适配器');
        //$this->usb->usb();
        //这里改成使用父类的usb方法。
        parent::usb();
    }

}
```

### 适配器和代理模式还有装饰器模式的区别

这几个设计模式其实都差不多，你也可以说使用了typec代理了usb。只是角度不同所以名字不同罢了。

- 代理模式 更注重代理，代理了原有类。
- 装饰器模式 比代理模式更加灵活多样。
- 适配器模式 更注重兼容性，为了兼容别的类，而不是代理和装饰功能。

虽然角度不同，但是我觉得核心都差不多。**这几个设计模式都是需要修改原有类的时候，没有选择修改，而是套了壳子，来扩展功能**。这是一种好的思想，灵活运用思想更重要。

代码放在了我的github上面。

- [设计模式](https://github.com/Thepatterraining/design-pattern)


