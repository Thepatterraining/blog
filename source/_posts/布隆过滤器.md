---
title: 布隆过滤器
date: 2020-03-26 16:11:05
tags: ['数据结构','算法', '分布式']
category: 数据结构和算法
---

# 布隆过滤器

上一节提到了缓存穿透的问题，如果查询不存在的值怎么办，布隆过滤器可以完美解决这个问题。

当查询的时候，我们只需要确定这个值不存在，那我们就不用再查询了，也就减少了数据库，缓存的压力，减少了服务器压力，避免了一些攻击。

`布隆过滤器`是个什么东西呢，它是由一串`二进制`组成的串，这个串中，只有`0`和`1`。

0代表不存在，1代表存在。

我们用hash算法计算之后，对布隆过滤器的长度进行取余操作，确定这个值应该存在布隆过滤器的哪个位置上。确定之后，将这个位置的值设置为`1`。

例如：

有一个长度为32的布隆过滤器

<!--more-->

> 00000 00000 00000 00000 00000 00000 00

我们缓存了值`张三`

> hash(张三) % 32 = 2

`布隆过滤器`变成下面这样

> 01000 00000 00000 00000 00000 00000 00

我们又缓存了`李四`

> hash(李四) % 32 = 8

`布隆过滤器`变成下面这样

> 01000 00100 00000 00000 00000 00000 00

当我们查询`张三`的时候我们进行hash取余操作后是2，那我们就只要确定布隆过滤器的第二位是不是1就行了。

如果是`1`，代表了`张三`这个值有可能存在，为什么是有可能呢，因为我们不能保证hash冲突，也就是别的值经过hash取余操作后也是2。比如`王五`hash后也是2，那么我们查询王五的时候，不能确定是王五存在还是张三存在，但是我们能确定，他有存在的可能。

如果是`0`，代表了`张三`这个值一定不存在。

这样已经达到了我们的目的，我们就是想把不存在的筛出去。

## 缺点

1. 判断元素有误判的可能

上面也说了，有hash冲突，那么怎么办呢？

我们可以经过多次hash，如果多次hash后取余的结果都是`1`，那么可能存在，这种方法可以减少hash冲突的概率。

不过只要我们的需求是要筛选掉`一定不存在`的，那么这个缺点就无所谓了。

2. 不支持删除操作

这个和上面的问题点类似，因为有误判的可能，如果删除，那么可能会影响到其他值。

解决方案：

我们可以存储计数器，不再使用二进制。

比如`张三`, `王五`都命中了2，那么布隆过滤器变成下面这样：
> 02000 00100 00000 00000 00000 00000 00

当我们删除的时候，计数器减1就好了

这样也存在问题，本身二进制存储很节省空间，但是存储数值类型的话，空间耗费就会增加了。

## 总结

使用之前先思考一下使用场景，布隆过滤器适用于筛除`一定不存在`的元素。比如我们的缓存穿透。

布隆过滤器有误判的风险，可以使用多个hash来减少误判的概率。

布隆过滤器不支持删除操作，可以用耗费空间的方式使它支持。

