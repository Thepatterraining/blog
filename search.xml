<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ElasticSearch一--ES简介</title>
    <url>/ES--%E7%AE%80%E4%BB%8B.html</url>
    <content><![CDATA[<h1 id="ES–简介"><a href="#ES–简介" class="headerlink" title="ES–简介"></a>ES–简介</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>ES起源于Lucene.Lucene是基于JAVA开发的搜索引擎类库。</p>
<p>Lucene具有高性能，易扩展的优点。</p>
<p>Lucene的局限性：</p>
<ol>
<li>只能基于JAVA开发</li>
<li>类库的接口学习曲线陡峭</li>
<li>原生并不支持水平扩展</li>
</ol>
<h2 id="ES的诞生"><a href="#ES的诞生" class="headerlink" title="ES的诞生"></a>ES的诞生</h2><p>ES的创始人<code>Shay Banon</code>说过：<code>Search is something that any application should have</code>。</p>
<p>2004年基于Lucene开发了 Compass</p>
<p>2010年重写了 Compass ，取名 ElasticSearch</p>
<ul>
<li>支持分布式，可水平扩展</li>
<li>降低全文检索的学习曲线，可以被任何编程语言调用</li>
</ul>
<h2 id="ES的分布式架构"><a href="#ES的分布式架构" class="headerlink" title="ES的分布式架构"></a>ES的分布式架构</h2><p>集群规模可以从单个扩展至数百个节点</p>
<p>高可用 &amp; 水平扩展<br>    - 服务和数据两个维度</p>
<p>支持不同的节点类型<br>    - 支持 Hot &amp; Warm架构</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul>
<li><p>海量数据的分布式存储以及集群管理</p>
<ul>
<li>服务与数据的高可用，水平扩展</li>
</ul>
</li>
<li><p>近实时搜索，性能卓越</p>
<ul>
<li>结构化/全文/地理位置/自动完成</li>
</ul>
</li>
<li><p>海量数据的近实时分析</p>
<ul>
<li>聚合功能</li>
</ul>
</li>
</ul>
<h3 id="新特性5-x"><a href="#新特性5-x" class="headerlink" title="新特性5.x"></a>新特性5.x</h3><ul>
<li>Lucene 6.x ，性能提升，默认打分机制从TF-IDF改为BM25</li>
<li>支持Ingest节点/ Painless Scripting / Completion suggested 支持/ 原生的JAVA REST客户端</li>
<li>Type 标记成 deprecated ，支持了keyword类型</li>
<li>性能优化<ul>
<li>内部引擎移除了避免同一文档并发更新的竞争锁，带来15 - 20%的性能提升</li>
<li>Instant aggregation，支持分片上聚合的缓存</li>
<li>新增了Profile API</li>
</ul>
</li>
</ul>
<h3 id="新特性6-x"><a href="#新特性6-x" class="headerlink" title="新特性6.x"></a>新特性6.x</h3><ul>
<li>Lucene 7.x</li>
<li>新功能<ul>
<li>跨集群复制（CCR）</li>
<li>索引生命周期管理</li>
<li>SQL的支持</li>
</ul>
</li>
<li>更友好的升级及数据迁移<ul>
<li>在主要版本之间的迁移更为简化，体验升级</li>
<li>全新的基于操作的数据复制框架，可加快回复数据。</li>
</ul>
</li>
<li>性能优化<ul>
<li>有效存储稀疏字段的新方法，降低了存储成本</li>
<li>在索引时进行排序，可加快排序的查询性能</li>
</ul>
</li>
</ul>
<h3 id="新特性7-x"><a href="#新特性7-x" class="headerlink" title="新特性7.x"></a>新特性7.x</h3><ul>
<li>Lucene 8.x</li>
<li>重大改进 - 正式废除单个索引下多Type的支持</li>
<li>7.1开始，Security功能免费使用</li>
<li>ECK - ElasticSearch Operator on Kubernetes</li>
<li>新功能<ul>
<li>New Cluster coordination</li>
<li>Feature-Complete High Level Rest Client</li>
<li>Script Score Query</li>
</ul>
</li>
<li>性能优化<ul>
<li>默认的Primary Shard 数从5变为1，避免Over Sharding</li>
<li>性能优化，更快的Top K</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>ES</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层CRC(循环冗余码)差错校验码详解</title>
    <url>/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82CRC%E5%B7%AE%E9%94%99%E6%A0%A1%E9%AA%8C%E7%A0%81%E8%AF%A6%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="数据链路层CRC-循环冗余码-差错校验码详解"><a href="#数据链路层CRC-循环冗余码-差错校验码详解" class="headerlink" title="数据链路层CRC(循环冗余码)差错校验码详解"></a>数据链路层CRC(循环冗余码)差错校验码详解</h1><p><code>CRC</code>差错校验码是数据链路层用来进行差错校验的一个码。</p>
<h3 id="CRC编码过程"><a href="#CRC编码过程" class="headerlink" title="CRC编码过程"></a>CRC编码过程</h3><p>假设要编码的<code>数据D</code>，有<code>d个比特</code>，发送节点要将它发送给接收节点。发送方和接收方要先协商一个<code>r + 1</code>比特模式，成为<code>生成多项式</code>。我们将其表示为<code>G</code>。我们将要求G的最高有效位（最左边）的比特是1。</p>
<p>我们要有一个数据D，比如 1001<br>这个数据有d个比特，也就是4个比特<br>需要附加 r 个比特作为校验码 R<br>编码过后会变成数据会变成D + R<br>数据有d + r个比特<br>使得得到的数据D+R进行模2运算恰好能被G整除</p>
<h3 id="CRC差错检测过程"><a href="#CRC差错检测过程" class="headerlink" title="CRC差错检测过程"></a>CRC差错检测过程</h3><p>接收方用G去除接收到的D+R数据，如果余数为非0，则有差错，如果余数为0，则无差错</p>
<h3 id="CRC计算"><a href="#CRC计算" class="headerlink" title="CRC计算"></a>CRC计算</h3><p>所有CRC计算采用模2算术来做，在加法中不进位，在减法中不借位。这意味着加法和减法是相同的，而且这两种操作等价于<code>异或</code>（XOR）操作。</p>
<p>1011 XOR 0101 = 1110</p>
<p><code>异或</code>操作：不同的为1，相同为0。也就是0 XOR 0 = 0,1 XOR 1 = 0,0 XOR 1 = 1。</p>
<p>乘法和除法是相同的。</p>
<p>给定D 和 R, D * 2<sup>r</sup> XOR R就等于 D + R数据。</p>
<h3 id="如何计算R"><a href="#如何计算R" class="headerlink" title="如何计算R"></a>如何计算R</h3><p>我们要求出R使得对于n有：<br>D * 2<sup>r</sup> XOR R = nG</p>
<p>也就是说，我们要选择 R 使得G能除 D * 2<sup>r</sup> XOR R 而没有余数。如果对上面的等式两边都 XOR R.</p>
<p>D * 2<sup>r</sup> = nG XOR R</p>
<p>根据上面的等式可以得出，如果我们用G 除 D * 2<sup>r</sup>，余数刚好是R</p>
<p>R = remainder (D * 2<sup>r</sup> / G)</p>
<p>也就是使用D * 2<sup>r</sup>去除以 G。余数就是R。</p>
<h3 id="如何计算G"><a href="#如何计算G" class="headerlink" title="如何计算G"></a>如何计算G</h3><p>G 作为多项式，有两种写法，一种是x<sup>2</sup> + x + 1的写法，一种是二进制写法 111。</p>
<p>我们需要用 D * 2<sup>r</sup> 除以 G 。所以我们需要求出G的二进制写法，才能做除法运算。</p>
<p>这个转换的方法：</p>
<ol>
<li>首先把末尾的1看成x<sup>0</sup>，也就是x的0次幂</li>
<li>这样提取出x的所有幂</li>
<li>对应幂的位置填1，如果没有对应幂的位置则填0</li>
</ol>
<h5 id="转换例子1"><a href="#转换例子1" class="headerlink" title="转换例子1"></a>转换例子1</h5><p>G = x<sup>4</sup> + x + 1</p>
<p>提取出来的幂分别是 4,1,0。<br>没有的幂是3,2。<br>在对应的位置填上1或0。<br>4 3(无) 2(无) 1 0<br>1 0     0     1 1<br>这个G的二进制就是 10011。</p>
<p>其实很简单，0次幂对应个位，1次幂对应十位，一直往上加就行了，有1次幂十位就是1，没有就是0.</p>
<h5 id="转换例子2"><a href="#转换例子2" class="headerlink" title="转换例子2"></a>转换例子2</h5><p>G = x<sup>6</sup> + x<sup>4</sup> + x<sup>2</sup> + 1</p>
<p>6 5(无) 4 3(无) 2 1(无) 0<br>1 0     1 0     1 0     1</p>
<p>对应的二进制就是 1010101</p>
<h3 id="计算CRC编码"><a href="#计算CRC编码" class="headerlink" title="计算CRC编码"></a>计算CRC编码</h3><p>给定 D = 101110, G = 1001, d = 6, r = 3。计算D的CRC编码后的数据</p>
<p>首先求R。</p>
<p>用D/G可以得出结果为101011，余数为011，余数就是R。</p>
<p>然后把R放到D后面。</p>
<p>编码后就是 101110 011</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下四网络层</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%BA%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>负责通过一条链路从一个节点向另一个物理链路直接相连的相邻节点传送数据报</p>
<p>组帧</p>
<ul>
<li>封装数据报，加首部和尾部</li>
<li>帧同步</li>
</ul>
<p>链路接入</p>
<ul>
<li>如果是共享介质，需要解决信道接入</li>
<li>帧首部的MAC地址，用于标识帧的源和目的，不同于IP地址</li>
</ul>
<p>相邻节点间可靠交付</p>
<ul>
<li>在低误码率的有线链路上很少采用（如光纤，某些双绞线）</li>
<li>无线链路：误码率高，需要可靠交付</li>
</ul>
<p>流量控制</p>
<ul>
<li>协调相邻的发送和接受</li>
</ul>
<p>差错检测</p>
<ul>
<li>信号衰减和噪声会引起差错</li>
<li>接收端检测到差错<ul>
<li>通知发送端重传或丢弃</li>
</ul>
</li>
</ul>
<p>差错纠正</p>
<ul>
<li>接收端直接纠正比特差错</li>
</ul>
<p>全双工和半双工通信控制</p>
<ul>
<li>全双工:链路两端节点同时双向传输数据</li>
<li>半双工：链路两端节点交替双向传输数据</li>
</ul>
<h2 id="差错检测：差错编码"><a href="#差错检测：差错编码" class="headerlink" title="差错检测：差错编码"></a>差错检测：差错编码</h2><p>差错编码基本原理：<br>D -&gt; D<code>R</code> ，其中R为差错检测与纠正比特</p>
<p>差错编码分为<code>检错码</code>和<code>纠错码</code><br>对于检错码：如果编码集的汉明距离ds = r + 1，则可以检测r位的错误<br>对于纠错码：ds = 2r + 1则可以检测r位的错误</p>
<h2 id="MAC协议"><a href="#MAC协议" class="headerlink" title="MAC协议"></a>MAC协议</h2><p>两类<code>链路</code></p>
<p>点对点链路</p>
<ul>
<li>拨号接入的PPP</li>
<li>以太网交换机与主机间的点对点链路</li>
</ul>
<p>广播链路（共享介质）</p>
<ul>
<li>早期的总线以太网</li>
<li>HFC的上行链路</li>
<li>802.11 无线网</li>
</ul>
<p>单一共享广播信道</p>
<ul>
<li>两个或者两个以上节点同时传输：干扰</li>
<li>冲突：节点同时接收到两个或者多个信号 =》 接收失败</li>
</ul>
<p>多路访问控制协议MAC解决这些问题：</p>
<ul>
<li>采用分布式算法决定节点如何共享信道，及决策节点何时可以传输数据</li>
<li>必须基于信道本身，通信信道共享协调信息<ul>
<li>无带外信道协调</li>
</ul>
</li>
</ul>
<h4 id="理想MAC协议"><a href="#理想MAC协议" class="headerlink" title="理想MAC协议"></a>理想MAC协议</h4><p>给定：速率为R bps的广播信道<br>期望：</p>
<ol>
<li>当只有一个节点希望传输数据时，他可以以速率R发送</li>
<li>当有M个节点发送，每个节点R/M速率</li>
<li>完全分散控制<ul>
<li>无需特定节点协调</li>
<li>无需时钟、时隙同步</li>
</ul>
</li>
<li>简单</li>
</ol>
<h4 id="MAC协议分类"><a href="#MAC协议分类" class="headerlink" title="MAC协议分类"></a>MAC协议分类</h4><p>三大类：</p>
<ul>
<li>信道划分MAC协议<ul>
<li>多路复用</li>
<li>TDMA,FDMA,CDMA,WDMA等</li>
</ul>
</li>
<li>随机访问MAC协议<ul>
<li>信道不划分，允许冲突</li>
<li>采用<code>冲突</code>恢复机制</li>
</ul>
</li>
<li>轮转MAC协议<ul>
<li>节点轮流使用信道</li>
</ul>
</li>
</ul>
<h5 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h5><p>发送时候使用信道全部速率</p>
<p>需要定义：</p>
<ul>
<li>如果检测冲突</li>
<li>如何从冲突恢复（通过延迟重传）</li>
</ul>
<p>典型的协议</p>
<ul>
<li>时隙 ALOHA</li>
<li>ALOHA</li>
<li>CSMA CSMA/CD CSMA/CA</li>
</ul>
<h6 id="时隙-ALOHA"><a href="#时隙-ALOHA" class="headerlink" title="时隙 ALOHA"></a>时隙 ALOHA</h6><p>假定：</p>
<ul>
<li>所有帧大小相同</li>
<li>时间被划分为等长的时隙</li>
<li>节点只能在时隙开始时刻发送数据</li>
<li>节点间时钟同步</li>
<li>如果2个或2个以上节点在同一时隙发送帧，节点就检测到冲突</li>
</ul>
<p>运行：</p>
<ul>
<li>当节点有新的帧时，在下一个时隙发送<ul>
<li>无冲突：发送成功</li>
<li>冲突：节点在下一个时隙以概率P重传该帧，直至成功</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>单个节点活动时，可以连续以信道全部速率发送</li>
<li>高度分散化：只需同步时隙</li>
<li>简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>冲突，浪费时隙</li>
<li>空闲时隙</li>
<li>节点也许能以远小于分组传输时间检测到冲突</li>
</ul>
<p>最大效率<code>0.37</code></p>
<h6 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h6><p>非时隙，更简单，无需同步<br>当有新的帧，立即发送<br>冲突可能增大</p>
<p>最大效率<code>0.18</code></p>
<h6 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h6><p>载波监听多路访问协议</p>
<ul>
<li>发送帧之前，监听信道（载波）<ul>
<li>信道空闲：发送完整帧</li>
<li>信道忙：推迟发送<ul>
<li>1-坚持CSMA 一直监听信道</li>
<li>非坚持CSMA 随机等待一段时间再监听信道</li>
<li>P-坚持CSMA 以概率P监听信道，概率1-P不监听信道</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>冲突仍可能发生：</p>
<ul>
<li>信号传播延迟</li>
</ul>
<p>继续发送冲突帧：浪费信道资源</p>
<h6 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h6><p>带有冲突检测的载波监听多路访问协议</p>
<ul>
<li>短时间内可以检测到冲突</li>
<li>冲突后传输中止，减少信道浪费</li>
</ul>
<p>运行：</p>
<ol>
<li>适配器从网络获取一条数据报，准备链路层帧，并放入帧适配器缓存中。</li>
<li>如果适配器侦听到信道空闲（即无信号能量从信道进入适配器），他开始传输帧。另一方面，如果适配器侦听到信道正在忙，他将等待，直到侦听到没有信号能量时才开始传输帧。</li>
<li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li>
<li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，他中指传输（即他停止了传输帧）</li>
<li>中止传输后，适配器等待一个随机时间量，然后返回步骤2.<ul>
<li>等待一个随机（而不是固定）的时间量的需求是明确的–如果两个结点同时传输帧，然后这两个结点等待相同固定的时间量，他们将持续碰撞下去。但选择随机回退时间的时间间隔多大为好呢？如果时间间隔大而碰撞结点数量小，在重复“侦听-当空闲时传输”的步骤前。</li>
</ul>
</li>
</ol>
<p>冲突检测</p>
<ul>
<li>有线局域网易于实现：测量信号强度，比较发射信号与接收信号</li>
<li>无线信号很难实现：接收信号强度淹没在本地发射信号强度下</li>
</ul>
<p>边发送边监听，不发送就不监听</p>
<p>网络带宽：R bps<br>数据帧最小长度：Lmin(bits)<br>信号传播速度：V(m/s)<br>信道长度：Dmax</p>
<p>满足：<br>L /R &gt;= 2 Dmax / V<br>Lmin / R = 2 Dmax / V<br>Lmin / R = RTT max</p>
<p>远优于ALOAH，并且简单，分散。</p>
<h5 id="轮转MAC"><a href="#轮转MAC" class="headerlink" title="轮转MAC"></a>轮转MAC</h5><p>轮询：</p>
<ul>
<li>主节点轮流“邀请”从属节点发送数据</li>
<li>典型应用：<ul>
<li>“哑”从属设备</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>不会冲突</li>
<li>使用全部带宽</li>
</ul>
<p>问题：</p>
<ul>
<li>轮询开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ul>
<h6 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h6><p>控制令牌依次从一个节点传递到下一个节点<br>令牌：特殊帧<br>获取令牌才可以发送数据</p>
<p>优点：</p>
<ul>
<li>不会冲突</li>
<li>使用全部带宽</li>
</ul>
<p>缺点：</p>
<ul>
<li>令牌开销</li>
<li>等待延迟</li>
<li>单点故障</li>
</ul>
<h5 id="MAC协议总结"><a href="#MAC协议总结" class="headerlink" title="MAC协议总结"></a>MAC协议总结</h5><p>信道划分协议：<br>优点：网络负载高，利用率高，性能高<br>缺点：网络负载低，利用率低，性能低</p>
<p>随机访问MAC协议：<br>优点：网络负载低，利用率高，性能高<br>缺点：网络负载高，会冲突</p>
<p>轮转MAC:<br>主节点轮询：令牌传递<br>结合两者优点，不是最好也不是最坏</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下四网络层</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层核心功能：转发与路由</p>
<p>转发：将分组从路由器的输入端口转移到合适的输出端口</p>
<p>转发表确定在本路由器如何转发分组</p>
<p>路由：确定分组从源到目的经过的路径。</p>
<ul>
<li>路由算法：确定通过网络的端到端路径。</li>
</ul>
<p>某些网络的重要功能：连接建立</p>
<p>数据分组传输前需要建立连接，和运输层不一样的是所有网络设备路由器都会参与建立连接。</p>
<p>网络层是两个主机建立连接</p>
<p>运输层是两个应用进程建立连接</p>
<p>无连接服务</p>
<ul>
<li>不事先为分组确定传输路径</li>
<li>每个分组独立路径</li>
<li>不同分组可能传输路径不同</li>
<li>数据报网络</li>
</ul>
<p>连接服务：</p>
<ul>
<li>首先为分组确定传输路径</li>
<li>沿这个路径传输</li>
<li>系列分组传输路径相同</li>
<li>传输结束后拆除</li>
<li>虚电路网络</li>
</ul>
<p><code>数据报网络</code>和<code>虚电路网络</code>是典型两类分组交换网络。</p>
<p>类似UDP和TCP。但是网络层是<code>主机到主机</code>.<code>网络核心实现</code>.</p>
<h3 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h3><p>一条从源主机到目的主机，类似于电路的路径。</p>
<ul>
<li>分组交换</li>
<li>每个分组的传输利用链路的全部带宽</li>
<li>源主机到目的主机的所有网络设备完成虚电路连接和功能</li>
</ul>
<p>通信过程：</p>
<ul>
<li>呼叫建立（call setup） -》 数据传输 -》 拆除呼叫</li>
<li>每个分组携带虚电路标识（VC ID），而不是目的主机地址</li>
<li>虚电路经过的每个网络设备，维护每条经过他的虚电路连接状态</li>
<li>链路，网络设备资源可以面向VC进行预分配<ul>
<li>预分配资源 = 可预期服务性能</li>
<li>如ATM的电路仿真（CBR）</li>
</ul>
</li>
</ul>
<p>每条虚电路包括：</p>
<ul>
<li>从源主机到目的主机的一条路径</li>
<li>虚电路号（VCID），沿路每段链路一个编号</li>
<li>沿路每个网络层设备，利用转发表记录经过的每条虚电路</li>
</ul>
<p>分组携带虚电路号VCID，而不是目的地址。<br>同一条VC,在每段链路上的VCID通常不同。</p>
<ul>
<li>路由器转发分组时依据转发表改写/替换虚电路号</li>
</ul>
<h5 id="虚电路信令协议"><a href="#虚电路信令协议" class="headerlink" title="虚电路信令协议"></a>虚电路信令协议</h5><p>用于VC的建立，维护与拆除</p>
<ul>
<li>路径选择</li>
</ul>
<p>应用于虚电路网络</p>
<ul>
<li>如ATM</li>
</ul>
<p>目前的internet不采用</p>
<h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><ul>
<li>无连接</li>
<li>每个分组携带目的地址</li>
<li>路由器根据分组的目的地址转发分组<ul>
<li>基于路由协议/算法构建转发表</li>
<li>检索转发表</li>
<li>每个分组独立选路</li>
</ul>
</li>
<li>Internet网络是数据报网络</li>
<li>路由算法<ul>
<li>根据地址范围进行转发</li>
<li>最长前缀匹配优先</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>Internet(数据报网络) </p>
<ul>
<li>计算机之间的数据交换<ul>
<li>弹性服务，没有严格要求</li>
</ul>
</li>
<li>链路类型众多<ul>
<li>特点性能各异</li>
<li>同一服务困难</li>
</ul>
</li>
</ul>
<p>ATM(虚电路网络)</p>
<ul>
<li>电话网络演变而来</li>
<li>核心业务是实时对话<ul>
<li>严格的时间，可靠性需求</li>
<li>需要有保障的服务</li>
</ul>
</li>
<li>非智能端系统<ul>
<li>电话机</li>
<li>传真机</li>
</ul>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>路由协议</p>
<ul>
<li>路径选择</li>
<li>RIP OSPF BGP</li>
</ul>
<p>IP协议</p>
<ul>
<li>寻址规约</li>
<li>数据报格式</li>
<li>分组处理规约</li>
</ul>
<p>ICMP协议</p>
<ul>
<li>差错报告</li>
<li>路由器“信令”</li>
</ul>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><ul>
<li>首部<ul>
<li>版本号 4比特 ipv4就是4</li>
<li>首部长度 4比特 首部的长度，以4字节为单位 默认是5 表示20字节</li>
<li>服务类型 8比特 期望获得哪种类型的服务 只有在网络提供区分服务时使用 通常是0</li>
<li>总长度 16比特 IP数据报的长度（首部 + 数据），以字节为单位， 最大IP分组总长度 65535B 最小分组首部 20B IP分组数据最大可以是 65515B</li>
<li>标识 16比特 ID，计数器+1</li>
<li>标志位 3比特 保留1比特 DF = 1禁止分片 0 允许分片 MF = 1非最后一片 0 最后一片或未分片</li>
<li>片偏移 13比特 IP分组分片封装原IP分组数据的相对偏移量 以8字节为单位</li>
<li>生存时间 8比特 IP分组在网络中可以通过的路由器数（跳步数）</li>
<li>协议 8比特 指示IP分组封装的是哪个协议的数据包 6是TCP或者17是UDP</li>
<li>首部校验和 16比特 IP分组首部的差错检测 逐步计算</li>
<li>源IP地址 32比特  </li>
<li>目的IP地址 32比特</li>
<li>选项字段 变长 范围 1 - 40B 携带安全，源选路径，时间戳和路由记录等内容 实际很少被使用</li>
<li>填充字段 变长 范围 0 - 3B 补齐整个首部，保证32位对齐</li>
</ul>
</li>
<li>数据</li>
</ul>
<h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><p>链路最大数据单元MTU。如果现在的IP分组大于下个链路的MTU就可以进行分片。</p>
<ul>
<li>如果进行分片就分片，然后重组</li>
<li>如果不可以分片则丢弃分组</li>
</ul>
<p>分片过程：<br>假设IP分组长L，带转发MTU为M<br>若L &gt; M且DF = 0,则可以分片<br>分片时每个分片的标识复制原IP分组的标识<br>通常分片时，除最后一个分片，都为MTU允许的最大分片<br>一个最大分片可封装的应该是 8 的倍数。<br>d = M - 20 / 8 * 8<br>n = L - 20 / d<br>分片偏移量<br>Fi = d / 8 * (i - 1)<br>每片总长度<br>d + 20<br>最后一个<br>L - （n - 1）d</p>
<h3 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h3><p>32比特（IPv4） 11011111 00000001 00000001 00000001 = 233.1.1.1<br>IP地址与每个接口关联</p>
<ul>
<li>网络号：高位比特</li>
<li>主机号：低位比特</li>
</ul>
<h3 id="IP子网"><a href="#IP子网" class="headerlink" title="IP子网"></a>IP子网</h3><p>IP子网：</p>
<ul>
<li>IP地址具有相同的网络号</li>
<li>不跨越路由器可以彼此物理联通</li>
<li>233.1.1.0/24</li>
</ul>
<p><code>有类编址</code><br>A类地址：</p>
<ul>
<li>网络号 8比特 主机号 24比特 50% 0.0.0.0 - 127.255.255.255<br>B类地址：</li>
<li>网络号 16比特 主机号 16比特 25% 128.0.0.0 - 191.255.255.255<br>C类地址：</li>
<li>网络号 24比特 主机号 8比特 12.5% 192。0.0.0 - 223.255.255.255<br>D类地址：</li>
<li>6.25% 224.0.0.0 - 239.255.255.255<br>E类地址：</li>
<li>6.25% 240.0.0.0 - 255.255.255.255</li>
</ul>
<p>私有IP地址：</p>
<ul>
<li>A类：网络号10开头的 10.<em>.</em>.*</li>
<li>B类：172.16 - 172.31 16个</li>
<li>C类：192.168.0 - 192.168.255</li>
</ul>
<p>IP地址：</p>
<ul>
<li>网络号：高位比特</li>
<li>子网号：原主机号的部分</li>
<li>主机号：地位比特</li>
</ul>
<p>子网掩码：网络号和子网号取255，主机号取0</p>
<ul>
<li>A类网络子网掩码 255.255.255.0</li>
</ul>
<p>子网地址 + 子网掩码 = 准确确定子网大小</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>子网 201.2.3.0 子网掩码 255.255.255.0，划分为4个等长的子网。</p>
<ul>
<li>201.2.3.0 = 201.2.3.00000000 255.255.255.11000000 = 255.255.255.192</li>
<li>201.2.3.64 = 201.2.3.01000000 255.255.255.11000000 = 255.255.255.192</li>
<li>201.2.3.128 = 201.2.3.10000000 255.255.255.11000000 = 255.255.255.192</li>
<li>201.2.3.192 = 201.2.3.11000000 255.255.255.11000000 = 255.255.255.192</li>
</ul>
<p>将IP分组的目的IP地址与子网掩码<code>按位与</code>运算，提取子网地址。<br>目的IP:172.32.1.112 = 10101100.00100000.00000001.01110000<br>子网掩码：255.255.254.0 = 11111111.11111111.11111110.00000000<br>子网地址：10101100.00100000.00000000.00000000 = 172.32.0.0<br>地址范围：172.32.0.0 - 172.32.1.255<br>可分配地址范围：172.32.0.1 - 172.32.1.254<br>广播地址：172.32.1.255</p>
<h3 id="CIDR与路由聚合"><a href="#CIDR与路由聚合" class="headerlink" title="CIDR与路由聚合"></a>CIDR与路由聚合</h3><p>无类域间路由CIDR</p>
<ul>
<li>消除传统的A类，B类，C类地址划分</li>
<li>网络号 + 子网号 = 网络前缀 可以任意长度</li>
<li>融合子网地址和子网掩码，方便子网划分<ul>
<li>无类地址格式：a.b.c.d/x 其中x为网络前缀长度</li>
</ul>
</li>
<li>提高IPv4地址空间分配效率</li>
<li>提高路由效率<ul>
<li>将多个子网构成一个大的子网</li>
<li>构造超网</li>
<li>路由聚合</li>
</ul>
</li>
</ul>
<p>例如：<br>前23位是网络前缀，后9位是主机号<br>11001000 00010111 00010000 00000000<br>200.23.16.0/23</p>
<p>11001000.00010111.00010010.00000000<br>200.23.18.0/23</p>
<p>11001000.00010111.00010100.00000000<br>200.23.20.0/23<br>聚合成超网：<br>11001000 00010111 00010000 00000000<br>200.23.16.0/20</p>
<p>如果有一个子网不在也没事，路由记录两条信息。根据<code>最长前缀匹配优先</code>。不会出错。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态分配路由协议：<br>客户：DHCP discover</p>
<ul>
<li>src:0.0.0.0:68</li>
<li>dest:255.255.255.255:67 广播</li>
<li>yiaddr:0.0.0.0</li>
<li>transactionID:654</li>
</ul>
<p>DHCP服务器：DHCP offer</p>
<ul>
<li>src:223.1.2.5:67 DHCP服务器的IP</li>
<li>dest:255.255.255.255:68 广播</li>
<li>yiaddr:223.1.2.4  分配的IP</li>
<li>transactionID:654</li>
<li>lifetime:3600 secs</li>
</ul>
<p>客户：DHCP req</p>
<ul>
<li>src:0.0.0.0:68</li>
<li>dest:255.255.255.255:67 广播</li>
<li>yiaddr:223.1.2.4  分配的IP</li>
<li>transactionID:655</li>
<li>lifetime:3600 secs</li>
</ul>
<p>DHCP服务器：DHCP ACK</p>
<ul>
<li>src:223.1.2.5:67 DHCP服务器的IP</li>
<li>dest:255.255.255.255:68 广播</li>
<li>yiaddr:223.1.2.4  分配的IP</li>
<li>transactionID:655</li>
<li>lifetime:3600 secs</li>
</ul>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>子网使用一个公共IP。发送网络数据的时候路由器替换源IP地址。</p>
<p>动机：</p>
<ul>
<li>只需从ISP申请一个IP地址<ul>
<li>IPv4地址耗尽</li>
</ul>
</li>
<li>本地网络地址是私有的，局部的，IP地址变更根外界没有影响</li>
<li>变更ISP时候，无需修改内部网络IP</li>
<li>内部网络设备对外界网络不可见，更加安全</li>
</ul>
<p>实现：</p>
<ul>
<li>替换<ul>
<li>利用（NAT IP地址，新端口号）替换每一个<code>外出IP数据报</code>的（源IP地址，源端口号）</li>
</ul>
</li>
<li>记录<ul>
<li>将每对（NAT IP地址，新端口号）和（源IP地址，源端口号）记录在<code>NAT转换表</code>中</li>
</ul>
</li>
<li>替换<ul>
<li>根据<code>NAT转换表</code>，利用（源IP地址，源端口号）替换（NAT IP地址，新端口号）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0GBN%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议"><a href="#网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议" class="headerlink" title="网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议"></a>网络原理自顶向下三可靠数据传输原理实现GBN滑动窗口协议</h1><p>在GBN中，允许发送方发送多个分组而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p>
<p>我们需要</p>
<ul>
<li>base 基序号 最早未确认分组的序号</li>
<li>nextSeqNum下一个序号 最小的未使用序号</li>
</ul>
<p>则可以将序号范围分割成四段</p>
<ul>
<li>0 至 base - 1 已经发送并被确认的分组</li>
<li>base 至 nextSeqNum - 1 已经发送没有被确认的分组</li>
<li>nextSeqNum 至 base + N - 1 可以被发送的分组序号</li>
<li>base + N 至 无穷大  不能使用的序号</li>
</ul>
<p>已经被发送的可以但未被确认的可以看成是一个在序号范围内长度为N的窗口。随着协议允许，窗口往前滑动。因此N常被成为<code>窗口长度</code>，GBN协议也被称为<code>滑动窗口协议</code></p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><p>GBN的发送方必须响应三种类型的事件</p>
<ul>
<li>上层的调用。检测有没有可以使用的序号，如果有就发送。</li>
<li>收到ACK。GBN使用<code>累计确认</code>。即收到的N之前的全部确认。</li>
<li>超时事件。如果出现超时，就重传所有已发送未确认的分组。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$base = <span class="number">1</span>;</span><br><span class="line">$nextSeqNum = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet[$nextSeqNum] = make_pkt($data, $checkSum, $nextSeqNum);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet[$nextSeqNum]);</span><br><span class="line">    <span class="comment">//只启动一个定时器</span></span><br><span class="line">    <span class="keyword">if</span> ($base == $nextSeqNum) &#123;</span><br><span class="line">        start_timer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果超时</span></span><br><span class="line">    <span class="keyword">if</span> (timeout()) &#123;</span><br><span class="line">        <span class="comment">//重传所有已发送的分组</span></span><br><span class="line">        <span class="keyword">for</span> ($i = $base; $i &lt;= $nextSeqNum - <span class="number">1</span>; $i++) &#123;</span><br><span class="line">            udt_send($packet[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($isAck = rdt_rev() &amp;&amp; check($isAck)) &#123;</span><br><span class="line">        <span class="comment">//等待接收方回传ack 并且没有出现错误</span></span><br><span class="line">        <span class="comment">//获取确认的序号</span></span><br><span class="line">        $ackNum = getAckNum($isAck);</span><br><span class="line">        <span class="comment">//确认这个序号之前所有的分组</span></span><br><span class="line">        $base = $ackNum;</span><br><span class="line">        <span class="comment">//如果确认了最新的分组，那么停止定时器</span></span><br><span class="line">        <span class="keyword">if</span> ($base == $nextSeqNum) &#123;</span><br><span class="line">            stop_timer();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start_timer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><p>GBN的接收端较为简单，因为接收端只需要按序号交付数据就可以了。如果数据没有按序到达接收端，接收端只需要直接丢弃，因为发送端会重传所有分组。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的序号</span></span><br><span class="line">$expackNum = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (check($packet) &amp;&amp; $packet[<span class="string">'num'</span>] == $expackNum) &#123;</span><br><span class="line">        <span class="comment">//解析报文</span></span><br><span class="line">        $data = extract($packet);</span><br><span class="line">        <span class="comment">//序号对的</span></span><br><span class="line">        <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">        <span class="comment">//把数据给应用层</span></span><br><span class="line">        deliver_data($data);</span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>, $expackNum);</span><br><span class="line">        $expackNum++;</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>, $expackNum);</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>在SR中，和GBN不同，SR是给每一个分组设置定时器，发送端只确认重传当前分组，而不是所有分组。接收端在接收到乱序的分组的时候会进行缓存，当前面的分组到达以后一起提交给应用层。</p>
<h4 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h4><ul>
<li>等待上层调用。这里和GBN一样</li>
<li>超时。超时哪个重传哪个</li>
<li>收到ACK。如果收到的是最小序号的ACK，那么base可以往前移动，也就是窗口滑动。如果收到其他序号的ACK。那么把这些ACK缓存。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$base = <span class="number">1</span>;</span><br><span class="line">$nextSeqNum = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet[$nextSeqNum] = make_pkt($data, $checkSum, $nextSeqNum);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet[$nextSeqNum]);</span><br><span class="line">    <span class="comment">//每个启动一个定时器</span></span><br><span class="line">    start_timer($nextSeqNum);    </span><br><span class="line">    <span class="comment">//如果超时</span></span><br><span class="line">    <span class="keyword">if</span> ($timeNum = timeout()) &#123;</span><br><span class="line">        <span class="comment">//重传超时的分组</span></span><br><span class="line">        udt_send($packet[$timeNum]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($isAck = rdt_rev() &amp;&amp; check($isAck)) &#123;</span><br><span class="line">        <span class="comment">//等待接收方回传ack 并且没有出现错误</span></span><br><span class="line">        <span class="comment">//获取确认的序号</span></span><br><span class="line">        $ackNum = getAckNum($isAck);</span><br><span class="line">        stop_timer($ackNum);</span><br><span class="line">        <span class="comment">//判断这个ACK是不是base</span></span><br><span class="line">        <span class="keyword">if</span> ($ackNum == $base) &#123;</span><br><span class="line">            ++$base;</span><br><span class="line">            <span class="comment">//判断缓存有没有</span></span><br><span class="line">            <span class="keyword">while</span>(array_key_exists(++$ackNum, $cache)) &#123;</span><br><span class="line">                <span class="comment">//如果下一个ack已经收到了，那么就把base接着往前移动</span></span><br><span class="line">                ++$base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//缓存起来</span></span><br><span class="line">            $cache[$ackNum] = $ackNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h4><ul>
<li>序号在rcv_base 至 rcv_base + N - 1内的分组被正确接受。如果该分组不是期望的分组，那么缓存，如果是，那么给应用层并且看缓存里面有没有后续，有就直接一起给应用层</li>
<li>序号在rcv_base - N 至 rcv_base - 1内的分组被正确接受。返回一个确认ACK。表示我已经收到了。</li>
<li>其他情况。忽略分组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的序号</span></span><br><span class="line">$expackNum = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (check($packet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($packet[<span class="string">'num'</span>] &gt; $expackNum &amp;&amp; $packet[<span class="string">'num'</span>] &lt; $expackNum + N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($packet[<span class="string">'num'</span>] == $expackNum) &#123;</span><br><span class="line">                <span class="comment">//是我们期望的，直接给应用层</span></span><br><span class="line">                <span class="comment">//解析报文</span></span><br><span class="line">                $data = extract($packet);</span><br><span class="line">                <span class="comment">//序号对的</span></span><br><span class="line">                <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">                <span class="comment">//把数据给应用层</span></span><br><span class="line">                deliver_data($data);</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                $ack = make_pkt(<span class="number">1</span>, $expackNum);</span><br><span class="line">                $expackNum++;</span><br><span class="line">                udt_send($ack);</span><br><span class="line">                <span class="comment">//查询缓存里面有没有</span></span><br><span class="line">                $key = $expackNum + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(array_key_exists($key, $cache)) &#123;</span><br><span class="line">                    <span class="comment">//如果下一个分组已经收到了，那么给应用层，并且滑动窗口</span></span><br><span class="line">                    deliver_data($cache[$expackNum]);</span><br><span class="line">                    ++$expackNum;</span><br><span class="line">                    $key++;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//缓存分组</span></span><br><span class="line">                $cache[$packet[<span class="string">'num'</span>]] = $packet;</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                $ack = make_pkt(<span class="number">1</span>, $packet[<span class="string">'num'</span>]);</span><br><span class="line">                udt_send($ack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>, $expackNum);</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三可靠数据传输原理实现SR选择重传协议</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0SR%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="网络原理自顶向下三可靠数据传输原理实现SR选择重传协议"><a href="#网络原理自顶向下三可靠数据传输原理实现SR选择重传协议" class="headerlink" title="网络原理自顶向下三可靠数据传输原理实现SR选择重传协议"></a>网络原理自顶向下三可靠数据传输原理实现SR选择重传协议</h1><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p>在SR中，和GBN不同，SR是给每一个分组设置定时器，发送端只确认重传当前分组，而不是所有分组。接收端在接收到乱序的分组的时候会进行缓存，当前面的分组到达以后一起提交给应用层。</p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><ul>
<li>等待上层调用。这里和GBN一样</li>
<li>超时。超时哪个重传哪个</li>
<li>收到ACK。如果收到的是最小序号的ACK，那么base可以往前移动，也就是窗口滑动。如果收到其他序号的ACK。那么把这些ACK缓存。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$base = <span class="number">1</span>;</span><br><span class="line">$nextSeqNum = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet[$nextSeqNum] = make_pkt($data, $checkSum, $nextSeqNum);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet[$nextSeqNum]);</span><br><span class="line">    <span class="comment">//每个启动一个定时器</span></span><br><span class="line">    start_timer($nextSeqNum);    </span><br><span class="line">    <span class="comment">//如果超时</span></span><br><span class="line">    <span class="keyword">if</span> ($timeNum = timeout()) &#123;</span><br><span class="line">        <span class="comment">//重传超时的分组</span></span><br><span class="line">        udt_send($packet[$timeNum]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($isAck = rdt_rev() &amp;&amp; check($isAck)) &#123;</span><br><span class="line">        <span class="comment">//等待接收方回传ack 并且没有出现错误</span></span><br><span class="line">        <span class="comment">//获取确认的序号</span></span><br><span class="line">        $ackNum = getAckNum($isAck);</span><br><span class="line">        stop_timer($ackNum);</span><br><span class="line">        <span class="comment">//判断这个ACK是不是base</span></span><br><span class="line">        <span class="keyword">if</span> ($ackNum == $base) &#123;</span><br><span class="line">            ++$base;</span><br><span class="line">            <span class="comment">//判断缓存有没有</span></span><br><span class="line">            <span class="keyword">while</span>(array_key_exists(++$ackNum, $cache)) &#123;</span><br><span class="line">                <span class="comment">//如果下一个ack已经收到了，那么就把base接着往前移动</span></span><br><span class="line">                ++$base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//缓存起来</span></span><br><span class="line">            $cache[$ackNum] = $ackNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><ul>
<li>序号在rcv_base 至 rcv_base + N - 1内的分组被正确接受。如果该分组不是期望的分组，那么缓存，如果是，那么给应用层并且看缓存里面有没有后续，有就直接一起给应用层</li>
<li>序号在rcv_base - N 至 rcv_base - 1内的分组被正确接受。返回一个确认ACK。表示我已经收到了。</li>
<li>其他情况。忽略分组</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//期望的序号</span></span><br><span class="line">$expackNum = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (check($packet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($packet[<span class="string">'num'</span>] &gt; $expackNum &amp;&amp; $packet[<span class="string">'num'</span>] &lt; $expackNum + N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($packet[<span class="string">'num'</span>] == $expackNum) &#123;</span><br><span class="line">                <span class="comment">//是我们期望的，直接给应用层</span></span><br><span class="line">                <span class="comment">//解析报文</span></span><br><span class="line">                $data = extract($packet);</span><br><span class="line">                <span class="comment">//序号对的</span></span><br><span class="line">                <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">                <span class="comment">//把数据给应用层</span></span><br><span class="line">                deliver_data($data);</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                $ack = make_pkt(<span class="number">1</span>, $expackNum);</span><br><span class="line">                $expackNum++;</span><br><span class="line">                udt_send($ack);</span><br><span class="line">                <span class="comment">//查询缓存里面有没有</span></span><br><span class="line">                $key = $expackNum + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(array_key_exists($key, $cache)) &#123;</span><br><span class="line">                    <span class="comment">//如果下一个分组已经收到了，那么给应用层，并且滑动窗口</span></span><br><span class="line">                    deliver_data($cache[$expackNum]);</span><br><span class="line">                    ++$expackNum;</span><br><span class="line">                    $key++;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//缓存分组</span></span><br><span class="line">                $cache[$packet[<span class="string">'num'</span>]] = $packet;</span><br><span class="line">                <span class="comment">//回传ACK</span></span><br><span class="line">                $ack = make_pkt(<span class="number">1</span>, $packet[<span class="string">'num'</span>]);</span><br><span class="line">                udt_send($ack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>, $expackNum);</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三可靠数据传输原理实现停等协议</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h1 id="网络原理自顶向下三可靠数据传输原理实现停等协议"><a href="#网络原理自顶向下三可靠数据传输原理实现停等协议" class="headerlink" title="网络原理自顶向下三可靠数据传输原理实现停等协议"></a>网络原理自顶向下三可靠数据传输原理实现停等协议</h1><p>这里仅考虑<code>单向可靠数据传输</code>。而不是<code>双向可靠数据传输</code>。</p>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="经完全可靠信道的可靠数据传输-rdt1-0版本"><a href="#经完全可靠信道的可靠数据传输-rdt1-0版本" class="headerlink" title="经完全可靠信道的可靠数据传输 rdt1.0版本"></a>经完全可靠信道的可靠数据传输 rdt1.0版本</h3><p>首先考虑最简单的版本，底层信道完全可靠。</p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><p>发送端应用层只需要调用<code>rdt_send</code>函数。网络层提供了一个函数<code>udt_send</code>来给运输层调用。现在假设<code>udt_send</code>是可靠的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet = make_pkt($data);</span><br><span class="line">    <span class="comment">//调用网络层传输</span></span><br><span class="line">    udt_send($packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><p>接收端网络层只需要调用<code>rdt_rev</code>函数。应用层提供了一个<code>deliver_data</code>函数来接受运输层的数据。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解析报文</span></span><br><span class="line">    $data = extract($packet);</span><br><span class="line">    <span class="comment">//把数据给应用层</span></span><br><span class="line">    deliver_data($data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>再来画一下对应的有限状态机（FSM）.</p>
<p>发送端只有一个状态，<code>等待调用</code>。</p>
<p><img src="" alt=""></p>
<p>接收端也只有一个状态，<code>等待调用</code>。</p>
<p><img src="" alt=""></p>
<h3 id="经比特差错信道的可靠数据传输rdt2-0"><a href="#经比特差错信道的可靠数据传输rdt2-0" class="headerlink" title="经比特差错信道的可靠数据传输rdt2.0"></a>经比特差错信道的可靠数据传输rdt2.0</h3><p>现在底层信道有可能造成比特的错误。</p>
<p>回想一下打电话的时候，如果我们说的话对方没听清，会怎么样。会<code>再说一遍</code>也就是<code>重传</code>。</p>
<p>那么什么情况下会<code>重传</code>。当接收方说<code>我没听清</code>的时候。</p>
<p>所以在<code>rdt2.0</code>里面我们让接收方接受完信息后回传一个标志，告诉我们<code>正确</code>还是<code>错误</code>。</p>
<p>如果正确，那么我们继续等待调用。</p>
<p>如果错误，那么我们<code>重传</code>。</p>
<p>基于这样重传机制的可靠数据传输协议称为<code>自动重传请求协议</code>（Automatic Repeat reQuest）ARQ,需要下面三个功能</p>
<ul>
<li>差错检测</li>
<li>接收方回传ack或者nak</li>
<li>重传</li>
</ul>
<h4 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h4><p>看一下发送端的简单实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet = make_pkt($data, $checkSum);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet);</span><br><span class="line">    <span class="comment">//等待接收方回传ack或者nak</span></span><br><span class="line">    $isAck = rdt_rev();</span><br><span class="line">    <span class="comment">//判断ack</span></span><br><span class="line">    <span class="keyword">if</span> ($isAck == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($isAck == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//收到了Nak分组，需要重传</span></span><br><span class="line">        <span class="keyword">return</span> rdt_send($data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (check($packet)) &#123;</span><br><span class="line">        <span class="comment">//解析报文</span></span><br><span class="line">        $data = extract($packet);</span><br><span class="line">        <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">        <span class="comment">//把数据给应用层</span></span><br><span class="line">        deliver_data($data);</span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>);</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有错，回传一个nak，不交付数据</span></span><br><span class="line">        $nak = make_pkt(<span class="number">0</span>);</span><br><span class="line">        udt_send($nak);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>现在发送端有两个状态</p>
<ul>
<li>等待调用</li>
<li>等待返回ack或nak</li>
</ul>
<p>接收端还是一个状态</p>
<ul>
<li>等待调用</li>
</ul>
<p>rdt2.0也被称为<code>停等协议</code>。因为发送端处于<code>等待ack</code>状态是不能被上层调用的。</p>
<h3 id="ack受损rdt2-1"><a href="#ack受损rdt2-1" class="headerlink" title="ack受损rdt2.1"></a>ack受损rdt2.1</h3><p>从上面的代码可以看出来，接收端发送<code>ack</code>使用的是<code>udt_send</code>函数，这个函数是不可靠的。那么如果我们的<code>ack</code>或者<code>nak</code>损坏了怎么办。</p>
<p>这时候可以像处理损坏分组一样。我们校验ack是否受损，如果受损，那么我们重传分组。</p>
<p>可是重传分组就会造成接收方不知道这个分组我有没有收到过。所以我们需要增加<code>分组序号</code>。</p>
<p>对于停等协议来说，0和1就够用了。因为停等协议只有两个状态，发完会等待ack。</p>
<h4 id="发送端-2"><a href="#发送端-2" class="headerlink" title="发送端"></a>发送端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet = make_pkt($data, $checkSum, $num);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet);</span><br><span class="line">    <span class="comment">//等待接收方回传ack或者nak</span></span><br><span class="line">    $isAck = rdt_rev();</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (check($isAck)) &#123;</span><br><span class="line">        <span class="comment">//没出问题，那么把改变序号</span></span><br><span class="line">        $num = !$num;</span><br><span class="line">        <span class="comment">//判断ack</span></span><br><span class="line">        <span class="keyword">if</span> ($isAck == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($isAck == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//收到了Nak分组，需要重传</span></span><br><span class="line">            <span class="keyword">return</span> rdt_send($data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//ack出问题了，那么这个时候重传</span></span><br><span class="line">        <span class="keyword">return</span> rdt_send($data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-2"><a href="#接收端-2" class="headerlink" title="接收端"></a>接收端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (check($packet)) &#123;</span><br><span class="line">        <span class="comment">//判断报文序号</span></span><br><span class="line">        <span class="keyword">if</span> ($packet[<span class="string">'num'</span>] == $num) &#123;</span><br><span class="line">            <span class="comment">//解析报文</span></span><br><span class="line">            $data = extract($packet);</span><br><span class="line">            <span class="comment">//序号对的</span></span><br><span class="line">            <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">            <span class="comment">//把数据给应用层</span></span><br><span class="line">            deliver_data($data);</span><br><span class="line">            <span class="comment">//回传ACK</span></span><br><span class="line">            $ack = make_pkt(<span class="number">1</span>, $num);</span><br><span class="line">            udt_send($ack);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//序号错了，说明这不是我们要的，我们回传一个ack，告诉发送端这个分组我们收到了。</span></span><br><span class="line">            <span class="comment">//回传ACK</span></span><br><span class="line">            $ack = make_pkt(<span class="number">1</span>, $num);</span><br><span class="line">            udt_send($ack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有错，回传一个nak，不交付数据</span></span><br><span class="line">        $nak = make_pkt(<span class="number">0</span>, $num);</span><br><span class="line">        udt_send($nak);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h4><p>发送端有4个状态</p>
<ul>
<li>等待调用0</li>
<li>等待ack0或者nak0</li>
<li>等待调用1</li>
<li>等待ack1或者nak1</li>
</ul>
<p>接收端有2个状态</p>
<ul>
<li>等待调用0</li>
<li>等待调用1</li>
</ul>
<h3 id="去掉nak分组的rdt2-2"><a href="#去掉nak分组的rdt2-2" class="headerlink" title="去掉nak分组的rdt2.2"></a>去掉nak分组的rdt2.2</h3><p>从上面的代码可以看出来，发送端在接收到<code>nak</code>的时候和丢失<code>ack</code>或者<code>nak</code>的时候都是重传。<br>所以我们只需要判断<code>ack</code>就可以了。那么同样接收方只需要回传<code>ack</code>就可以了。<br>这样一来，代码更见简单了。</p>
<h4 id="发送端-3"><a href="#发送端-3" class="headerlink" title="发送端"></a>发送端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet = make_pkt($data, $checkSum, $num);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet);</span><br><span class="line">    <span class="comment">//等待接收方回传ack</span></span><br><span class="line">    $isAck = rdt_rev();</span><br><span class="line">    <span class="comment">//差错检测</span></span><br><span class="line">    <span class="keyword">if</span> (check($isAck) &amp;&amp; $isAck[<span class="string">'num'</span>] == $num) &#123;</span><br><span class="line">        <span class="comment">//没出问题，那么把改变序号</span></span><br><span class="line">        $num = !$num;</span><br><span class="line">        <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//ack出问题了，那么这个时候重传</span></span><br><span class="line">        <span class="keyword">return</span> rdt_send($data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-3"><a href="#接收端-3" class="headerlink" title="接收端"></a>接收端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_rev</span><span class="params">($packet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//差错检测通过了并且报文序号正确</span></span><br><span class="line">    <span class="keyword">if</span> (check($packet) &amp;&amp; $packet[<span class="string">'num'</span>] == $num) &#123;</span><br><span class="line">        <span class="comment">//解析报文</span></span><br><span class="line">        $data = extract($packet);</span><br><span class="line">        <span class="comment">//序号对的</span></span><br><span class="line">        <span class="comment">//没有错，把数据交付给应用层并回传ack</span></span><br><span class="line">        <span class="comment">//把数据给应用层</span></span><br><span class="line">        deliver_data($data);</span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>, $num);</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没通过差错检测或者序号错误，我们回传一个上一个ack，告诉发送端上一个分组我们收到了，当前分组没收到。</span></span><br><span class="line">        <span class="comment">//回传ACK</span></span><br><span class="line">        $ack = make_pkt(<span class="number">1</span>, !$num);</span><br><span class="line">        udt_send($ack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="状态机-2"><a href="#状态机-2" class="headerlink" title="状态机"></a>状态机</h4><p>发送端有4个状态</p>
<ul>
<li>等待调用0</li>
<li>等待ack0或者nak0</li>
<li>等待调用1</li>
<li>等待ack1或者nak1</li>
</ul>
<p>接收端有2个状态</p>
<ul>
<li>等待调用0</li>
<li>等待调用1</li>
</ul>
<h3 id="经具有比特差错的丢包信道的可靠数据传输rdt3-0"><a href="#经具有比特差错的丢包信道的可靠数据传输rdt3-0" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输rdt3.0"></a>经具有比特差错的丢包信道的可靠数据传输rdt3.0</h3><p>现在底层信道除了会出错，还会丢包了。</p>
<p>如果遇到丢包怎么办呢，也就是接收方接收不到数据了。这个时候也就回传不了<code>ack</code>。</p>
<p>那么可以在发送端加上超时机制。如果长时间没收到<code>ack</code>。那么就重传分组。</p>
<h4 id="发送端-4"><a href="#发送端-4" class="headerlink" title="发送端"></a>发送端</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序号</span></span><br><span class="line">$num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rdt_send</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成校验和</span></span><br><span class="line">    $checkSum = generateCheckSum($data);</span><br><span class="line">    <span class="comment">//组装报文</span></span><br><span class="line">    $packet = make_pkt($data, $checkSum, $num);</span><br><span class="line">    <span class="comment">//调用网络层传输 </span></span><br><span class="line">    udt_send($packet);</span><br><span class="line">    <span class="comment">//启动一个定时器</span></span><br><span class="line">    start_timer();</span><br><span class="line">    <span class="comment">//等待接收方回传ack 并且没有超时</span></span><br><span class="line">    <span class="keyword">if</span> ($isAck = rdt_rev() &amp;&amp; !timeout()) &#123;</span><br><span class="line">        <span class="comment">//差错检测</span></span><br><span class="line">        <span class="keyword">if</span> (check($isAck) &amp;&amp; $isAck[<span class="string">'num'</span>] == $num) &#123;</span><br><span class="line">            <span class="comment">//没出问题，那么把改变序号</span></span><br><span class="line">            $num = !$num;</span><br><span class="line">            <span class="comment">//收到了Ack分组，可以结束了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ack出问题了，那么这个时候重传</span></span><br><span class="line">            <span class="keyword">return</span> rdt_send($data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没接收到ack或者超时 重发</span></span><br><span class="line">        <span class="keyword">return</span> rdt_send($data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接收端-4"><a href="#接收端-4" class="headerlink" title="接收端"></a>接收端</h4><p>无变化</p>
<h4 id="状态机-3"><a href="#状态机-3" class="headerlink" title="状态机"></a>状态机</h4><p>发送端</p>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><p>停等协议的缺点是性能受限。因为每次要等待上一个ack回来才能发送下一个报文。</p>
<p>而采用<code>流水线</code>就是不等待ack直接发送下一个报文。</p>
<p>这样会有下面的影响</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有序号</li>
<li>协议的发送方和接收方两端也许不得不缓存多个分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及时延大的分组。解决流水线的差错恢复有两种基本方法：<ul>
<li>回退N步（Go Back N）GBN</li>
<li>选择重传（Selective Repeat）SR</li>
</ul>
</li>
</ul>
<h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p><a href="https://blog.csdn.net/Thepatterraining/article/details/111138785" target="_blank" rel="noopener">滑动窗口协议</a></p>
<h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p><a href="https://blog.csdn.net/Thepatterraining/article/details/111138684" target="_blank" rel="noopener">选择重传协议</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络原理自顶向下三运输层</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%89%E8%BF%90%E8%BE%93%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h2><p>网络层是主机到主机，端到端的逻辑传输。</p>
<p>运输层是应用到应用，端口到端口的逻辑传输。</p>
<p>先由网络层送到主机，再通过运输层送到对应的端口程序中。</p>
<p>运输层将应用层报文封装成报文段交给网络层</p>
<p>将主机间交付扩展到进程间交付被称为<code>运输层的多路复用和多路分解</code></p>
<p>UDP提供不可靠服务</p>
<ul>
<li>差错检测</li>
<li>数据交付</li>
</ul>
<p>TCP提供可靠服务</p>
<ul>
<li>流量控制</li>
<li>序号</li>
<li>确认</li>
<li>定时器</li>
<li>拥塞控制</li>
</ul>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>源主机使用多路复用把多个套接字进程的报文发送给目的主机</p>
<p>目的主机使用多路分解把报文发送给多个套接字进程</p>
<p>运输层需要再首部信息加入</p>
<ul>
<li>源端口号</li>
<li>目的端口号</li>
</ul>
<p>通过端口号来区分进程</p>
<p>UDP套接字通过二元组来标识</p>
<ul>
<li>目的端口号</li>
<li>目的ip<br>只要你的目的ip和端口号相同就算你的源ip和端口不一样，也会分解到同一个套接字</li>
</ul>
<p>TCP通过四元组来标识</p>
<ul>
<li>源ip</li>
<li>源端口</li>
<li>目的Ip</li>
<li>目的端口</li>
</ul>
<p>这是因为TCP会创建链接，一个TCP进程有一个“欢迎套接字”，用来等待程序过来，然后创建一个新的套接字来进行通信。</p>
<p>如果四元组一致会分解到一个套接字，不一致，会分解到另外的套接字。</p>
<h3 id="web服务器和TCP"><a href="#web服务器和TCP" class="headerlink" title="web服务器和TCP"></a>web服务器和TCP</h3><p>现在的计算机有线程的概念，所以TCP链接一般也不会创建多个进程来服务不同的客户端，而是创建多个线程套接字，通过分解到不同的线程套接字来服务多个客户端。</p>
<h2 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h2><p>UDP只提供了运输层最低限度的东西。</p>
<ul>
<li>差错检测</li>
<li>复用分解</li>
</ul>
<p>DNS是使用UDP的一个应用层协议.</p>
<p>UDP存在的意义及优势：</p>
<ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细。<br>采用UDP时，只要应用将数据给UDP,UDP就会直接传递给IP网络层。TCP有<code>拥塞控制</code>和重发机制，但是这样会需要更长的时间。因为实时应用通常要求最小的发送速率，不希望过分的延迟报文段的传送，且能容忍一部分数据丢失，TCP服务模型并不是特别适合这些应用的需要。这些应用使用UDP，并可以再应用层实现所需的，超出UDP的额外功能。</li>
<li>无需链接建立<br>TCP需要三次握手建立链接，UDP不需要。因此没有建立链接的时延。</li>
<li>无连接状态<br>TCP需要再端系统中维护链接状态。此链接状态包括接受和发送缓存，拥塞控制参数以及序号与确认号的参数。UDP一般能支持更多的活跃用户。</li>
<li>分组首部开销小<br>每个TCP报文段首部有20字节，UDP只有8字节</li>
</ul>
<p>UDP也可以通过应用层实现<code>可靠性传输</code>。比如chrome的<code>QUIC协议</code>。</p>
<h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><ul>
<li>首部字段 8字节<ul>
<li>源端口号 2字节</li>
<li>目的端口号 2字节</li>
<li>长度 2字节 数据长度</li>
<li>校验和 2字节 差错检测</li>
</ul>
</li>
<li>数据</li>
</ul>
<h3 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h3><p>发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和时候遇到的任何溢出都被回卷。得到的结果被放在UDP报文段中的校验和字段。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>如果有三个16比特的字：</p>
<p>0110011001100000<br>0101010101010101<br>1000111100001100</p>
<p>计算他们的和</p>
<p> 0110011001100000<br>+0101010101010101<br>=1011101110110101<br>+1000111100001100<br>=0100101011000001</p>
<p>这个时候溢出了，把溢出的1加到后面<br>=0100101011000010</p>
<p>进行反码运输，把1变0，0变1<br>=1011010100111101</p>
<p>这就变成了校验和。</p>
<p>接收方将三个16比特和校验和加在一起，如果全是1，那么就没问题。如果有0，那么就有差错。</p>
<p>把上面的和加上校验和算一下<br> 0100101011000010<br>+1011010100111101<br>=1111111111111111</p>
<p>UDP虽然实现了<code>差错检测</code>，但是没有<code>差错恢复</code>。他只是丢弃受损的报文段。其他实现是将受损的报文段交给应用程序并给出警告。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP提供<code>全双工服务</code>。双方都可以发送数据。</p>
<p>TCP首先建立连接。然后把数据引导到<code>发送缓存</code>中。从发送缓存中取出数据进行发送。取出的数量受限于<code>最大报文段长度</code>MSS。MSS一般根据<code>最大链路层帧长度</code>MTU。以太网和PPP链路层都具有1500MTU。所以MSS的典型值在1460 + 40字节的TCP/IP首部长度。</p>
<p>TCP报文段结构：</p>
<ul>
<li>源端口号 16比特</li>
<li>目的端口号 16比特</li>
<li>序号 32比特</li>
<li>确认号 32比特</li>
<li>接收窗口 16比特 用于流量控制</li>
<li>首部长度 4比特</li>
<li>选项字段 可选变长</li>
<li>标志字段 6比特<ul>
<li>ACK用于确认</li>
<li>RST, SYN, FIN用于连接建立和删除</li>
<li>拥塞通告中使用 CWR和ECE字段</li>
<li>PSH置位标识接收方应立即将数据交给上层</li>
<li>URG用来指示紧急数据</li>
</ul>
</li>
<li>紧急数据指针字段 16比特</li>
<li>校验和 16比特</li>
</ul>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><h4 id="估计往返时间"><a href="#估计往返时间" class="headerlink" title="估计往返时间"></a>估计往返时间</h4><p>估计一个SampleRTT作为样本，根据SampleRTT取平均值，也就是EstimatedRTT。</p>
<p>EstimatedRTT = (1 - a) * EstimatedRTT + a * SmapleRTT</p>
<p>a的推荐值是0.125。</p>
<p>RTT的偏差用DevRTT表示</p>
<p>DevRTT = (1 - b) * DevRTT + b * |SampleRTT - EstimatedRTT|</p>
<p>b的推荐值是0.25</p>
<h4 id="设置和管理重传超时间隔"><a href="#设置和管理重传超时间隔" class="headerlink" title="设置和管理重传超时间隔"></a>设置和管理重传超时间隔</h4><p>超时间隔应该 &gt;= EstimatedRTT。但是也不能大太多</p>
<p>TimeoutInterval = EstimatedRTT + 4 * DevRTT</p>
<p>TCP设置单一的定时器，每当超时一次超时时间会加倍，以免造成网络拥塞。</p>
<p>TCP收到同一个ACK三次，会进行快速重传而不等待定时器超时。</p>
<p>TCP采用的是GBN和SR的混合体。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP有发送缓存和接收缓存。接收方把数据放入接收缓存，然后读取到应用层。</p>
<p>当发送数据太多，为防止接收缓存装不下，需要控制发送端发送数量。</p>
<p><code>接收窗口</code>字段就是这个作用，用来控制接收方还有多少空间。发送方就可以根据这个调整发送数量。</p>
<p>如果接收缓存已经满了。那么发送方依旧会发送1比特的数据。这样才能知道接收方变化后的接收缓存大小。</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>第一步：发送一个SYN = 1 Seq = 随机序号</li>
<li>第二步：返回一个SYN = 1 Seq = 随机序号 Ack = Seq + 1</li>
<li>第三步：SYN = 0 Seq = Ack Ack = Seq + 1 可以携带数据</li>
</ul>
<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><ul>
<li>第一步：发送一个FIN = 1</li>
<li>第二步：接收一个ACK</li>
<li>第三步：接收一个FIN = 1</li>
<li>第四步：发送一个ACK</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li><p>端到端的拥塞控制。网络层不提供支持，端系统观察网络层得到结果。</p>
</li>
<li><p>网络辅助的拥塞控制。</p>
</li>
<li><p>丢失的报文段表示拥塞，降低发送速率。</p>
</li>
<li><p>确认报文段表示顺利，提高发送速率</p>
</li>
<li><p>带宽检测，逐步提高发送速率，如果丢失超时就降低然后接着提高。</p>
</li>
</ul>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>开始速率较小。大概MSS/RTT.<br>每当收到一个确认，就增加一个MSS。也就是指数级增长，不断翻倍。<br>何时结束？</p>
<ul>
<li>遇到丢包超时</li>
<li>达到一个阈值</li>
</ul>
<p>结束慢启动进入拥塞避免模式</p>
<h4 id="拥塞避免模式"><a href="#拥塞避免模式" class="headerlink" title="拥塞避免模式"></a>拥塞避免模式</h4><p>不再郑家指数级，而是一个一个增长。线性增长</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu安装supervisor守护进程</title>
    <url>/ubuntu%E5%AE%89%E8%A3%85supervisor%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h1><p>supervisor是一个守护进程软件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu安装很简单。直接apt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>修改配置项，加入我们的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;supervisor&#x2F;conf.d&#x2F;test.conf</span><br></pre></td></tr></table></figure>

<p>复制下面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:命令名称]</span><br><span class="line">;目录</span><br><span class="line">;directory&#x3D;&#x2F;test 这里我注释掉了，如果你加上以后报错可以注释掉试试</span><br><span class="line">;执行的命令如果没有配置环境变量或者软连接请使用全路径</span><br><span class="line">command&#x3D;php &#x2F;test&#x2F;think queue:listen --queue im</span><br><span class="line">process_name&#x3D;%(program_name)s_%(process_num)02d;</span><br><span class="line">numprocs &#x3D; 3</span><br><span class="line">autostart &#x3D; true</span><br><span class="line">startsecs &#x3D; 5</span><br><span class="line">autorestart &#x3D; true</span><br><span class="line">startretries &#x3D; 3</span><br><span class="line">;执行的linux用户</span><br><span class="line">user&#x3D;root</span><br><span class="line">redirect_stderr &#x3D; true</span><br><span class="line">stdout_logfile_maxbytes &#x3D; 50MB</span><br><span class="line">stdout_logfile_backups &#x3D; 20</span><br><span class="line">;日志位置</span><br><span class="line">stdout_logfile &#x3D; &#x2F;var&#x2F;log&#x2F;supervisor&#x2F;queue_worker.log</span><br><span class="line">loglevel&#x3D;info</span><br></pre></td></tr></table></figure>

<p>然后启动supervisor，因为是apt安装的，所以很好启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service supervisor start</span><br></pre></td></tr></table></figure>

<p>查看启动了没有，有两种方法，一种status命令，还有一种查看linux进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service supervisor status</span><br></pre></td></tr></table></figure>

<p>查看进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux |grep super</span><br></pre></td></tr></table></figure>

<p>再查看我们的命令挂起来没有。我们执行的php命令所以直接查看php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux|grep php</span><br></pre></td></tr></table></figure>
<p>如果看见刚刚的命令就成功了。</p>
]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>php-simplexml解析一个或多个结构的坑</title>
    <url>/php-simplexml%E8%A7%A3%E6%9E%90%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BB%93%E6%9E%84%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<h1 id="php-simplexml解析一个或多个结构的坑"><a href="#php-simplexml解析一个或多个结构的坑" class="headerlink" title="php-simplexml解析一个或多个结构的坑"></a>php-simplexml解析一个或多个结构的坑</h1><p>php解析xml还是挺方便的，不管是正常的xml，还是加了一个命名空间或者前缀的xml。都可以通过<code>simplexml_load_string</code>函数来解析成数组或者对象。</p>
<h2 id="simplexml-load-string"><a href="#simplexml-load-string" class="headerlink" title="simplexml_load_string"></a>simplexml_load_string</h2><p>来看一下使用方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$xml = <span class="string">"&lt;reports&gt;&lt;report&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;/reports&gt;"</span></span><br><span class="line"></span><br><span class="line">$arr = (<span class="keyword">array</span>)simplexml_load_string($xml);</span><br></pre></td></tr></table></figure>

<p>是不是很简单，如果你的带啦前缀或者命名空间也可以使用。下面带了s前缀</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$xml = <span class="string">"&lt;s:reports&gt;&lt;s:report&gt;&lt;s:id&gt;1&lt;/id&gt;&lt;s:name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;/reports&gt;"</span></span><br><span class="line"></span><br><span class="line">$arr = (<span class="keyword">array</span>)simplexml_load_string($xml,<span class="string">'SimpleXMLElement'</span>,<span class="number">0</span>,<span class="string">'s'</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>但是如果带了多个前缀，这个函数就无能为力了，可以使用别的方法解析。</p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>不过这个函数解析一个和多个结果是不一样的，这里解析出来一定要做判断！！！</p>
<p>下面有两个report，解析出的结果是一个数组。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$xml = <span class="string">"&lt;reports&gt;&lt;report&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;report&gt;&lt;id&gt;1&lt;/id&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/report&gt;&lt;/reports&gt;"</span></span><br><span class="line"></span><br><span class="line">$arr = (<span class="keyword">array</span>)simplexml_load_string($xml);</span><br></pre></td></tr></table></figure>

<p>而上面只有一个report的时候，解析出来就是一个对象！！！</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>php-thinkphp-报错Creating default object from empty value</title>
    <url>/php-thinkphp-%E6%8A%A5%E9%94%99Creating%20default%20object%20from%20empty%20value.html</url>
    <content><![CDATA[<h1 id="php-thinkphp-报错Creating-default-object-from-empty-value"><a href="#php-thinkphp-报错Creating-default-object-from-empty-value" class="headerlink" title="php-thinkphp-报错Creating default object from empty value"></a>php-thinkphp-报错Creating default object from empty value</h1><p>报错第一步，打印，打印日志，在你用到对象的地方，把对象都打印出来看看，你以为他是个对象，但他。。。不一定是个对象！！！</p>
<p>如果你确定你从数据库查询出来的没有错，是个对象，那么。。请看一下你别的对象是不是一个对象！！！</p>
<p>要相信报错，一定是对象错了，但你不确定，所以，请打印日志，如果你这里没问题，别人那里有问题，那么可能是参数的问题。打印日志在别人那就能看到你想的对象可能在他那里不是一个对象！！！</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp-queue队列使用</title>
    <url>/thinkphp-queue%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="thinkphp-queue队列使用"><a href="#thinkphp-queue队列使用" class="headerlink" title="thinkphp-queue队列使用"></a>thinkphp-queue队列使用</h1><p>在我们写程序的时候，经常会用到队列来完成一些操作，关于队列的介绍和使用场景，注意事项可以看我的这个文章<a href="https://blog.csdn.net/Thepatterraining/article/details/105344675" target="_blank" rel="noopener">你不知道的队列使用技巧</a></p>
<h2 id="在tp里面使用队列"><a href="#在tp里面使用队列" class="headerlink" title="在tp里面使用队列"></a>在tp里面使用队列</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>tp</code>框架提供了一个扩展包，叫做<code>think-queue</code>。我们先来安装这个扩展包。</p>
<blockquote>
<p>composer require topthink/think-queue</p>
</blockquote>
<h3 id="配置消息队列"><a href="#配置消息队列" class="headerlink" title="配置消息队列"></a>配置消息队列</h3><p>等待安装完成之后，我们需要进行配置，消息队列的消息存放在哪里，可以配置成redis。</p>
<p>配置在你的<code>config/queue.php</code>里面。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'default'</span>     =&gt; <span class="string">'redis'</span>,  <span class="comment">//默认是sync，改成redis</span></span><br><span class="line"></span><br><span class="line"><span class="string">'connections'</span> =&gt; [</span><br><span class="line">        <span class="string">'redis'</span>    =&gt; [</span><br><span class="line">            <span class="string">'type'</span>       =&gt; <span class="string">'redis'</span>,</span><br><span class="line">            <span class="string">'queue'</span>      =&gt; <span class="string">'default'</span>,</span><br><span class="line">            <span class="string">'host'</span>       =&gt; env(<span class="string">'queue.host'</span>, <span class="string">'127.0.0.1'</span>),</span><br><span class="line">            <span class="string">'port'</span>       =&gt; env(<span class="string">'queue.port'</span>, <span class="number">6379</span>),</span><br><span class="line">            <span class="string">'password'</span>   =&gt; env(<span class="string">'queue.password'</span>, <span class="string">''</span>),</span><br><span class="line">            <span class="string">'select'</span>     =&gt; <span class="number">0</span>,      <span class="comment">// 使用哪一个 db，默认为 db0</span></span><br><span class="line">            <span class="string">'timeout'</span>    =&gt; <span class="number">0</span>,      <span class="comment">// redis连接的超时时间</span></span><br><span class="line">            <span class="string">'persistent'</span> =&gt; <span class="keyword">false</span>,  <span class="comment">// 是否是长连接</span></span><br><span class="line">        ],</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>

<h3 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h3><p>配置完成以后我们就可以开始使用了。</p>
<p>在我们的<code>controller</code>里面把一个消息推送到队列里面。这里我们定义一个队列名称叫做<code>message</code>,定义一个处理队列消息的消费者类<code>app\common\queue\consumer</code>。然后调用<code>Queue</code>门面的<code>push</code>方法，把消费者，队列名称，数据传入进去就可以了。这个时候就会把数据放到<code>message</code>这个队列里面。然后消费者取出数据进行处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">api</span>\<span class="title">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">BaseController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">facade</span>\<span class="title">Queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $consumer = <span class="string">'app\common\queue\consumer'</span>;  <span class="comment">//消费者类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $queue = <span class="string">'message'</span>; <span class="comment">//队列名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;request-&gt;isPost()) &#123;</span><br><span class="line">            <span class="comment">//要推送到队列里面的数据</span></span><br><span class="line">            $jobData = [];</span><br><span class="line">            $jobData[<span class="string">"a"</span>] = <span class="string">'a'</span>;</span><br><span class="line">            $jobData[<span class="string">'b'</span>] = <span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line">            $res = Queue::push(<span class="keyword">$this</span>-&gt;consumer, $data, <span class="keyword">$this</span>-&gt;queue);</span><br><span class="line">            <span class="keyword">return</span> json([]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>我们接下来实现我们上面定义的消费者。来处理我们的逻辑。</p>
<p>消费者<code>app\common\queue\consumer</code>类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">common</span>\<span class="title">queue</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">use</span> <span class="title">think</span>\<span class="title">queue</span>\<span class="title">Job</span>;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * fire方法是消息队列默认调用的方法</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> Job            $job      当前的任务对象</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> array|mixed    $data     发布任务时自定义的数据</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fire</span><span class="params">(Job $job,$data)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="comment">// 有些消息在到达消费者时,可能已经不再需要执行了</span></span><br><span class="line">         $isJobStillNeedToBeDone = <span class="keyword">$this</span>-&gt;check($data);</span><br><span class="line">         <span class="keyword">if</span>(!$isJobStillNeedToBeDone)&#123;</span><br><span class="line">             $job-&gt;delete();  <span class="comment">//删除任务</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       </span><br><span class="line">         <span class="comment">//执行任务</span></span><br><span class="line">         $isJobDone = <span class="keyword">$this</span>-&gt;doJob($data);</span><br><span class="line">       </span><br><span class="line">         <span class="keyword">if</span> ($isJobDone) &#123;</span><br><span class="line">             <span class="comment">// 如果任务执行成功， 记得删除任务</span></span><br><span class="line">             $job-&gt;delete();</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span> ($job-&gt;attempts() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                 <span class="comment">//通过这个方法可以检查这个任务已经重试了几次了</span></span><br><span class="line"> 				  $job-&gt;delete();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 有些消息在到达消费者时,可能已经不再需要执行了</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> array|mixed    $data     发布任务时自定义的数据</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> boolean                 任务执行的结果</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">($data)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 根据消息中的数据进行实际的业务处理...</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">doJob</span><span class="params">($data)</span> </span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         dump($data);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就完成了代码的逻辑，也就是发布消息，消费消息。</p>
<p>接下来我们启动这个队列。</p>
<h3 id="启动队列"><a href="#启动队列" class="headerlink" title="启动队列"></a>启动队列</h3><p>启动队列有两种方式。</p>
<ul>
<li>work</li>
<li>listen</li>
</ul>
<p><code>work</code>方式启动。这种方式是单进程运行。如果你更新了代码需要手动重启队列。</p>
<blockquote>
<p>php think queue:work –queue message  //我们刚刚定义的队列名称</p>
</blockquote>
<p><code>listen</code>方式启动。这种方式是master-worker模型。一个master主进程来监听，当请求进来了启动一个work子进程来运行上面的work方式启动。</p>
<blockquote>
<p>php think queue:listen –queue message</p>
</blockquote>
<p>我更推荐listen方式来运行。这种方式更新代码后也不需要手动重启。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp-queue队列导致MySQL server has gone away</title>
    <url>/thinkphp-queue%E9%98%9F%E5%88%97%E5%AF%BC%E8%87%B4MySQL%20server%20has%20gone%20away.html</url>
    <content><![CDATA[<h1 id="thinkphp-queue队列导致MySQL-server-has-gone-away"><a href="#thinkphp-queue队列导致MySQL-server-has-gone-away" class="headerlink" title="thinkphp-queue队列导致MySQL server has gone away"></a>thinkphp-queue队列导致MySQL server has gone away</h1><p>虽然队列一时爽，不过还是有缺点的，比如当队列运行时间长了会报错 MySQL server has gone away</p>
<p>原因是使用<code>work</code>模式运行时间长了以后没有释放mysql数据库的链接，导致时间长了以后被mysql server端判断超时切断了链接。</p>
<p>可以改用<code>listen</code>模式运行，这样每次都是启动一个新的work进程来运行程序，每次都会新链接数据库。</p>
<p>可以使用tp的断线重连功能。修改配置文件<code>config/database.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数据库连接配置信息</span></span><br><span class="line">    <span class="string">'connections'</span>     =&gt; [</span><br><span class="line">        <span class="string">'mysql'</span> =&gt; [</span><br><span class="line">            <span class="comment">// 是否需要断线重连</span></span><br><span class="line">            <span class="string">'break_reconnect'</span>   =&gt; <span class="keyword">true</span>,</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>php-mpdf扩展包中文乱码问题</title>
    <url>/php-mpdf%E6%89%A9%E5%B1%95%E5%8C%85%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="php-mpdf扩展包中文乱码问题"><a href="#php-mpdf扩展包中文乱码问题" class="headerlink" title="php-mpdf扩展包中文乱码问题"></a>php-mpdf扩展包中文乱码问题</h1><p><a href="http://mpdf.github.io/fonts-languages/fonts-in-mpdf-7-x.html" target="_blank" rel="noopener">mpdf</a>是一个可以把html网页转换成pdf文件的扩展包。一开始使用的时候，发现中文乱码了。。在网上查了半天，好多方法都不管用。</p>
<p>最后，在他的文档里面找到了问题原因。</p>
<p>想要输出中文，有两个参数至关重要！！！</p>
<ul>
<li>autoLangToFont 这个值一定要设置为true才可以</li>
<li>autoScriptToLang 这个值也一定要设置为true才可以</li>
</ul>
<p>只要上面两个设置为true，那么你的中文就可以正常输出了。相信我，不能正常输出你来打我。</p>
<p>看一下mpdf文档上面的描述。</p>
<p>!(mpdf)[../images/mpdf1.png]</p>
<p>!(mpdf)[../images/mpdf2.png]</p>
<p>可以看到默认值是false，所以我们使用的时候需要改成true。</p>
<p>设置这两个值也很简单。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Mpdf</span>\<span class="title">Mpdf</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $pdf = <span class="keyword">new</span> Mpdf;</span><br><span class="line">    $pdf-&gt;autoLangToFont = <span class="keyword">true</span>;</span><br><span class="line">    $pdf-&gt;autoScriptToLang = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    $pdf-&gt;writeHTML(<span class="string">'&lt;h1&gt;123&lt;/h1&gt;'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> $pdf-&gt;output(<span class="string">'./test.pdf'</span>, <span class="string">'D'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，mpdf的文档最开始是有错误的，他的文档中写的默认值是<code>true</code>而不是现在的<code>false</code>。不过从他的源码上可以看到他的默认值其实是<code>false</code>。</p>
<p>源码位置：<code>vendor/mpdf/mpdf/src/Config/ConfigVariables.php</code>里面。<br>这个文件里面是很多变量的默认值，在这里面搜索可以看到这两个值是false。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// AUTOMATIC FONT SELECTION</span></span><br><span class="line"><span class="comment">// Based on script and/or language</span></span><br><span class="line"><span class="comment">// mPDF 6.0 (similar to previously using function SetAutoFont() )</span></span><br><span class="line"><span class="string">'autoScriptToLang'</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// mPDF 6.0 (similar to old useLang)</span></span><br><span class="line"><span class="string">'autoLangToFont'</span> =&gt; <span class="keyword">false</span>,</span><br></pre></td></tr></table></figure>

<p>我给他们的github上面提了一个issue，他们才把文档改过来了。</p>
<p>!(mpdf)[../images/mpdf3.png]</p>
<p>最后附上mpdf官方文档：</p>
<blockquote>
<p><a href="http://mpdf.github.io/fonts-languages/fonts-in-mpdf-7-x.html" target="_blank" rel="noopener">http://mpdf.github.io/fonts-languages/fonts-in-mpdf-7-x.html</a></p>
</blockquote>
<p>我给他们提的issue:</p>
<blockquote>
<p><a href="https://github.com/mpdf/mpdf.github.io/issues/141" target="_blank" rel="noopener">https://github.com/mpdf/mpdf.github.io/issues/141</a></p>
</blockquote>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mpdf</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp-tp6使用chunk分块操作数据的坑</title>
    <url>/thinkphp-tp6%E4%BD%BF%E7%94%A8chunk%E5%88%86%E5%9D%97%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%91.html</url>
    <content><![CDATA[<h1 id="thinkphp-tp6使用chunk分块操作数据的坑"><a href="#thinkphp-tp6使用chunk分块操作数据的坑" class="headerlink" title="thinkphp-tp6使用chunk分块操作数据的坑"></a>thinkphp-tp6使用chunk分块操作数据的坑</h1><p>有的时候我们会遇到需要定时操作数据的需求，比如定时更新所有用户的权益，徽章等等。这个时候你不能一次性取出所有数据来进行操作，因为数据量太大了，我们一次取出全部，先不说mysql数据库会很慢，就算取出来传给你，网络开销也很大。这时候你通过网络接收到数据以后，会把这些数据放到一个变量里面。这个变量是存在内存中的，如果过大还会导致内存溢出，内存不足的问题。</p>
<p>所以我们就需要分页取出数据来进行操作，比如每次取出100条，操作完了再取出下100条。而tp框架提供了一个方便的<code>chunk</code>方法来供我们使用，免去了我们需要手动<code>limit</code>分页的麻烦。</p>
<p>我之前使用过laravel的chunk，以为两个差不多，看了文档也觉得差不多。下图是tp6文档的描述。</p>
<p><img src="../images/tp-chunk1.png" alt="tp"></p>
<p>其实单表这么写也没有什么问题，不过一旦你使用了连表查询，就出现问题了。。而他的文档并没有说连表的问题。</p>
<p>虽然他的文档有这么一段也说明了主键和排序的问题。</p>
<p><img src="../images/tp-chunk2.png" alt="tp"></p>
<p>但是，没想到连表的时候是必须，注意，必须！！！传主键，不然他不知道是哪个表的主键。而laravel就没有这个问题。。</p>
<p>我当时写的时候去找了他的源码，才看到这个问题，因为我正常写完后一直报错。。</p>
<p>看一下他的源码。源码位置在<code>./vendor/topthink/think-orm/src/db/query.php</code>里面的<code>chunk</code>方法。</p>
<p><img src="../images/tp-chunk3.png" alt="tp"></p>
<p><img src="../images/tp-chunk4.png" alt="tp"></p>
<p>从这里可以看到他有4个参数。</p>
<ul>
<li>count 每次处理的数量</li>
<li>callback 处理的回调函数</li>
<li>column 处理的字段名 默认 null</li>
<li>order 字段排序 默认asc</li>
</ul>
<p>前两个我们必传，后面的可选。</p>
<p>他的第二行代码，如果你传了第三个参数，那么使用你传的，不然调用getPk这个函数。这个函数在源码里面也有，就是获取主键。假设你不传，你的主键是id，那么<code>column</code>这个变量就是id。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$column  = $column ?: <span class="keyword">$this</span>-&gt;getPk();</span><br></pre></td></tr></table></figure>

<p>接下来的代码你会发现你的<code>column</code>参数，还可以传一个数组。如果是一个数组，那么他在这里不使用这个参数。</p>
<p>如果你传的不是一个数组，那么看有没有<code>.</code>也就是连不连表。因为连表你传的是<code>a.id</code>。如果连表那么<code>explode</code>分割成数组[a,id]的形式。</p>
<p>如果你传的就是<code>id</code>那么直接赋值给变量<code>key</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_array($column)) &#123;</span><br><span class="line">    $times = <span class="number">1</span>;</span><br><span class="line">    $query = <span class="keyword">$this</span>-&gt;options($options)-&gt;page($times, $count);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $query = <span class="keyword">$this</span>-&gt;options($options)-&gt;limit($count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strpos($column, <span class="string">'.'</span>)) &#123;</span><br><span class="line">        [$alias, $key] = explode(<span class="string">'.'</span>, $column);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $key = $column;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是真正获取数据，然后调用回调函数，再重复获取数据的过程了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$resultSet = $query-&gt;order($column, $order)-&gt;select();</span><br></pre></td></tr></table></figure>

<p>这里可以看到，我们传数组，那么数组就会直接给<code>order</code>函数，如果是连表的主键<code>a.id</code>，那么就会把[a,id]给<code>order</code>函数，如果是单表，那么默认<code>id</code>主键给<code>order</code>函数。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title>php yii2框架前端加载css和js文件的方法</title>
    <url>/php%20yii2%E6%A1%86%E6%9E%B6%E5%89%8D%E7%AB%AF%E5%8A%A0%E8%BD%BDcss%E5%92%8Cjs%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="php-yii2框架前端加载css和js文件的方法"><a href="#php-yii2框架前端加载css和js文件的方法" class="headerlink" title="php yii2框架前端加载css和js文件的方法"></a>php yii2框架前端加载css和js文件的方法</h1><p>这两天有一个以前的项目是用<code>yii2</code>框架写的，前后端没有做分离，现在需要用vue接手后续的前端开发。</p>
<p>把vue的项目放到yii2里面，这时候遇到一个加载静态资源的问题，原来html的引用方式不管用了。</p>
<p>后来看到yii2官方文档里面，需要改一下引用方式。</p>
<p>改成下面这样就可以了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;registerCssFile(<span class="string">"@web/static_vue/css/index.css"</span>)</span><br><span class="line"><span class="keyword">$this</span>-&gt;registerJsFile(<span class="string">"@web/static_vue/js/index.js"</span>)</span><br></pre></td></tr></table></figure>

<p>所有都使用这两个php代码进行引入，引入后就可以了。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>js</tag>
        <tag>yii2</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装php环境</title>
    <url>/wsl%E5%AE%89%E8%A3%85php%E7%8E%AF%E5%A2%83.html</url>
    <content><![CDATA[<h1 id="wsl"><a href="#wsl" class="headerlink" title="wsl"></a>wsl</h1><p>wsl是可以在windows里面运行linux的一个软件。是微软官方发行的。</p>
<h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h2><p>从php官网下载php tar包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget https:&#x2F;&#x2F;www.php.net&#x2F;distributions&#x2F;php-7.4.12.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf php-7.4.12.tar.gz</span><br></pre></td></tr></table></figure>

<p>接下来需要安装一些扩展来支持php。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc make pkg-config libxml2-dev libssl-dev libsqlite3-dev libcurl4-openssl-dev libonig-dev zlib1g-dev libffi-dev libpng-dev libzip-dev</span><br></pre></td></tr></table></figure>

<p>不安装上面的扩展会导致接下来报错。</p>
<p>切换目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .&#x2F;php-7.4.12</span><br></pre></td></tr></table></figure>

<p>执行configure,注意这里<code>prefix</code>一定要是/usr/local/php7，要不然找不到配置文件php.ini。这里有这个坑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --enable-fpm --with-mysql --with-pear --with-zip --enable-sockets --enable-soap --with-pdo-mysql  --enable-gd --enable-ftp --with-ffi  --with-zlib  --with-curl --with-openssl --enable-mbstring --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;php7 --with-config-file-path&#x3D;&#x2F;usr&#x2F;local&#x2F;php7 --with-external-gd --with-webp  --with-jpeg  --with-xpm  --with-freetype  --enable-bcmath</span><br></pre></td></tr></table></figure>

<p>执行完上面一步如果没有错误就可以了。</p>
<p>接下来执行make</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>建立软连接或者环境变量。我们要配置全局的环境变量有两种方式。</p>
<ul>
<li>在环境变量目录里面增加软连接</li>
<li>把php目录增加到环境变量里面</li>
</ul>
<p>我采用的是软连接的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;php7&#x2F;bin&#x2F;php &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;php7&#x2F;bin&#x2F;phpize &#x2F;usr&#x2F;local&#x2F;bin&#x2F;phpize</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;php7&#x2F;sbin&#x2F;php-fpm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php-fpm</span><br></pre></td></tr></table></figure>

<p>接下来就可以全局使用php命令了</p>
<h3 id="php-fpm启动，重启方法"><a href="#php-fpm启动，重启方法" class="headerlink" title="php-fpm启动，重启方法"></a>php-fpm启动，重启方法</h3><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo php-fpm</span><br></pre></td></tr></table></figure>

<p>重启 先找到进程 然后发送<code>USR2</code>信号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -aux | grep php</span><br><span class="line"></span><br><span class="line">sudo kill -USR2 进程id</span><br></pre></td></tr></table></figure>


<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>访问nginx的<a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a>进行下载。</p>
<p>复制下载地址。比如我下载的1.19.5,直接下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.19.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>然后解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf nginx-1.19.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>接下来需要安装一些扩展来支持php。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure>

<p>切换目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .&#x2F;nginx-1.19.5</span><br></pre></td></tr></table></figure>

<p>执行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>好了，安装完成。</p>
<p>同意，建立软连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>接下来启动nginx看看效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>

<p>访问localhost就可以看到效果了。</p>
<h2 id="配置网站"><a href="#配置网站" class="headerlink" title="配置网站"></a>配置网站</h2><p>接下来配置一下网站。</p>
<p>修改nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>

<p>在http块里面加上这句话，引入其他的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include     conf.d&#x2F;*.conf;</span><br></pre></td></tr></table></figure>

<p>然后我们创建这个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx&#x2F;conf&#x2F;conf.d</span><br></pre></td></tr></table></figure>

<p>配置我们的网站文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx&#x2F;conf&#x2F;conf.d&#x2F;test.com.conf</span><br></pre></td></tr></table></figure>

<p>复制下面内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  test.com;</span><br><span class="line">        root   &quot;&#x2F;home&#x2F;wwwroot&#x2F;test&#x2F;public&#x2F;&quot;;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            index index.php index.html error&#x2F;index.html;</span><br><span class="line">            autoindex  off;</span><br><span class="line">            if (!-e $request_filename) &#123;</span><br><span class="line">                rewrite ^(.*)$ &#x2F;index.php?s&#x3D;&#x2F;$1 last;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.php(.*)$ &#123;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_split_path_info  ^((?U).+\.php)(&#x2F;?.+)$;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            fastcgi_param  PATH_INFO  $fastcgi_path_info;</span><br><span class="line">            fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改hosts文件就好了。</p>
<h2 id="redis扩展"><a href="#redis扩展" class="headerlink" title="redis扩展"></a>redis扩展</h2><p>如果要装redis扩展，那么手动下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;pecl.php.net&#x2F;package&#x2F;redis</span><br></pre></td></tr></table></figure>

<p>找到tar包下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;pecl.php.net&#x2F;get&#x2F;redis-5.3.2.tgz</span><br></pre></td></tr></table></figure>

<p>解压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar -zxvf redis-5.3.2.tgz</span><br></pre></td></tr></table></figure>

<p>进去执行phpize</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .&#x2F;redis-5.3.2</span><br><span class="line">sudo phpize</span><br></pre></td></tr></table></figure>

<p>然后编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php7&#x2F;bin&#x2F;php-config</span><br><span class="line">sudo make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure>

<p>接下来会出现下面的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;php7&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20190902</span><br></pre></td></tr></table></figure>

<p>修改我们的php.ini</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;usr&#x2F;local&#x2F;php7&#x2F;lib&#x2F;php.ini</span><br></pre></td></tr></table></figure>

<p>修改下面这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension_dir&#x3D;&#x2F;usr&#x2F;local&#x2F;php7&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20190902</span><br></pre></td></tr></table></figure>

<p>增加redis扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension&#x3D;&quot;redis.so&quot;</span><br></pre></td></tr></table></figure>

<p>重启nginx和php-fpm就好了。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>如何生成ssh-key</title>
    <url>/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90ssh-key.html</url>
    <content><![CDATA[<h1 id="如何生成ssh-key"><a href="#如何生成ssh-key" class="headerlink" title="如何生成ssh-key"></a>如何生成ssh-key</h1><p>打开命令终端，或者使用<code>git bash</code>都可以。</p>
<p>打开以后先查看你之前是否生成过<code>ssh-key</code>。生成之后会在目录<code>~/.ssh/</code>下面出现两个文件<code>id_rsa</code>私钥和<code>id_rsa.pub</code>公钥。</p>
<blockquote>
<p>cd ~/.ssh/<br>ls</p>
</blockquote>
<p>如果没看到这两个文件，那么开始执行生成指令。</p>
<blockquote>
<p> ssh-keygen -t rsa -C “你的邮箱” //这里一般使用github的邮箱</p>
</blockquote>
<p>运行之后，会出现提示让你输入一些东西，这里不需要管，不需要输入，直接<code>回车</code>即可。</p>
<p>一直回车。直到指令执行完。</p>
<p>再次查看，发现已经生成了两个文件。接下来使用的时候只需要把公钥给到别人就可以了。</p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统一--Amdahl定律</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%80--Amdahl%E5%AE%9A%E5%BE%8B.html</url>
    <content><![CDATA[<h1 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h1><p>Gene Amdal，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。</p>
<p>这个观察被称为<code>Amdahl定律</code>。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</p>
<p>若系统执行某应用程序需要时间为<code>T</code><sub><code>old</code></sub>。假设系统某部分执行所需时间与该时间的比例为<code>a</code>，而该部分性能提升比例为<code>k</code>。即该部分初始所需执行时间为<code>aT</code><sub><code>old</code></sub>，现在所需时间为(<code>aT</code><sub><code>old</code></sub>)/<code>k</code>。因此，总的执行时间应为：</p>
<blockquote>
<p>T<sub>new</sub> = (1 - a)T<sub>old</sub> + (aT<sub>old</sub>)/k = T<sub>old</sub> [(1 - a) + a/k]</p>
</blockquote>
<p>由此，可以计算加速比 S = T<sub>old</sub> / T<sub>new</sub> 为</p>
<blockquote>
<p>S = 1 / [(1 - a) + a/k]</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>考虑这样一种情况，系统的某个部分初始耗时比例为60%（a = 0.6），其加速比例因子为3，也就是性能提升了300%。则我们可以获得的整体系统加速比为：</p>
<blockquote>
<p>1 / [(1 - 0.6) + 0.6 / 3] = 1 / (0.4 + 0.2) = 1 / 0.6 = 1.66666666 约等于 1.67倍</p>
</blockquote>
<p>可以看到虽然我们优化的部分提升了3倍性能，但是整体性能只提升了1.67倍。</p>
<p>虽然我们对系统的一个主要部分做了重大改进，但是获得的加速比却明显小于这部分的加速比。这就是<code>Amdahl</code>定律的主要观点–<code>要想显著加速整个系统，必须提升系统中相当大的部分的速度</code>。</p>
<h2 id="练习题1-1"><a href="#练习题1-1" class="headerlink" title="练习题1.1"></a>练习题1.1</h2><p>假设你要把土豆从爱达荷州送到明尼苏达州，全程2500公里。在限速范围内，你估计平均速度为100公里/小时，整个行程需要25个小时。</p>
<blockquote>
<p>A:新闻说蒙大拿州取消了限速，这使得行程有1500公里速度可以达到150公里/小时，那么加速比是多少？</p>
</blockquote>
<p>答：根据题目可知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 1500 &#x2F; 2500 &#x3D; 0.6 k &#x3D; 1.5 求S</span><br><span class="line"></span><br><span class="line">公式 S &#x3D; 1 &#x2F; [(1 - a) + a&#x2F;k] 代入：</span><br><span class="line"></span><br><span class="line">S &#x3D; 1 &#x2F; (0.4 + 0.4)</span><br><span class="line">S &#x3D; 1 &#x2F; 0.8</span><br><span class="line">S &#x3D; 1.25</span><br></pre></td></tr></table></figure>
<p>加速比是 1.25倍</p>
<blockquote>
<p>B:你可以购买道具，想让加速比达到1.67倍，那么你必须以多快的速度通过蒙大拿州？</p>
</blockquote>
<p>答：根据题目可知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S &#x3D; 1.67 a &#x3D; 0.6 求k</span><br><span class="line"></span><br><span class="line">1.67 &#x3D; 1 &#x2F; (0.4 + 0.6 &#x2F; k)</span><br><span class="line">1.67 * (0.4 + 0.6 &#x2F; k) &#x3D; 1</span><br><span class="line">0.668 + 1.002 &#x2F; k &#x3D; 1</span><br><span class="line">1.002 &#x2F; k &#x3D; 0.332</span><br><span class="line">k &#x3D; 1.002 &#x2F; 0.332</span><br><span class="line">k &#x3D; 3.02</span><br></pre></td></tr></table></figure>
<p>也就是蒙大拿州的速度必须达到 100 * 3.02 = 302公里/小时才行。</p>
<h2 id="练习题1-2"><a href="#练习题1-2" class="headerlink" title="练习题1.2"></a>练习题1.2</h2><p>公司说下个版本的软件性能将提升2倍。这个任务分配给你，你已经确认只有80%的系统可以进行改进，那么，这部分需要改进多少才可以达到要求？</p>
<p>根据题目可以知道:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 0.8, S &#x3D; 2,求k</span><br><span class="line"></span><br><span class="line">公式 S &#x3D; 1 &#x2F; [(1 - a) + a&#x2F;k] 代入：</span><br><span class="line">2 &#x3D; 1&#x2F; [(1 - 0.8) + 0.8&#x2F;k]</span><br><span class="line">2 &#x3D; 1 &#x2F; (0.2 + 0.8 &#x2F; k)</span><br><span class="line">2 (0.2 + 0.8 &#x2F; k) &#x3D; 1</span><br><span class="line">0.4 + 1.6 &#x2F; k &#x3D; 1</span><br><span class="line">1.6 &#x2F; k &#x3D; 0.6</span><br><span class="line">1.6 &#x3D; 0.6k</span><br><span class="line">16 &#x2F; 6 &#x3D; k</span><br><span class="line">k &#x3D; 2.67</span><br></pre></td></tr></table></figure>
<p>所以我们需要改进这部分至少2.67倍才能达到要求。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统一--c程序发生了什么</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%80--c%E7%A8%8B%E5%BA%8F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88.html</url>
    <content><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。。虽然系统的 具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有 相似的硬件和软件组件，它们又执行着相似的功能。</p>
<h2 id="第一个c程序"><a href="#第一个c程序" class="headerlink" title="第一个c程序"></a>第一个c程序</h2><p>一般第一个程序都是输出<code>hello world</code>，这里我们使用c语言输出一个<code>hello world</code>。后面在来讲这里面都发生了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终程序都会被转成2进制代码，一般都根据ASCII码来转换，下图是上面的代码根据ASCII码转换成的二进制代码。</p>
<p><img src="../images/csapp1-1.png" alt="coursera"></p>
<h2 id="程序被翻译成不同格式"><a href="#程序被翻译成不同格式" class="headerlink" title="程序被翻译成不同格式"></a>程序被翻译成不同格式</h2><p>计算机最后能执行的是二进制文件，所以需要把c文件转换成二进制文件，这是经过几个步骤的转换，而不是一次性转换成的。当然了，我们使用gcc编译的时候他是一下子执行了所有步骤的。</p>
<p>分为4个阶段</p>
<ul>
<li>hello.c 经过 预处理器(cpp) 输出 hello.i (修改了的源程序)</li>
<li>hello.i 经过 编译器(ccl) 输出 hello.s (汇编程序)</li>
<li>hello.s 经过 汇编器(as) 输出 hello.o (可重定位目标程序)</li>
<li>hello.o 和 引入的其他库的文件 经过 连接器(ld) 输出 hello.exe (可执行程序)</li>
</ul>
<h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>预处理器根据以字符<code>#</code>开头的命令，修改原始的c程序。把你引入的文件插入到原始文件中。生成新的hello.i文件。</p>
<h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>编译器把hello.i这个c程序文件编译成汇编程序文件。生成新的hello.s文件。</p>
<h4 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h4><p>汇编器把hello.s这个汇编程序翻译成机器语言指令，把这些指令打包成可重定位目标程序。生成新的hello.o文件，它包含的17个字节是函数main的指令编码。</p>
<h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><p>我们的c程序调用了别的函数，调用了printf这个输出函数，这个函数是标准c库里面的函数，这个函数存在于printf.o这个预先编译好的文件里面，而我们要把这两个文件合并到一起，链接器就负责这种合并。最后得到一个可执行程序 hello.exe</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统一--系统的硬件组成</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%80--%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.html</url>
    <content><![CDATA[<h1 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>总线贯穿整个计算机系统，负责在各个部件之间传递数据。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数是一个基本的系统参数，现在大多数机器都是8个字节（64）位的了，4个字节（32）位的机器已经很少见了。</p>
<h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p>I/O(输入/输出)设备是系统和外部连接的通道。下图包括四个I/O设备。分别是</p>
<ul>
<li>作为用户输入的键盘</li>
<li>作为用户输入的鼠标</li>
<li>作为用户输出的显示器</li>
<li>存储数据和程序的磁盘<br>最开始，可执行程序就是存储在磁盘上面的。</li>
</ul>
<p>每个I/O设备都通过适配器或者控制器和I/O总线相连。控制器和适配器的区别主要在于封装方式上面。<code>控制器是I/O设备本身或者系统的主印制电路板（通常称作主板）</code>上的芯片组。而<code>适配器是一块插在主板插槽上的卡</code>。</p>
<h2 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h2><p>主存是一个临时存储设备，在处理器执行程序时，用来存放数据。</p>
<p>从物理上来说，主存是<code>一组动态随机存储器（DRAM）</code>芯片组成的。从逻辑上来说，存储器是<code>一个线性的字节数组，每个字节都有其唯一的地址，这些地址是从零开始的</code>。</p>
<h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p>中央处理单元（CPU），简称处理器。是解释或执行存储在主存中指令的引擎。处理器的核心是<code>一个大小为一个字的存储设备或寄存器，称为程序计数器（PC）</code>。在任何时刻，PC都指向主存中的某条指令。</p>
<p>从电脑开机开始，PC就指向一条指令，执行指令后执行下一条指令，不断运行。</p>
<p>这样的简单操作不多，都围绕着主存，寄存器文件和算术/逻辑运算单元（ALU）进行。下面是一些简单操作的例子。</p>
<ul>
<li>加载：从主存复制一个字节到寄存器。</li>
<li>存储：从寄存器复制一个字节到主存。以覆盖原来的值。</li>
<li>操作：把两个寄存器的内容复制到ALU做运算，将结果存在一个寄存器中。</li>
<li>跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，覆盖PC原来的值。</li>
</ul>
<p><img src="../images/csapp1-2.png" alt="coursera"></p>
<h1 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h1><p>程序通过shell进行执行。</p>
<blockquote>
<p>./hello</p>
</blockquote>
<p>这个时候系统把这个字符通过<code>键盘</code>逐一读入寄存器，然后再放入主存。</p>
<p>当我们按下回车，这个时候系统开始执行<code>hello</code>的内容，把<code>hello world</code>从磁盘读入主存。利用直接存储器存取技术（DMA），可以直接从磁盘读入主存，而不需要经过寄存器。</p>
<p>把程序内容读入主存后，开始执行main函数的内容，把<code>hello world</code>从主存复制到寄存器，最后显示在<code>屏幕</code>上面。</p>
<h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>这个运行过程说明程序多次在主存和寄存器之间复制移动代码。这些重复操作如果能变得更快，那么整个程序就能变得更快。这就是高速缓存的作用。</p>
<p>根据机械原理，较大的设备比较小的设备速度慢，而快速设备的造价也远高于低速设备。比如，磁盘的容量可以比主存大1000倍，但是主存的速度可能比磁盘大1000万倍。同样的，寄存器比主存的速度也要更快。</p>
<p>针对这些速度的差异，系统的设计者采用了高速缓存设备，作为暂时的集结区域，存放处理器近期可能会需要的信息。系统有L1,L2,L3三级缓存。L1最快最小，L3最慢最大，</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统（一）</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。。虽然系统的 具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有 相似的硬件和软件组件，它们又执行着相似的功能。</p>
<h2 id="第一个c程序"><a href="#第一个c程序" class="headerlink" title="第一个c程序"></a>第一个c程序</h2><p>一般第一个程序都是输出<code>hello world</code>，这里我们使用c语言输出一个<code>hello world</code>。后面在来讲这里面都发生了什么。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理-自顶向下一</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><p>什么是因特网？回答这个问题有两种方式：其一，从具体构成上看：可以分成<code>基本硬件</code>和<code>软件组件</code>。其二，我们能够根据为分布式应用提供服务的联网基础设施来描述因特网。</p>
<p>因特网是网络的网络，是<code>通信技术</code>和<code>计算机技术</code>紧密结合的产物。是<code>互连的</code>，<code>自治的</code>。</p>
<ul>
<li>自治：无主从关系</li>
<li>互连：互联互通</li>
</ul>
<h3 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h3><p>因特网是世界范围的计算机网络。互联了世界的计算机网络。在之前计算设备多是电脑，发展到现在，加入了手机，电视，平板，汽车等设备。这些都被称为<code>主机（host）</code>或<code>端系统（end system）</code>。</p>
<p>端系统通过<code>通信链路</code>和<code>分组交换机</code>连接到一起。通信链路由<code>同抽电缆</code>，<code>铜线</code>,<code>光纤</code>等物理媒体组成。不同物理媒体的传输速率不同，传输速率以（比特/秒度量)。</p>
<p>端系统要发送的时候，把<code>发送信息</code>分段，每段和<code>首部字节</code>包裹到一起称为一个分组，把分组通过网络从发送端系统发送到接收端系统。</p>
<p>分组交换机分成<code>路由器</code>和<code>链路层交换机</code>。路由器用于网络核心，链路层交换机用于接入网。</p>
<p>端系统通过<code>因特网服务提供商ISP</code>接入，包括家庭ISP，公司ISP等。每个ISP由多个分组交换机和多个通信链路组成。</p>
<ul>
<li>从范围分：局域网，城域网，广域网</li>
<li>从拓扑结构分：星型，主线型，树形，网状。</li>
<li>从交换网络分：电路交换，报文交换，分组交换。</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议控制着网络之间计算机的通信。不同的协议完成不同的通信任务。</p>
<p>协议的三要素：</p>
<ul>
<li>语法：数据与控制信息的结构和格式</li>
<li>语义：需要发出何种控制信息，完成何种动作何种响应。差错控制</li>
<li>时序：事件顺序，速度匹配</li>
</ul>
<h4 id="问问题"><a href="#问问题" class="headerlink" title="问问题"></a>问问题</h4><p>当你发出<code>你好</code>的时候，发送了一条请求报文。当对方回复<code>你好，你有什么事吗</code>的时候，回复了一条响应报文。</p>
<p>这时候你问问题<code>你知道天安门在哪里吗</code>。发送了一条请求报文。对方回复<code>天安门在这里呀，......</code>。回复了一条响应报文。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>我们的手机，电视，智能设备这些端系统联网，都处于网络边缘。端系统也叫做主机，可以分成客户端和服务端。</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>接入网是链接网络边缘的端系统到<code>边缘路由器</code>的物理链路。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心是网络之网络，无数的路由器和交换机相互连接在一起。</p>
<p>三种交换方式：</p>
<ul>
<li>电路交换，建立连接-通信-释放链接，独占信道，不应对突发性。不用的时候浪费。通过多路复用技术来实现共享物理链路。</li>
<li>报文交换，发送整个报文。 时间 M/R *　h h是跳步数。发送时间长，和跳步数成正比，并且随着报文越大，路由器存储也需要越大。</li>
<li>分组交换，报文切成一个个分组，一个分组过一个路由器的时间是 L/R 。整个报文的时间是 M/R + nL/R ，n是路由器数量。</li>
</ul>
<p>多路复用技术：</p>
<ul>
<li>频分多路复用（FDM）根据不同的频率划分</li>
<li>时分多路复用（TDM）根据不同的时间划分</li>
<li>波分多路复用（WDM）根据不同的波划分</li>
<li>码分多路复用（CDM）每个手机分配码片，通过码片加密传输，再解密。用于手机网络。</li>
</ul>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>报文：包含从源主机到目的主机传输的任何东西。源主机将长报文划分为较小的一个个<code>分组</code>。分组通过通信链路和分组交换机（路由器和链路层交换机）传送。</p>
<p>分组以最大传输速率传输。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传输时间 &#x3D; 分组长度 &#x2F; 传输速率</span><br><span class="line">传输时间 &#x3D; L &#x2F; R</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>一个报文大小7.5Mbps。一个分组1500bits。总共有5000个分组。传输速率R = 1.5Mbps。会经过3段链路，2个路由器。</p>
<p>报文交换时间 = M / R = 7.5 / 1.5 = 5s 3段链路总共就是 5 * 3 = 15s。</p>
<p>分组交换时间 = L / R = 1500 / (1.5 * 10<sup>6</sup>) = 0.001s<br>5000个分组就是 5000 * 0.001s = 5s，再加上2个路由器，总共是 5.002s</p>
<p>分组交换公式：M/R + nL/R n=路由器数量<br>报文交换公式：hM/R h=链路数量（跳步数）</p>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><p><code>速率</code>即<code>数据率</code>或称<code>数据传输速率</code>或<code>比特率</code>。单位时间（秒）传输信息（比特）量。</p>
<ul>
<li>b/s(bps)</li>
<li>kb/s(kbps)</li>
<li>Mb/s(Mb/s)</li>
<li>Gb/s(Gb/s)</li>
<li>k = 10<sup>3</sup>, M = 10<sup>6</sup>, G = 10<sup>9</sup></li>
</ul>
<p><code>带宽</code>原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（HZ）。<br>网络的<code>带宽</code>通常是数字信道所能传输的<code>最高数据率</code>，单位b/s。</p>
<h4 id="延迟-时延"><a href="#延迟-时延" class="headerlink" title="延迟/时延"></a>延迟/时延</h4><p>分组交换为什么会丢包和时延？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路由器的缓存队列满了，在接到分组就会丢弃，产生丢包。</span><br><span class="line">分组进行排队的时间延迟。</span><br></pre></td></tr></table></figure>

<p>d<sub>proc</sub> :节点处理延迟</p>
<ul>
<li>差错检测</li>
<li>确定输出链路</li>
<li>通常 &lt; msec</li>
</ul>
<p>d<sub>queue</sub>:排队延迟，在路由器里面排队</p>
<ul>
<li>等待输出链路可用</li>
<li>取决于路由器拥塞程度</li>
<li>a:平均分组到达速率</li>
<li>La/R流量强度 = 0 平均排队延迟很小</li>
<li>La/R = 1平均排队延迟很大</li>
<li>La/R &gt; 1超出服务能力</li>
</ul>
<p>d<sub>trans</sub>:传输延迟</p>
<ul>
<li>L:分组长度(bits)</li>
<li>R:链路带宽(bps)</li>
<li>d<sub>trans</sub> = L/R</li>
</ul>
<p>d<sub>prop</sub>:传播延迟</p>
<ul>
<li>d:物理链路长度</li>
<li>s:信号传播速度(2 * 10<sup>8</sup> m/sec)</li>
<li>d<sub>prop</sub> = d/s</li>
</ul>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时延带宽积 &#x3D; 传播时延 * 带宽</span><br><span class="line">          &#x3D; d&lt;sub&gt;prop&lt;&#x2F;sub&gt; * R(btis)</span><br><span class="line">          &#x3D; 以比特为单位的链路长度，也就是链路里面有多少个比特</span><br></pre></td></tr></table></figure>

<h4 id="分组丢失-丢包"><a href="#分组丢失-丢包" class="headerlink" title="分组丢失 丢包"></a>分组丢失 丢包</h4><ul>
<li>队列缓存容量有限，队列满了</li>
<li>分组到达已满队列将丢弃</li>
<li>丢弃分组可能由前序节点或源重发（也可能不重发）</li>
</ul>
<p>丢包率 = 丢包数 / 已发分组总数</p>
<h4 id="吞吐量-率"><a href="#吞吐量-率" class="headerlink" title="吞吐量/率"></a>吞吐量/率</h4><p><code>吞吐量</code>表示在发送端与接收端之间传送数据速率(b/s)<br><code>即时吞吐量</code>是给定时刻的速率<br><code>平均吞吐量</code>是一段时间的平均速率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">吞吐量取较小的一段链路的带宽吞吐量。</span><br></pre></td></tr></table></figure>


<h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><p>实体：表示任何可发送或接收信息的硬件或软件。<br>协议：控制两个对等实体通信的规则的集合，协议是“水平的”。<br>实体需要使用下层服务，对上层提供服务，遵循本层协议，实现本层功能。服务是“垂直的”<br>下层实现对上层服务是“透明”的</p>
<h4 id="OSI7层结构"><a href="#OSI7层结构" class="headerlink" title="OSI7层结构"></a>OSI7层结构</h4><p>从功能上描述网络结构：分层结构</p>
<ul>
<li>应用层 http https ftp  报文</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层 tcp upd 报文段</li>
<li>网络层 ip 数据报</li>
<li>数据链路层 mac 帧</li>
<li>物理层</li>
</ul>
<p>每层进行数据封装，增加头信息，也就是<code>控制信息</code>：</p>
<ul>
<li>地址：发送和接收</li>
<li>差错检测编码：差错检测或纠正</li>
<li>协议控制：附加信息，优先级，服务质量，安全控制<br>构造协议数据单元（PDU）</li>
</ul>
<h5 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h5><ul>
<li>接口特性</li>
<li>比特编码</li>
<li>数据率</li>
<li>比特同步<ul>
<li>时钟同步</li>
</ul>
</li>
<li>传输模式<ul>
<li>单工 只能单向通信</li>
<li>半双工 可以双向通信，但只能交替进行</li>
<li>全双工</li>
</ul>
</li>
</ul>
<h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p>物理链路直接相连的两个节点之间的数据传输。</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理-自顶向下一课后作业解析</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%B8%80%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h1 id="第一章课后复习题"><a href="#第一章课后复习题" class="headerlink" title="第一章课后复习题"></a>第一章课后复习题</h1><ol>
<li>“主机”和“端系统”之间有什么不同？列举几种不同类型的端系统。web服务器是一种端系统吗？</li>
</ol>
<p>没什么不同，主机即端系统。<br>手机是端系统，ipad是端系统，智能音箱是端系统。<br>web服务器也是一种端系统。</p>
<ol start="2">
<li>“协议”一词常被用于描述外交关系。维基百科是怎样描述外交协议的。</li>
</ol>
<p>直接去维基百科看</p>
<ol start="3">
<li>标准对于协议为什么重要？</li>
</ol>
<p>如果都使用不同的协议，那么就没法交互了。所以需要标准来统一协议。</p>
<ol start="4">
<li>列出6种接入技术，将它们分为住宅接入，公司接入或广域无线网络接入。</li>
</ol>
<p>同轴电缆 住宅接入<br>混合光纤同轴电缆（HFC）住宅接入<br>FTTH 住宅接入，公司接入<br>双绞线 住宅接入<br>WIFI 住宅接入，公司接入，广域无线网络接入<br>4G 广域无线网络接入</p>
<ol start="5">
<li>HFC传输速率在用户间是专用的还是共享的？在下行HFC信道中，可能出现碰撞吗？为什么？</li>
</ol>
<p>共享的。<br>不会，在下行信道，所有的分组从头到尾有同一个源发出，因此不会发生冲突。</p>
<ol start="6">
<li>略</li>
<li>以太LAN的传输速率是多少</li>
</ol>
<p>用户10Mbps,100Mbps,服务器1Gbps,10Gbps</p>
<ol start="8">
<li>能够运行以太网的一些物理媒体是什么？</li>
</ol>
<p>同轴电缆，光纤，双绞铜线</p>
<ol start="9">
<li>拨号调制解调器，HFC，DSL和FTTH都用于住宅接入，对于这些技术中的每一种，给出传输速率的范围，并讨论有关带宽是共享的还是专用的</li>
</ol>
<p>拨号是专用的<br>HFC,DSL,FTTH都是用户共享的</p>
<ol start="10">
<li><p>略</p>
</li>
<li><p>假定在发送主机和接收主机间只有一台分组交换机。发送主机和交换机间以及交换机和接收主机间的传输速率分别是R1和R2。假设该交换机使用存储转发分组交换方式，发送一个长度为L的分组的端到端总时延是什么？（忽略排队时延，传播时延和节点处理时延）</p>
</li>
</ol>
<p>从发送主机到交换机的传输时延是 L/R1<br>从交换机到接受主机的传输时延是 L/R2<br>端到端总时延 = L/R1 + L/R2</p>
<ol start="12">
<li>与分组交换网络相比，电路交换网络有哪些优点？在电路交换网络中，TDM比FDM有哪些优势？</li>
</ol>
<p>电路交换网络独占带宽，速率更加稳定，建立好链接好只需要传输数据，不需要拥塞控制，流量控制，丢包等问题。</p>
<p>FDM是划分频率，TDM是划分时隙。发生丢失数据的话，TDM只会丢失一个时隙的数据，而FDM可能是大部分。</p>
<ol start="13">
<li>假定用户共享一条2Mbps链路。同时假定当每个用户传输时连续以1Mbps传输，但每个用户仅传输20%的时间。<br>a. 当使用电路交换时，能够支持多少用户？<br>b. 作为该题的遗留问题，假定使用分组交换。为什么如果两个或更少的用户同时传输的话，在链路前面基本没有排队时延？为什么如果3个用户同时传输的话，将会有排队时延？<br>c. 求出某指定用户正在传输的概率。<br>d. 假定现在有3个用户。求出在任何给定时间，所有3个用户在同时传输的概率。求出队列增长的时间比率。</li>
</ol>
<p>a: 电路交换可以支持两个用户。<br>b: 因为两个用户每个用户1Mbps传输速率，两个刚好2Mbps占满了链路，当3个的时候，对于交换机来说输入速率就变成了3Mbps，而输出还是2Mbps,所以会产生排队。<br>C: 20%<br>d: 0.2 * 0.2 * 0.2 = 0.008</p>
<ol start="14">
<li>为什么在等级结构相同级别的两个ISP通常互相对等？某IXP是如何挣钱的？</li>
</ol>
<p>因为互相对等可以直接连接，节省从上层ISP的时间和钱。<br>IXP通过流量对ISP收费</p>
<ol start="15">
<li>某些内容提供商构建了自己的网络。描述谷歌的网络。内容提供商构建这些网络的动机是什么？</li>
</ol>
<p>绕过顶层ISP，直接和接入ISP互联，减少向顶层ISP的付费，并且可以对网络有更多的控制和操作。</p>
<ol start="16">
<li>考虑从某源主机跨越一条固定路由向某目的主机发送一分组。列出端到端时延组成部分。这些时延中的哪些是固定的，哪些是变化的？</li>
</ol>
<p>总时延 = 节点处理时延 + 排队时延 + 传输时延 + 传播时延<br>变化的是节点处理时延 + 排队时延<br>固定的是传输时延 + 传播时延</p>
<ol start="17">
<li>访问在配套Web网站上有关传输时延与传播时延的Java小程序。在可用速率、传播时延和可用的分组长度之中找出一种组合，使得该分组的第一个比特到达接收方之前发送方结束了传输。找出另一种组合，使得发送方完成传输之前，该分组的第一个比特到达了接收方。</li>
</ol>
<p>传输时延 &lt; 传播时延的时候，传输完了第一个比特还没有到达接收方。<br>传输时延 &gt; 传播时延的时候，传播完了还没传输完，也就是第一个比特到达接收方还在传输。</p>
<ol start="18">
<li>一个长度为1000字节的分组经距离2500km的链路传播，传播速率为2.5x10^8m/s并且传输速率为2Mbps，它需要多长时间？更为一般地，一个长度为L的分组经距离为d的链路传播，传输速率为s并且传播速率为Rbps，它需要用多长时间？该时延与传输速率相关吗？</li>
</ol>
<p>传输时延 = 1000 / 2000000 = 0.0005s<br>传播时延 = 2500 / 250000 = 0.01s<br>需要 0.0105s 忽略节点处理时延和传播时延<br>L/s + d/Rbps<br>相关</p>
<ol start="19">
<li>假定主机A要向主机B发送一个大文件。从主机A到主机B的路径上有3段链路，其速率分别为R1 = 500kbps，R2 = 2Mbps，R3 = 1Mbps。<br>a. 假定该网络中没有其他流量，该文件传送的吞吐量是多少？<br>b. 假定该文件为4MB。传输该文件到主机B大致需要多长时间？<br>c. 重复(a)和(b)，只是这时R2减小到100kbps。</li>
</ol>
<p>a: 吞吐量取决于最小的速率也就是500kbps。<br>b: 4000 * 8 / 500 = 64s<br>c: 吞吐量 = 100kbps 传输时间 = 4000 * 8 / 100 = 320s</p>
<ol start="20">
<li>假定端系统A要向端系统B发送一个大文件。在一个非常高的层次上，描述端系统怎样从该文件生成分组。当这些分组之一到达某分组交换机时，该交换机使用分组中的什么信息来决定将该分组转发到哪一条路上？因特网中的分组交换为什么可以与驱车从一个城市到另一个城市并沿途询问方向相类比？</li>
</ol>
<p>报文-段-数据报-帧<br>使用目的ip地址和路由转发协议决定<br>路由转发协议使用了转发表，查询转发表和问路类似，一个路由器和一个城市类似</p>
<ol start="21">
<li>访问配套Web站点的排队和丢包Java小程序。最大发送速率和最小的传输速率是什么？对于这些速率，流量强度是多少？用这些速率运行该Java小程序并确定出现丢包要花费多长时间？然后第二次重复该实验，再次确定出现丢包花费多长时间。这些值有什么不同？为什么会有这种现象？</li>
</ol>
<p>略</p>
<ol start="22">
<li>列出一个层次能执行的5个任务。这些任务中的一个（或两个）可能由两个（或更多）层次执行吗？</li>
</ol>
<p>传输层 tcp协议：差错检测，分组重传，流量控制，拥塞控制，建立连接</p>
<p>可能，传输层有差错检测，网络层也有差错检测。</p>
<ol start="23">
<li>因特网协议栈中的5个层次有哪些？在这些层次中，每层的主要任务是什么？</li>
</ol>
<p>应用层：完成自己的应用功能 http,icmp,ftp应用执行<br>传输层：完成端到端传输 tcp udp协议 确定源和目的端口号 进程传输<br>网络层：完成网络的端到端传输 IP协议 源和目的ip地址 主机传输<br>数据链路层：完成数据的端到端传输 MAC协议 到下一个节点的传输<br>物理层：完成比特流的端到端传输 实际物理传输</p>
<ol start="24">
<li>什么是应用层报文？什么是传输层报文段？什么是网络层数据报？什么是链路层帧？</li>
</ol>
<p>应用层报文就是数据报文<br>传输层：增加源和目的端口号封装成段<br>网络层：增加源和目的ip地址，封装成数据报<br>链路层：增加MAC地址，封装成帧</p>
<ol start="25">
<li>路由器处理因特网协议栈中的哪些层次？链路层交换机处理的是哪些层次？主机处理的是哪些层次？</li>
</ol>
<p>主机处理所有层次<br>路由器处理物理层，链路层，网络层三层<br>交换机处理物理层，链路层两层</p>
<ol start="26">
<li>病毒和蠕虫之间有什么不同？</li>
</ol>
<p>病毒：需要用户交互才能感染设备<br>蠕虫：不需要用户交互</p>
<ol start="27">
<li>描述如何产生一个僵尸网络，以及僵尸网络是怎样被用于DDoS攻击的。</li>
</ol>
<p>恶意软件控制网络设备产生僵尸网络<br>恶意软件控制僵尸网络不断攻击服务器，发送大量分组，创建大量链接，让正常请求被服务器忽略或拒绝。</p>
<ol start="28">
<li>假定Alice和Bob经计算机网络相互发送分组。假定Trudy将自己安置在网络中，使得她能够俘获由Alice发送的所有分组，并发送她希望给Bob的东西；她也能俘获Bob发送的所有分组，并发送她希望给Alice的东西。列出在这种情况下Trudy能够做的某些恶意的事情。</li>
</ol>
<p>假扮成Alice或者Bob发送恶意软件<br>盗取Alice和Bob的信息</p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络原理-自顶向下二</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%BA%8C.html</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>两种架构</p>
<ul>
<li>C/S 客户-服务器架构</li>
<li>P2P 对等架构</li>
</ul>
<p>P2P的<code>自扩展性</code>：尽管每个对等方都请求文件产生工作量，但每个对等方也向其他对等方分发文件增加系统服务能力。</p>
<p>未来P2P面临的三大挑战：</p>
<ul>
<li>ISP友好。<br>大多数ISP都是下载比上传快。但是P2P加大了上传流量，给ISP带来了压力。需要设计对ISP友好的P2P。</li>
<li>安全性。<br>因为高度分布和开放特性。给安全带来了挑战。</li>
<li>激励<br>未来P2P的成功也取决于说服用户自愿向应用提供带宽，存储和计算资源。这对激励设计带来挑战。</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>实际通信的是计算机上面的进程。<br>通过IP地址确定一个主机。通过端口号确定一个进程。<br>计算机提供了一套socket套接字。</p>
<h3 id="使用的运输层服务"><a href="#使用的运输层服务" class="headerlink" title="使用的运输层服务"></a>使用的运输层服务</h3><p>看几个方面：</p>
<ul>
<li>可靠数据传输</li>
<li>吞吐量 带宽敏感</li>
<li>时延</li>
<li>安全</li>
</ul>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li>建立连接</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>轻量级，全部由应用层实现</p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul>
<li>交换的报文类型， 例如请求报文和响应报文</li>
<li>各种报文类型的语法，如报文的各个字段及这些字段是如何描述的。</li>
<li>字段的语义，这些字段中包含的信息的含义。</li>
<li>一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>HTTP的RFC文档</p>
<ul>
<li>RFC 1945</li>
<li>RFC 2616</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>请求报文</p>
<ul>
<li>请求行</li>
<li>首部行</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p>响应报文</p>
<ul>
<li>状态行</li>
<li>首部行</li>
<li>响应体</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>HTTP本身是无状态的，通过cookie可以实现身份记录。</p>
<p>cookie技术有4个组件</p>
<ul>
<li>HTTP响应报文中的一个cookie首部行</li>
<li>HTTP请求报文中的一个cookie首部行</li>
<li>用户端系统有一个cookie文件</li>
<li>WEB站点的一个后端数据库</li>
</ul>
<h3 id="WEB缓存"><a href="#WEB缓存" class="headerlink" title="WEB缓存"></a>WEB缓存</h3><p>WEB缓存器也叫代理服务器，它是能代表初始WEB服务器来满足HTTP请求的实体。WEB缓存服务器有自己的磁盘空间，保存最近请求过的对象的副本。</p>
<p>CDN就是一种WEB缓存。</p>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>尽管高速缓存能快速响应，但是存储的副本可能是陈旧的，过期的。</p>
<p>HTTP协议有一种机制，允许缓存器证实它是最新的。这种机制就是<code>条件GET方法</code></p>
<ul>
<li>请求报文使用GET方法</li>
<li>请求报文中包含一个“if-Modified-Since”首部行，内容是上次服务器返回的最新修改时间</li>
</ul>
<p>WEB服务器会检查如果没有修改就返回一个304状态码，缓存就知道还是最新的。</p>
<h2 id="文件传输FTP"><a href="#文件传输FTP" class="headerlink" title="文件传输FTP"></a>文件传输FTP</h2><p>HTTP和FTP都是文件传输协议。(RFC959)</p>
<p>一些重要的区别，最显著的是<code>FTP</code>使用两个并行的TCP连接来传输文件，一个是<code>控制连接</code>，一个是<code>数据连接</code>。</p>
<p>控制连接用于在俩主机之间传输控制信息，如用户标识、口令、改变远程目录的命令以及<code>存放</code>和<code>获取</code>文件的命令。</p>
<p>数据连接用于实际发送一个文件。</p>
<p>因为FTP使用一个独立的控制连接，所以我们也称FTP的控制信息是<code>带外传送</code>的。</p>
<p>FTP首先在21端口建立一个<code>控制连接</code>。<br>FTP的客户端通过控制连接发送用户标识和口令，命令。<br>FTP的服务端收到传输文件的命令后，建立数据连接用来传输文件。<br>每个数据连接传输一个文件后关闭。</p>
<h3 id="FTP命令和回答"><a href="#FTP命令和回答" class="headerlink" title="FTP命令和回答"></a>FTP命令和回答</h3><p>命令和回答都是以<code>7比特的ASCII格式</code>在控制连接上发送的。为了区分连续的命令，每个命令后跟回车换行符。</p>
<ul>
<li>USER username: 用于向服务器发送用户标识</li>
<li>PASS password: 用于向服务器发送用户口令</li>
<li>LIST ：用于请求服务器回送当前远程目录中的所有文件列表。该文件列表是一个数据连接发送的。</li>
<li>RETR filename: 用于从远程主机当前目录检索文件。该命令引起远程主机发起数据连接传输该文件到本地客户端。</li>
<li>STOR filename: 用于在远程主机当前目录存放文件。就是往远程主机传输文件。</li>
</ul>
<p>一些典型回答：</p>
<ul>
<li>331 Username OK, Password required(用户名Ok，需要口令)</li>
<li>125 Data connection already open: transfer starting (数据连接已经打开，开始传送)</li>
<li>425 Can’t open data connection (无法打开数据连接)</li>
<li>452 Error Writing File (写文件出错)</li>
</ul>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>邮件有三部分</p>
<ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议</li>
</ul>
<p>发送邮件过程</p>
<ul>
<li>发送方的用户代理 到 发送方的邮件服务器</li>
<li>发送方的邮件服务器 到 接收方的邮件服务器</li>
<li>接收方的邮件服务器 到 接收方的用户代理邮箱</li>
</ul>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>RFC 5321 给出了SMTP的定义。SMTP使用TCP协议。只能传输7比特的ASCII表示。</p>
<p>发送过程：</p>
<ul>
<li>客户端建立连接</li>
<li>S:220 hamburger.edu</li>
<li>C:HELO crepes.fr</li>
<li>S:250 Hello crepes.fr,pleased to meet you</li>
<li>C:MAIL FROM: <a href="mailto:&#x61;&#x6c;&#x69;&#99;&#x65;&#x40;&#99;&#114;&#x65;&#112;&#x65;&#x73;&#x2e;&#x66;&#114;">&#x61;&#x6c;&#x69;&#99;&#x65;&#x40;&#99;&#114;&#x65;&#112;&#x65;&#x73;&#x2e;&#x66;&#114;</a></li>
<li>S:250 <a href="mailto:alice@crepes.fr">alice@crepes.fr</a> … sender ok</li>
<li>C:RCPT TO: <a href="mailto:&#x62;&#x6f;&#x62;&#64;&#x68;&#117;&#109;&#98;&#x75;&#114;&#103;&#x65;&#x72;&#46;&#x65;&#100;&#x75;">&#x62;&#x6f;&#x62;&#64;&#x68;&#117;&#109;&#98;&#x75;&#114;&#103;&#x65;&#x72;&#46;&#x65;&#100;&#x75;</a></li>
<li>S:250 <a href="mailto:bob@humburger.edu">bob@humburger.edu</a> …. Recipient ok</li>
<li>C:DATA</li>
<li>S:354 Enter mail, end with “.” on a line by itself</li>
<li>C:Do you like ketchup?</li>
<li>C:How about you pickets?</li>
<li>C:.</li>
<li>S:250 Message accepted for delivery</li>
<li>C:QUIT</li>
<li>S:221 hamburger.edu closeing connection</li>
</ul>
<h3 id="和HTTP对比"><a href="#和HTTP对比" class="headerlink" title="和HTTP对比"></a>和HTTP对比</h3><p>HTTP 是一个拉协议，从服务器拉取数据。<br>SMTP 是一个推协议，往服务器推送邮件。</p>
<p>HTTP 可以任意表示<br>SMTP 只能7比特ASCII表示。</p>
<p>HTTP 每个对象一个响应<br>SMTP 一个邮件多个对象</p>
<h3 id="SMTP典型的首部报文"><a href="#SMTP典型的首部报文" class="headerlink" title="SMTP典型的首部报文"></a>SMTP典型的首部报文</h3><p>FROM:<br>TO:<br>Subject:</p>
<h3 id="获取邮件协议"><a href="#获取邮件协议" class="headerlink" title="获取邮件协议"></a>获取邮件协议</h3><p>POP3 和 IMAP</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>pop3分为3个阶段</p>
<ul>
<li>特许：用户代理发送用户名和口令（明文）</li>
<li>事务处理：用户代理取回报文，做删除报文的标记，取消删除标记，获取邮件的统计信息。</li>
<li>更新阶段：发生在客户端QUIT指令后，结束会话，删除那些标记的报文。</li>
</ul>
<p>特许阶段有两个主要命令</p>
<ul>
<li>user <username></li>
<li>pass <password></li>
</ul>
<p>事务处理阶段有4个主要命令</p>
<ul>
<li>list 列出邮件列表</li>
<li>retr id 读取邮件内容</li>
<li>delete 删除邮件</li>
<li>quit 退出</li>
</ul>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>imap比pop3更加复杂，增加了远程文件夹功能。imap支持用户读取报文的一部分，比如只读取首部，或多部分MIME的一部分。当宽度低的时候非常有用。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS使用UDP协议。</p>
<p>DNS完成域名和ip地址的转换。</p>
<p>域名分为</p>
<ul>
<li>根DNS服务器</li>
<li>顶级DNS服务器 com,org,edu,cn</li>
<li>权威DNS服务器</li>
</ul>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>迭代请求</p>
<ul>
<li>请求根服务器</li>
<li>根服务器返回</li>
<li>请求顶级服务器</li>
<li>顶级服务器返回</li>
<li>请求权威</li>
<li>权威返回</li>
</ul>
<p>递归请求</p>
<ul>
<li>请求根</li>
<li>根请求顶级</li>
<li>顶级请求权威</li>
<li>权威返回顶级</li>
<li>顶级返回根</li>
<li>根返回</li>
</ul>
<h2 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h2><p>遵守RFC协议文档的应用程序是“开放”的。不遵循RFC文档中的协议的应用程序是“专用”的。</p>
<h3 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h3>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之享元模式--共享内存来节省空间</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%9D%A5%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4.html</url>
    <content><![CDATA[<h1 id="设计模式之享元模式–共享内存来节省空间"><a href="#设计模式之享元模式–共享内存来节省空间" class="headerlink" title="设计模式之享元模式–共享内存来节省空间"></a>设计模式之享元模式–共享内存来节省空间</h1><p><code>享元模式</code>是说共享单元，如果有一样的部分那么共享一个组件而不是复制，也就是传址不传值。</p>
<blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<h2 id="为什么要使用享元模式"><a href="#为什么要使用享元模式" class="headerlink" title="为什么要使用享元模式"></a>为什么要使用享元模式</h2><p>享元模式体现在很多地方，比如后端共享一套代码给前端各个平台，很多接口都是同一个。</p>
<p>享元模式是复用性的体现，大量节省了空间。</p>
<p>比如棋牌游戏，棋子和牌都是一样的，那么他们就可以复用同一个。</p>
<h4 id="五子棋游戏"><a href="#五子棋游戏" class="headerlink" title="五子棋游戏"></a>五子棋游戏</h4><p>五子棋只有<code>黑子</code>和<code>白子</code>，虽然我们用到了很多，但是他们其实指向了同一个内存空间，只不过创建了很多对象而已。</p>
<h4 id="象棋游戏"><a href="#象棋游戏" class="headerlink" title="象棋游戏"></a>象棋游戏</h4><p>象棋也只有<code>车马炮</code>这些棋子，同样可以复用，不然如果你每个棋局重新创建，那么内存很容易溢出。</p>
<h4 id="扑克牌游戏"><a href="#扑克牌游戏" class="headerlink" title="扑克牌游戏"></a>扑克牌游戏</h4><p>扑克牌也只有<code>123</code>到大王这些固定的牌。</p>
<h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>很多递归算法也可以通过享元模式来优化，递归到最后其实有很多是重复的值，而如果每个重复的值都需要重新占用空间，那么造成了大量的空间浪费，这也是递归慢和容易内存溢出的原因之一。</p>
<p>享元模式其实很简单，就是有需要的时候把已经存在的东西拿出来复用。</p>
<p>比如可以通过数组存储，然后需要的时候直接复用就好了。</p>
<p>比如通过<code>简单工厂</code>来创建对象的时候，如果有很多请求过来访问这个工厂，那么工厂需要创建很多对象返回。</p>
<p>而如果通过数组存起来，那么只返回一个对象，就节省了空间。</p>
<p>当然了，享元模式共享的只能是<code>可读对象</code>，一定是不可修改的。</p>
<p>如果可以修改就会造成某个地方修改而其他地方不可用的bug。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之组合模式--树形结构的最佳实践</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html</url>
    <content><![CDATA[<h1 id="设计模式之组合模式–树形结构的最佳实践"><a href="#设计模式之组合模式–树形结构的最佳实践" class="headerlink" title="设计模式之组合模式–树形结构的最佳实践"></a>设计模式之组合模式–树形结构的最佳实践</h1><p><code>组合模式</code>是部分组合成整体。</p>
<blockquote>
<p>将对象组合成树形结构以表示’部分’-‘整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<h2 id="为什么要使用组合模式"><a href="#为什么要使用组合模式" class="headerlink" title="为什么要使用组合模式"></a>为什么要使用组合模式</h2><p>最常用到组合模式的应该就是树形结构了。</p>
<p>比如公司-部门的结构，文件夹-文件的结构。</p>
<p>首先有一个共同的父类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合模式</span></span><br><span class="line"><span class="comment"> * 组合抽象类</span></span><br><span class="line"><span class="comment"> * 组合的部件和整体都继承这个抽象类，组合出这个抽象类的整体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> $name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(Component $component)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">(Component $component)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $depth)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现支节点和叶子节点两个类</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Arr</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合模式</span></span><br><span class="line"><span class="comment"> * 组合的支节点，可以有子节点，字节的需要是Component类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $arr = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(Component $component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;arr[] = $component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">(Component $component)</span> </span>&#123;</span><br><span class="line">        Arr::where(<span class="keyword">$this</span>-&gt;arr, <span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> <span class="title">use</span> <span class="params">($component)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ($value == $component) &#123;</span><br><span class="line">                <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;arr[$key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $depth)</span> </span>&#123;</span><br><span class="line">        dump(str_repeat(<span class="string">'-'</span>,$depth) . <span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;arr <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            $v-&gt;show(<span class="number">2</span>+$depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组合模式</span></span><br><span class="line"><span class="comment"> * 组合的叶子节点</span></span><br><span class="line"><span class="comment"> * 叶子节点不能添加和移除字节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(Component $component)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一个Component类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">(Component $component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $depth)</span> </span>&#123;</span><br><span class="line">        dump(str_repeat(<span class="string">'-'</span>,$depth) . <span class="keyword">$this</span>-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端通过任意添加子节点的方式来完成组合。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$root = <span class="keyword">new</span> Composite(<span class="string">'root'</span>);</span><br><span class="line">dump($root);</span><br><span class="line">$a = <span class="keyword">new</span> Composite(<span class="string">'a'</span>);</span><br><span class="line">$root-&gt;add($a);</span><br><span class="line">dump($root);</span><br><span class="line">$root-&gt;remove($a);</span><br><span class="line">dump($root);</span><br><span class="line">$root-&gt;add($a);</span><br><span class="line">$ab = <span class="keyword">new</span> Leaf(<span class="string">'ab'</span>);</span><br><span class="line">$a-&gt;add($ab);</span><br><span class="line">$b = <span class="keyword">new</span> Composite(<span class="string">'b'</span>);</span><br><span class="line">$root-&gt;add($b);</span><br><span class="line">$root-&gt;show(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="../images/composite.png" alt="composite"></p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之外观模式--抽象出高层接口更加易用</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%87%BA%E9%AB%98%E5%B1%82%E6%8E%A5%E5%8F%A3%E6%9B%B4%E5%8A%A0%E6%98%93%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="设计模式之外观模式–抽象出高层接口更加易用"><a href="#设计模式之外观模式–抽象出高层接口更加易用" class="headerlink" title="设计模式之外观模式–抽象出高层接口更加易用"></a>设计模式之外观模式–抽象出高层接口更加易用</h1><p><code>外观模式</code>是套个壳子，隐藏细节。</p>
<blockquote>
<p>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使子系统更加易用。</p>
</blockquote>
<h2 id="为什么要使用外观模式"><a href="#为什么要使用外观模式" class="headerlink" title="为什么要使用外观模式"></a>为什么要使用外观模式</h2><p>外观模式是对底层的抽象，隐藏你不该知道的东西，暴露你应该知道的东西，更加符合<code>迪米特法则</code>，<code>接口隔离原则</code>。</p>
<p>外观模式的本质同样是套壳子，比如你有一个缓存系统。</p>
<p>这个缓存系统存入数据需要</p>
<ol>
<li>加锁</li>
<li>存数据</li>
<li>释放锁</li>
</ol>
<p>我们的客户端实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">$lock = <span class="keyword">new</span> lock;</span><br><span class="line">$lock-&gt;lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入数据</span></span><br><span class="line">$redis = <span class="keyword">new</span> redis;</span><br><span class="line">$redis-&gt;set();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">$lock-&gt;unlock();</span><br></pre></td></tr></table></figure>

<p>这只是比较简单的几步，有的可能会更加复杂，你需要调用多个接口。</p>
<p>这样的话可以使用外观模式封装一下这些细节。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外观模式</span></span><br><span class="line"><span class="comment"> * 外观的封装，对底层模块的封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对存入缓存进行封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        $lock = <span class="keyword">new</span> lock;</span><br><span class="line">        $lock-&gt;lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入数据</span></span><br><span class="line">        $redis = <span class="keyword">new</span> redis;</span><br><span class="line">        $redis-&gt;set();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        $lock-&gt;unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用外观的客户端</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$facade = <span class="keyword">new</span> Facade;</span><br><span class="line">$facade-&gt;set();</span><br></pre></td></tr></table></figure>

<p>其实外观就是封装的思想体现。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之适配器模式--不兼容变兼容接口</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E4%B8%8D%E5%85%BC%E5%AE%B9%E5%8F%98%E5%85%BC%E5%AE%B9%E6%8E%A5%E5%8F%A3.html</url>
    <content><![CDATA[<h1 id="设计模式之适配器模式–不兼容变兼容接口"><a href="#设计模式之适配器模式–不兼容变兼容接口" class="headerlink" title="设计模式之适配器模式–不兼容变兼容接口"></a>设计模式之适配器模式–不兼容变兼容接口</h1><p><code>适配器模式</code>可以增加接口的易用性，使得不兼容的接口变得兼容。</p>
<blockquote>
<p>将一个接口转换成另外的接口，使得原本不兼容的接口变得兼容。</p>
</blockquote>
<h2 id="为什么要使用适配器模式"><a href="#为什么要使用适配器模式" class="headerlink" title="为什么要使用适配器模式"></a>为什么要使用适配器模式</h2><p>比如你的接口设计存在缺点，不够易用，不能复用但又希望复用的时候。</p>
<p>比如你要对接多个平台的接口他们互不兼容的时候。</p>
<p>现实中也有很多适配器，比如安卓苹果的转换头，比如usb到type-c的转换头，都是因为两边的接口不同，不兼容所以需要一个适配器。</p>
<p>下面是一个手机类，现在需要充电，但是手机的充电需要typec接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mobile</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给手机充电操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">charge</span><span class="params">(ITypec $typec)</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'使用typec接口给手机充电'</span>);</span><br><span class="line">        $typec-&gt;typec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在只有一个usb接口可以充电。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 需要适配的类</span></span><br><span class="line"><span class="comment"> * usb接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">usb</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'电脑usb接口'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们增加一个适配器，也就是typec转usb的头。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 适配器接口</span></span><br><span class="line"><span class="comment"> * typec接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITypec</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">typec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 适配器类，typec转换usb的适配器</span></span><br><span class="line"><span class="comment"> * typec接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typec</span> <span class="keyword">implements</span> <span class="title">ITypec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> $usb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;usb = <span class="keyword">new</span> usb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">typec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'接口适配器'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;usb-&gt;usb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的客户端就可以使用这个适配器了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$mobile = <span class="keyword">new</span> mobile();</span><br><span class="line"></span><br><span class="line">$mobile-&gt;charge(<span class="keyword">new</span> typec);</span><br></pre></td></tr></table></figure>

<p>这是<code>对象适配器</code>，还有类适配器，类适配器的话需要继承要适配的类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式</span></span><br><span class="line"><span class="comment"> * 适配器类，typec转换usb的适配器</span></span><br><span class="line"><span class="comment"> * typec接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typec</span> <span class="keyword">extends</span> <span class="title">usb</span> <span class="keyword">implements</span> <span class="title">ITypec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不再需要存储对象，直接继承了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">typec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'接口适配器'</span>);</span><br><span class="line">        <span class="comment">//$this-&gt;usb-&gt;usb();</span></span><br><span class="line">        <span class="comment">//这里改成使用父类的usb方法。</span></span><br><span class="line">        <span class="keyword">parent</span>::usb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适配器和代理模式还有装饰器模式的区别"><a href="#适配器和代理模式还有装饰器模式的区别" class="headerlink" title="适配器和代理模式还有装饰器模式的区别"></a>适配器和代理模式还有装饰器模式的区别</h3><p>这几个设计模式其实都差不多，你也可以说使用了typec代理了usb。只是角度不同所以名字不同罢了。</p>
<ul>
<li>代理模式 更注重代理，代理了原有类。</li>
<li>装饰器模式 比代理模式更加灵活多样。</li>
<li>适配器模式 更注重兼容性，为了兼容别的类，而不是代理和装饰功能。</li>
</ul>
<p>虽然角度不同，但是我觉得核心都差不多。<strong>这几个设计模式都是需要修改原有类的时候，没有选择修改，而是套了壳子，来扩展功能</strong>。这是一种好的思想，灵活运用思想更重要。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之装饰器模式--各种功能随意扩展</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD%E9%9A%8F%E6%84%8F%E6%89%A9%E5%B1%95.html</url>
    <content><![CDATA[<h1 id="设计模式之装饰器模式–各种功能随意扩展"><a href="#设计模式之装饰器模式–各种功能随意扩展" class="headerlink" title="设计模式之装饰器模式–各种功能随意扩展"></a>设计模式之装饰器模式–各种功能随意扩展</h1><p><code>装饰器模式</code>是灵活给原有类装饰新功能。</p>
<blockquote>
<p>动态的给对象添加额外职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
</blockquote>
<h2 id="为什么要使用装饰器模式"><a href="#为什么要使用装饰器模式" class="headerlink" title="为什么要使用装饰器模式"></a>为什么要使用装饰器模式</h2><p>如果你需要添加一些额外的功能，再不修改原有类的基础上，给原有类套个壳。并且可以套多个壳，我觉得装饰器模式有点像中间件。</p>
<p>比如你现在有一个登录的功能。</p>
<p>你现在需要给登录加一个权限控制。然后还要增加一个登录日志。还要增加登录微信通知。如果修改原有类可能引起未知bug。</p>
<p>可以使用装饰器模式。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 装饰器父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($compent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;compent = $compent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;compent-&gt;login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 权限装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginAuth</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'判断登录权限'</span>);</span><br><span class="line">        <span class="keyword">parent</span>::login();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 登录日志装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginLog</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::login();</span><br><span class="line">        dump(<span class="string">'记录登录日志'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 微信通知装饰器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginWechat</span> <span class="keyword">extends</span> <span class="title">Decorate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::login();</span><br><span class="line">        dump(<span class="string">'发送微信登录通知'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是原来的登录功能</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰器模式</span></span><br><span class="line"><span class="comment"> * 核心代码</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">login</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'用户登录'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来的客户端直接调用login，只有登录功能。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$login = <span class="keyword">new</span> login();</span><br><span class="line">$login-&gt;login();</span><br></pre></td></tr></table></figure>

<p>增加了装饰器以后可以把登录功能放入装饰器。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$login = <span class="keyword">new</span> login;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用权限装饰器</span></span><br><span class="line">$login = <span class="keyword">new</span> LoginAuth($login);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用登录日志装饰器</span></span><br><span class="line">$login = <span class="keyword">new</span> LoginLog($login);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用微信通知装饰器</span></span><br><span class="line">$login = <span class="keyword">new</span> LoginWechat($login);</span><br><span class="line"></span><br><span class="line">$login-&gt;login();</span><br></pre></td></tr></table></figure>

<p><img src="../images/decorator1.png" alt="decorate"></p>
<p>还可以任意调换装饰器的位置，可以先发送微信通知在记录登录日志。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$login = <span class="keyword">new</span> login;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用微信通知装饰器</span></span><br><span class="line">$login = <span class="keyword">new</span> LoginWechat($login);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用登录日志装饰器</span></span><br><span class="line">$login = <span class="keyword">new</span> LoginLog($login);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用权限装饰器</span></span><br><span class="line">$login = <span class="keyword">new</span> LoginAuth($login);</span><br><span class="line"></span><br><span class="line">$login-&gt;login();</span><br></pre></td></tr></table></figure>

<p><img src="../images/decorator2.png" alt="decorate"></p>
<p>这个模式就非常灵活，可以任意组装自己的装饰，比如购买支付的时候，需要装饰积分发放，账单通知这些。而且每个装饰器的职责单一，方便插拔，如果不需要一个装饰器的时候把这个装饰器去掉就可以了。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之桥接模式--组合优于继承的体现</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%93%E7%8E%B0.html</url>
    <content><![CDATA[<h1 id="设计模式之桥接模式–组合优于继承的体现"><a href="#设计模式之桥接模式–组合优于继承的体现" class="headerlink" title="设计模式之桥接模式–组合优于继承的体现"></a>设计模式之桥接模式–组合优于继承的体现</h1><p><code>桥接模式</code>是灵活运用组合对象而不是继承类来实现功能。</p>
<blockquote>
<p>将抽象与实现部分分离，使他们都可以独立变化。</p>
</blockquote>
<h2 id="为什么要使用桥接模式"><a href="#为什么要使用桥接模式" class="headerlink" title="为什么要使用桥接模式"></a>为什么要使用桥接模式</h2><p><code>继承</code>这个面向对象的特性使得我们继承父类可以继承父类的功能，在使用多态特性可以自由修改子类，使得我们的设计很好用。</p>
<p>但是<code>继承</code>有一个问题，就是<code>强耦合</code>。继承一个父类代表拥有这个父类的能力，但这个父类的很多能力你可能并不需要。</p>
<p>还有如果继承关系很复杂的时候，使用继承会导致关系复杂到破裂，无法继承。</p>
<p>比如<code>华为</code>手机和<code>小米</code>手机都具有玩游戏，听音乐等功能。按照继承设计就会有下面4个类，如果再实现拍照功能又需要增加2个类。这个继承关系太过复杂。</p>
<ul>
<li><p>手机父类</p>
</li>
<li><p>软件父类</p>
</li>
<li><p>华为游戏手机</p>
</li>
<li><p>华为音乐手机</p>
</li>
<li><p>小米游戏手机</p>
</li>
<li><p>小米音乐手机</p>
</li>
</ul>
<p>如果使用组合的方式，只有4个类。</p>
<ul>
<li>华为手机类</li>
<li>小米手机类</li>
<li>游戏类</li>
<li>音乐类</li>
</ul>
<p>让这4个类互相组合就可以了。如果增加个拍照，只需要增加拍照类。这就是抽象和实现分离。手机类就是手机类，软件类就是软件类，互相组合实现功能而不是互相继承。</p>
<p>桥接模式可以理解成连接两个部分，比如连接手机和软件两个部分。像一座桥一样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mobile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $soft;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行手机功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置相应的软件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setSoft</span><span class="params">(Soft $soft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;soft = $soft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 软件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Soft</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行软件功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是手机类的具体实现和软件的具体实现。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 华为手机类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span> <span class="keyword">extends</span> <span class="title">Mobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行手机功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'华为手机'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;soft-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 桥的一端</span></span><br><span class="line"><span class="comment"> * 小米手机类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">extends</span> <span class="title">Mobile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行手机功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'小米手机'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;soft-&gt;run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 游戏软件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">Soft</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行软件功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'玩王者荣耀'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接模式</span></span><br><span class="line"><span class="comment"> * 音乐软件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span> <span class="keyword">extends</span> <span class="title">Soft</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行软件功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'打开网易云音乐'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用根据需要注入不同的软件就可以实现不同的软件功能而不再需要增加新的类来实现。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$obj1 = <span class="keyword">new</span> HuaWei;</span><br><span class="line">$obj1-&gt;setSoft(<span class="keyword">new</span> Game);</span><br><span class="line">$obj1-&gt;run();</span><br><span class="line"></span><br><span class="line">$obj1-&gt;setSoft(<span class="keyword">new</span> Music);</span><br><span class="line">$obj1-&gt;run();</span><br></pre></td></tr></table></figure>

<p><img src="../images/bridge.png" alt="bridge"></p>
<p>桥接模式解决了继承过于复杂的问题，体现了组合优于继承的思想。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之代理模式--代理转发中间层</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%AD%E9%97%B4%E5%B1%82.html</url>
    <content><![CDATA[<h1 id="设计模式之代理模式–代理转发中间层"><a href="#设计模式之代理模式–代理转发中间层" class="headerlink" title="设计模式之代理模式–代理转发中间层"></a>设计模式之代理模式–代理转发中间层</h1><p><code>代理模式</code>是代理原来的类或对象，在不改变原有类或对象的基础上增加新的功能。</p>
<blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<h2 id="为什么要使用原型模式"><a href="#为什么要使用原型模式" class="headerlink" title="为什么要使用原型模式"></a>为什么要使用原型模式</h2><p>代理模式最常用的场景比如我们开发的代理中间层，来代理前端的请求，隐藏真正的后端接口。还有很多远程代理，科学上网也属于代理的一种。</p>
<p>还有虚拟代理，比如浏览器的图片会先出现图片框在加载图片，图片框其实就是一个对图片的代理。</p>
<p>安全代理，用来控制真实对象的访问权限，这个也是代理中间层会做到的。</p>
<p>在我们的代码中一般会使用代理模式做一些原有类做不到的事情，对原有类的扩展。</p>
<p>比如<code>打印sql</code>，<code>打印日志</code>，<code>发送通知</code>这些跟具体业务无关的功能增加。</p>
<p>这也更加符合<code>开闭原则</code>。通过增加代理类的方式来增加功能而不是修改原来的类。</p>
<p>代理模式要求<code>代理类</code>和<code>原类</code>都实现同一个接口，也是对接口实现才能实现用代理类来替换原类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//代理接口，代理类和原类都需要实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类，实现代理接口，代理原类，客户端访问代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxy</span> <span class="keyword">implements</span> <span class="title">IProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $proxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(IProxy $proxy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把要代理的原类传进来</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;proxy = $proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置功能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//访问原类</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;proxy-&gt;proxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后置功能</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product</span> <span class="keyword">implements</span> <span class="title">IProxy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原类的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来没有代理的时候，直接调用原类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$product = <span class="keyword">new</span> product();</span><br><span class="line">$product-&gt;proxy();</span><br></pre></td></tr></table></figure>

<p>有了代理类之后，客户端调用代理类，隐藏原类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$proxy = <span class="keyword">new</span> Proxy(<span class="keyword">new</span> product());</span><br><span class="line">$proxy-&gt;proxy();</span><br></pre></td></tr></table></figure>

<p>其实就是套了一层壳。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之原型模式--打印机快速复制的原理</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E6%89%93%E5%8D%B0%E6%9C%BA%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86.html</url>
    <content><![CDATA[<h1 id="设计模式之原型模式–打印机快速复制的原理"><a href="#设计模式之原型模式–打印机快速复制的原理" class="headerlink" title="设计模式之原型模式–打印机快速复制的原理"></a>设计模式之原型模式–打印机快速复制的原理</h1><p><code>原型模式</code>是一个克隆模式，以一个原型进行克隆，复制。</p>
<blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<h2 id="为什么要使用原型模式"><a href="#为什么要使用原型模式" class="headerlink" title="为什么要使用原型模式"></a>为什么要使用原型模式</h2><p>因为原型模式可以克隆整个对象而不用重新生成。</p>
<p>如果有一个订单对象，你要是重新生成，需要再次查询数据库，这是一个很耗时的操作，如果直接复制就不需要耗时了。</p>
<p>在php里面实现很简单，每个类有<code>__clone</code>魔术方法，实现这个方法就好了。</p>
<p>先看不实现这个方法的克隆。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式</span></span><br><span class="line"><span class="comment"> * 实现__clone魔术方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'张三'</span>;</span><br><span class="line">    <span class="keyword">public</span> $arr = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj1 = <span class="keyword">new</span> PrototypeClass;</span><br><span class="line">dump($obj1);</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">clone</span> $obj1;</span><br><span class="line">$obj2-&gt;name = <span class="string">'456'</span>;</span><br><span class="line">dump($obj2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/prototype.png" alt="原型模式"></p>
<p>可以看到成功克隆过来了，两个对象互不影响。</p>
<p>我们看一下修改第二个对象的<code>arr</code>属性呢</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$obj1 = <span class="keyword">new</span> PrototypeClass;</span><br><span class="line">dump($obj1);</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">clone</span> $obj1;</span><br><span class="line">$obj2-&gt;name = <span class="string">'456'</span>;</span><br><span class="line">$obj2-&gt;arr = [<span class="string">'1'</span>];</span><br><span class="line">dump($obj2);</span><br></pre></td></tr></table></figure>

<p><img src="../images/prototype2.png" alt="原型模式"></p>
<p>修改数组也没问题，也就是说，直接使用clone就可以完成深复制的拷贝操作。php本身通过clone关键字完成了原型模式。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之建造者模式--比工厂更精细的流水线生成</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-%E6%AF%94%E5%B7%A5%E5%8E%82%E6%9B%B4%E7%B2%BE%E7%BB%86%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%94%9F%E6%88%90.html</url>
    <content><![CDATA[<h1 id="设计模式之建造者模式–比工厂更精细的流水线生成"><a href="#设计模式之建造者模式–比工厂更精细的流水线生成" class="headerlink" title="设计模式之建造者模式–比工厂更精细的流水线生成"></a>设计模式之建造者模式–比工厂更精细的流水线生成</h1><p><code>建造者模式</code>是创建一个稳定流程的复杂对象，隐藏创建的具体流程、过程、细节。</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<h2 id="为什么要使用建造者模式"><a href="#为什么要使用建造者模式" class="headerlink" title="为什么要使用建造者模式"></a>为什么要使用建造者模式</h2><p><strong>当你需要创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化</strong>。</p>
<p>建造者分离了构建和表示，他把如何创建隐藏了起来，你只要告诉建造者你需要什么，他就会给你建造什么。</p>
<h3 id="建造者模式和工厂模式有什么区别"><a href="#建造者模式和工厂模式有什么区别" class="headerlink" title="建造者模式和工厂模式有什么区别"></a>建造者模式和工厂模式有什么区别</h3><p>工厂模式更像一个大工厂，比如<code>口罩工厂</code>负责生产<code>雾霾口罩</code>，<code>防毒口罩</code>等等。<strong>根据你需要的类型来判断给你什么</strong>。</p>
<p>那<code>雾霾口罩</code>怎么生产呢？假设需要123三个步骤，那么建造者就是负责这三个步骤的，你告诉建造者你需要<code>雾霾口罩</code>，那么他会给你一个完整的，建造好的<code>雾霾口罩</code>而不是<code>口罩半成品</code>。</p>
<p>所以建造者更像一个完整的流水线，按照步骤建造好成品给你。</p>
<p>再比如你去饭店点餐，<code>工厂模式</code>是你点哪个菜就给你哪个菜。<code>建造者模式</code>是你点的菜怎么做。你点了<code>鱼香肉丝</code>，建造者会按照步骤，哪一步该放肉，哪一步该放盐，最后做好了把菜给你。</p>
<p><code>建造者模式</code>还有一个作用就是<code>约束</code>。抽象出的建造流程不可改变，<code>口罩</code>不能少个过滤网，<code>饭菜</code>不能没有放盐。</p>
<p><code>建造者模式</code>也避免了复杂对象创建流程的缺失。</p>
<h3 id="php实现建造者模式"><a href="#php实现建造者模式" class="headerlink" title="php实现建造者模式"></a>php实现建造者模式</h3><p>假设现在有一个对接第三方支付的需求。使用建造者模式。</p>
<p>我们要先抽象出一个建造流程。使用抽象类，对接第三方支付大概需要一个加密，一个读取配置信息，然后把这些参数合并发送出去。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> * 建造者抽象类</span></span><br><span class="line"><span class="comment"> * 抽象出整个建造流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Build</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">buildHash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置流程，比如appid这些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">function</span> <span class="title">buildConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们的第三方支付类继承这个抽象建造者来实现具体的第三方支付建造者。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> * 建造者抽象类</span></span><br><span class="line"><span class="comment"> * 抽象出整个建造流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadBuild</span> <span class="keyword">extends</span> <span class="title">Build</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略加密代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hash'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取配置流程，比如appid这些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略配置代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'config'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送http请求流程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">http</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略发送代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'success'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了建造者，我们现在需要一个组装这整个建造流程的<code>监工</code>，<code>指挥者</code>。来保证整个流程不出错。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> * 指挥者类</span></span><br><span class="line"><span class="comment"> * 按照流程建造，返回建造后的类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createBuild</span><span class="params">(Build $build)</span> </span>&#123;</span><br><span class="line">        $build-&gt;buildHash();</span><br><span class="line">        $build-&gt;buildConfig();</span><br><span class="line">        <span class="keyword">return</span> $build;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的客户端调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$threadPay = Director::createBuild(<span class="keyword">new</span> ThreadBuild());  </span><br><span class="line">$threadPay-&gt;http();</span><br></pre></td></tr></table></figure>

<p>如果接入了别的第三方支付，那么我们只需要增加具体建造者就可以了，如果和抽象建造者冲突，那么说明没有抽象好。在客户端只需要更改具体建造者就可以了。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂方法模式--更加符合开闭原则的工厂模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-%E6%9B%B4%E5%8A%A0%E7%AC%A6%E5%90%88%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="设计模式之工厂方法模式–更加符合开闭原则的工厂模式"><a href="#设计模式之工厂方法模式–更加符合开闭原则的工厂模式" class="headerlink" title="设计模式之工厂方法模式–更加符合开闭原则的工厂模式"></a>设计模式之工厂方法模式–更加符合开闭原则的工厂模式</h1><p><code>工厂方法模式</code>是简单工厂模式的升级版本，更加符合开闭原则。</p>
<blockquote>
<p>定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
</blockquote>
<h2 id="为什么要使用工厂方法模式"><a href="#为什么要使用工厂方法模式" class="headerlink" title="为什么要使用工厂方法模式"></a>为什么要使用工厂方法模式</h2><p>之前说了<code>简单工厂模式</code>，<a href="https://blog.csdn.net/Thepatterraining/article/details/105904797" target="_blank" rel="noopener">简单工厂模式</a>的工厂类是这样的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">static</span> <span class="title">createPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">            <span class="comment">//小程序支付</span></span><br><span class="line">            $pay = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">            <span class="comment">//公众号支付</span></span><br><span class="line">            $pay = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">            <span class="comment">//扫码支付</span></span><br><span class="line">            $pay = <span class="keyword">new</span> nativePay;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $pay;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的工厂类是违反了开闭原则的，如果需要增加支付方法就需要修改这个工厂类，<strong>工厂方法模式就是解决这个问题的，使用工厂方法模式后不需要修改工厂类，只需要新增工厂类</strong>。</p>
<h2 id="改成工厂方法模式"><a href="#改成工厂方法模式" class="headerlink" title="改成工厂方法模式"></a>改成工厂方法模式</h2><p>为了符合开闭原则，我们需要创建多个工厂类和一个工厂接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jsAPIFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nativeFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> nativePay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们把实例化放到了这些子类中，如果增加实例化的需求只需要增加工厂类就可以了。这就是工厂方法模式。</p>
<p>相比简单工厂来说，这有一个缺点就是需要修改的时候虽然不需要修改工厂类了，但是需要修改客户端了。</p>
<p>下面的是原来的客户端。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    $pay = factory::createPay();</span><br><span class="line">    $pay-&gt;pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的是工厂方法模式的客户端</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    $pay = miniFactory::createPay(); <span class="comment">//需要修改这里</span></span><br><span class="line">    $pay-&gt;pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想修改客户端也可以再增加一个简单工厂类来实例化工厂方法模式的类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">createFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">            <span class="keyword">return</span> miniFactory::createPay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//省略其他判断和实例化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我觉得这样还不如直接用简单工厂来的好。</p>
<p>总的来说，简单工厂和工厂方法模式各有优缺点吧，不过对于php来说我觉得简单工厂就足以，虽然有修改代码的风险。但是也还好，而且通过封装成数组来实例化也不需要这一堆if-else。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解决composer-npm等包管理工具下载失败的问题</title>
    <url>/%E8%A7%A3%E5%86%B3composer-npm%E7%AD%89%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="解决composer-npm等包管理工具下载失败的问题"><a href="#解决composer-npm等包管理工具下载失败的问题" class="headerlink" title="解决composer-npm等包管理工具下载失败的问题"></a>解决composer-npm等包管理工具下载失败的问题</h1><p>使用composer npm进行下载依赖包的时候经常需要翻墙。不过国内已经有了很多国内源来加速下载，比如阿里云的国内镜像等。</p>
<p>不过有时候国内镜像并不能解决问题。</p>
<p>还有的时候就算你挂了全局翻墙也不行。</p>
<p>这是因为你使用命令行的时候，是用不到翻墙工具的。</p>
<p>如果你有翻墙工具，那么可以在命令行上面设置一下，使用代理就可以了。</p>
<p>在gitbash上面的设置。</p>
<blockquote>
<p>export http_proxy=<a href="http://127.0.0.1:41091" target="_blank" rel="noopener">http://127.0.0.1:41091</a>  //这个端口是你本地代理工具提供的端口<br>export https_proxy=<a href="http://127.0.0.1:41091" target="_blank" rel="noopener">http://127.0.0.1:41091</a> //这个端口是你本地代理工具提供的端口</p>
</blockquote>
<p>在cmd上的设置</p>
<blockquote>
<p>set http_proxy=<a href="http://127.0.0.1:41091" target="_blank" rel="noopener">http://127.0.0.1:41091</a>  //这个端口是你本地代理工具提供的端口<br>set https_proxy=<a href="http://127.0.0.1:41091" target="_blank" rel="noopener">http://127.0.0.1:41091</a> //这个端口是你本地代理工具提供的端口</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>npm</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之简单工厂模式--利用工厂解耦实例化对象</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%88%A9%E7%94%A8%E5%B7%A5%E5%8E%82%E8%A7%A3%E8%80%A6%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<h1 id="设计模式之简单工厂模式–利用工厂解耦实例化对象"><a href="#设计模式之简单工厂模式–利用工厂解耦实例化对象" class="headerlink" title="设计模式之简单工厂模式–利用工厂解耦实例化对象"></a>设计模式之简单工厂模式–利用工厂解耦实例化对象</h1><p><code>简单工厂模式</code>是最常被提起的一个设计模式，他的意思是</p>
<blockquote>
<p>利用简单工厂来决定实例化哪个类，而不是由外部程序来决定，把创建对象的操作内聚，解耦到工厂类中。</p>
</blockquote>
<h2 id="为什么要使用简单工厂模式"><a href="#为什么要使用简单工厂模式" class="headerlink" title="为什么要使用简单工厂模式"></a>为什么要使用简单工厂模式</h2><p>工厂模式除了<code>简单工厂模式</code>还有<code>工厂方法模式</code>,<code>抽象工厂模式</code>。</p>
<p>简单工厂模式有什么好处呢？</p>
<p>简单，非常简单。并且拥有工厂模式的特性，解耦对象的生成。</p>
<p>如果不使用工厂模式，那么对象的创建散落在程序的各个地方，如果需要修改，那么很麻烦。</p>
<p>我们在设计类的时候，为了遵循<code>单一职责原则</code>，我们应该把类划分的尽可能单一，拿一个实际应用例子来说，支付场景。</p>
<h3 id="支付场景"><a href="#支付场景" class="headerlink" title="支付场景"></a>支付场景</h3><p>我们需要在小程序端使用小程序支付，公众号端使用h5支付，pc端使用扫码支付。</p>
<p>后端统一提供支付接口。代码类似下面这样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">        <span class="comment">//小程序支付</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">        <span class="comment">//公众号支付</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="comment">//扫码支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是一个伪代码，这样写不管扩展性，维护性都不好，更不符合单一职责，所以我们应该把支付逻辑抽出来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">miniWechatPay</span> <span class="keyword">implements</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用小程序支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jsAPIPay</span> <span class="keyword">implements</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用公众号，jsapi支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nativePay</span> <span class="keyword">implements</span> <span class="title">pay</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用扫码支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">        <span class="comment">//小程序支付</span></span><br><span class="line">        $pay = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">        $pay-&gt;pay();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">        <span class="comment">//公众号支付</span></span><br><span class="line">        $pay = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">        $pay-&gt;pay();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="comment">//扫码支付</span></span><br><span class="line">        $pay = <span class="keyword">new</span> nativePay;</span><br><span class="line">        $pay-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在if判断里面有重复的地方，都是调用<code>pay</code>方法，我们可以抽出来。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">        <span class="comment">//小程序支付</span></span><br><span class="line">        $pay = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">        <span class="comment">//公众号支付</span></span><br><span class="line">        $pay = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="comment">//扫码支付</span></span><br><span class="line">        $pay = <span class="keyword">new</span> nativePay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $pay-&gt;pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果接下来我们还要增加刷脸支付等等其他支付怎么办呢，我们只能修改这个方法，这显然是不对的，违反了<code>开闭原则</code>。</p>
<p>增加支付其实和这个业务逻辑不是一个紧耦合的，我们应该增加他的复用性，如果我们要在其他地方支付呢。应该把实例化这部分也抽出来。就形成了<code>简单工厂类</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">static</span> <span class="title">createPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (小程序) &#123;</span><br><span class="line">            <span class="comment">//小程序支付</span></span><br><span class="line">            $pay = <span class="keyword">new</span> miniWechatPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (公众号) &#123;</span><br><span class="line">            <span class="comment">//公众号支付</span></span><br><span class="line">            $pay = <span class="keyword">new</span> jsAPIPay;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">            <span class="comment">//扫码支付</span></span><br><span class="line">            $pay = <span class="keyword">new</span> nativePay;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $pay;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//微信支付方法 省略了类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wechatPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略</span></span><br><span class="line">    $pay = factory::createPay();</span><br><span class="line">    $pay-&gt;pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样拆分有什么好处呢？</p>
<p>虽然增加支付的时候依旧需要修改代码，但是只需要修改简单工厂类，而不用修改业务逻辑类，避免了因为修改业务逻辑类而产生的业务逻辑bug。使得实例化对象和具体业务无关。</p>
<p>增加了代码的复用性，维护性，灵活性，测试性等。</p>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之单例模式--php实现单例模式</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-php%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="设计模式之单例模式–php实现单例模式"><a href="#设计模式之单例模式–php实现单例模式" class="headerlink" title="设计模式之单例模式–php实现单例模式"></a>设计模式之单例模式–php实现单例模式</h1><p><code>单例模式</code>是最常被提起的一个设计模式，他的意思是</p>
<blockquote>
<p>一个类只有一个实例，所有人共用这同一个实例。不让外部创建类的实例，并且提供一个外部的全局访问点。</p>
</blockquote>
<h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>单例模式有什么好处呢？</p>
<p>单例模式是为了全局唯一，如果你需要一个全局唯一的类那么就需要单例模式了。而且单例模式还可以节省资源，因为这个类只有一个对象。</p>
<p>比如你需要一个全局唯一的id生成器，如果创建了多个实例，那么生成的id可能就不是全局唯一了。</p>
<p>比如你需要一个全局配置信息，需要全局缓存信息，全局日志文件写入等等。</p>
<h2 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h2><p>下面是一个普通的类的实现和使用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Common</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">public</span> $age;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name, $age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'姓名：'</span>.<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        dump(<span class="string">'年龄：'</span>.<span class="keyword">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj1 = <span class="keyword">new</span> Common(<span class="string">'张三'</span>, <span class="string">'18'</span>);</span><br><span class="line">dump($obj1);</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">new</span> Common(<span class="string">'张三'</span>, <span class="string">'20'</span>);</span><br><span class="line">dump($obj1);</span><br></pre></td></tr></table></figure>
<p>可以看到普通类可以<code>new</code>多个对象，并且每个对象都不一样，拥有自己的属性。</p>
<h2 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h2><p>首先，单例类是一种特殊的类，单例类只允许<code>new</code>一次。怎么实现只能<code>new</code>一次呢，从上面的代码中可以看到，<code>new</code>这个操作是在我们的业务中进行的，这是个无法掌控的操作。</p>
<p>我们要让<code>new</code>操作在类中实现，由这个单例类来决定，来操作对象的实例化。而不是在业务中进行。</p>
<p>只有自己才能决定自己<code>new</code>不<code>new</code>，自己决定自己的人生，而不是交给别人，使得无法掌控。</p>
<p>从这个分析中可以知道，单例类要完成下面的操作：</p>
<ul>
<li>自己创建实例化，供外部全局访问</li>
<li>不允许外部实例化</li>
</ul>
<p>第一点简单，实现一个方法<code>new</code>自己，然后存起来返回就可以了。</p>
<p>第二点在php中怎么实现呢，不允许外部实例化可以通过将<code>__construct</code>方法设置为<code>private</code>权限。因为这个方法外部访问不到，所以外部就无法实例化了。</p>
<p>简单实现一下单例类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">public</span> $age;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name, $age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = $age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">($name, $age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">self</span>::$instance)) &#123;</span><br><span class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>($name, $age);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'姓名：'</span>.<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        dump(<span class="string">'年龄：'</span>.<span class="keyword">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj1 = Singleton::getInstance(<span class="string">'张三'</span>, <span class="string">'18'</span>);</span><br><span class="line">dump($obj1);</span><br><span class="line">$obj2 = Singleton::getInstance(<span class="string">'张三'</span>, <span class="string">'20'</span>);</span><br><span class="line">dump($obj2);</span><br></pre></td></tr></table></figure>

<p>这是把上面的普通类改成了单例类，现在这个单例类还有些问题。</p>
<ul>
<li>参数上面第二个参数没有生效</li>
</ul>
<p>单例类一般不会出现这种需要各种参数的，需要参数也建议通过配置文件来搞定参数，而不是传参。<strong>如果有传参需求，需要的是不同的参数是不同的对象，同一个参数是单例对象，那么需要维护一个单例对象的数组</strong>。为什么不提供修改参数的方法呢，因为提供这个方法太危险，全局使用同一个对象，如果某个地方不慎更改了属性，那么会导致其他地方出现未知bug。</p>
<ul>
<li>并没有完全禁止外部实例化，php还有魔术方法__clone。</li>
</ul>
<p>把__clone方法设置成<code>private</code></p>
<p>根据上面的我们在修改一下这个单例类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> $age;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = config(<span class="string">'design.singleton.name'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = config(<span class="string">'design.singleton.age'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">self</span>::$instance)) &#123;</span><br><span class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'姓名：'</span>.<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        dump(<span class="string">'年龄：'</span>.<span class="keyword">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj1 = Singleton::getInstance();</span><br><span class="line">dump($obj1);</span><br><span class="line">$obj2 = Singleton::getInstance();</span><br><span class="line">dump($obj2);</span><br></pre></td></tr></table></figure>

<p>到现在，我们就完成了一个基于php的单例类，这个单例类支持延迟加载。如果不需要延迟加载，那么实现更简单。看下面的<code>饿汉式单例类</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> $age;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象 饿汉式单例直接在这里new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = config(<span class="string">'design.singleton.name'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = config(<span class="string">'design.singleton.age'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     * 这里只需要直接返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'姓名：'</span>.<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        dump(<span class="string">'年龄：'</span>.<span class="keyword">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们支持延迟加载的其实还有些问题，那就是缺少锁，如果很多请求同时进来，那么后面的会覆盖前面的单例对象。如果再加上锁的话实现是下面这样。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> $age;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = config(<span class="string">'design.singleton.name'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = config(<span class="string">'design.singleton.age'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先加锁</span></span><br><span class="line">        $lock = <span class="keyword">new</span> lock;</span><br><span class="line">        $lock-&gt;lock();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">self</span>::$instance)) &#123;</span><br><span class="line">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        $lock-&gt;unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'姓名：'</span>.<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        dump(<span class="string">'年龄：'</span>.<span class="keyword">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话因为锁的原因会造成性能比较低，所以又有了下面的方式，叫做<code>双重检测</code>。也就是拿锁之前先判断一下有没有实例化，如果有了就不需要锁了。为什么不直接在第一个判断里面加呢，因为锁加晚了没有意义了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">protected</span> $age;  <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存放全局唯一对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造函数使得外部无法new对象</span></span><br><span class="line"><span class="comment">     * 构造函数去掉参数，参数从配置文件读取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = config(<span class="string">'design.singleton.name'</span>);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;age = config(<span class="string">'design.singleton.age'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化克隆函数使得外部无法克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取全局唯一对象的时候不需要传参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">self</span>::$instance)) &#123;</span><br><span class="line">            <span class="comment">//先加锁</span></span><br><span class="line">            $lock = <span class="keyword">new</span> lock;</span><br><span class="line">            $lock-&gt;lock();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">self</span>::$instance)) &#123;</span><br><span class="line">                <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            $lock-&gt;unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dump(<span class="string">'姓名：'</span>.<span class="keyword">$this</span>-&gt;name);</span><br><span class="line">        dump(<span class="string">'年龄：'</span>.<span class="keyword">$this</span>-&gt;age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是整个单例模式。四种实现：</p>
<ul>
<li>饿汉式 在类加载的时候实例化</li>
<li>懒汉式 支持延迟加载</li>
<li>带锁懒汉式 延迟加载的时候加锁</li>
<li>双重检测 两次判断</li>
</ul>
<p>代码放在了我的github上面。</p>
<ul>
<li><a href="https://github.com/Thepatterraining/design-pattern" target="_blank" rel="noopener">设计模式</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之KISS原则和YAGNI原则</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8BKISS%E5%8E%9F%E5%88%99%E5%92%8CYAGNI%E5%8E%9F%E5%88%99.html</url>
    <content><![CDATA[<h1 id="设计原则之KISS原则和YAGNI原则"><a href="#设计原则之KISS原则和YAGNI原则" class="headerlink" title="设计原则之KISS原则和YAGNI原则"></a>设计原则之KISS原则和YAGNI原则</h1><h2 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a>KISS原则</h2><p><code>KISS(Keep It simple and Stupid)原则</code>总的来说就是简单，你的代码要写的简单易懂。增加代码的可读性。</p>
<p>并不一定是代码量的多少来判断简单，而是通过可读性，如果这个代码可读性很好，比如你一下子就能看懂，这就说明符合KISS原则。</p>
<p>这个原则也比较主观，因为如果看代码的人水平比较差可能看不懂，而比你水平好的则可能一下子看懂。就像我们读框架源码读不懂并不是框架源码写的不好而是我们水平不够，哈哈哈哈。</p>
<p>怎么让代码简洁易懂呢？</p>
<ul>
<li>命名清晰易懂</li>
<li>可以写一些注释辅助看懂</li>
<li>遵守代码规范</li>
<li>统一团队风格</li>
</ul>
<p>我们要写出可读性好的代码而不是一些复杂的代码。我们的目的是写出实现需求的代码。</p>
<h2 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h2><p><code>YAGNI（You Ain&#39;t Gonna Need It）原则</code>的意思是你不需要他的时候就不要提前写好，不要做过度设计。我们可以基于扩展性留好’坑’，方便以后扩展新的代码。比如我们现在使用了微信支付，以后可能会接入支付宝支付，我们可以基于接口编程方便扩展，但不用直接写好支付宝支付的代码。</p>
<p>同样的，我们不要在代码中依赖不需要的东西，比如包管理，我们只需要当前需要的扩展包，不要把现在不需要的都加入进来。</p>
<p>比如<code>vue</code>的组件化设计，引入一些组件的时候，比如<code>element ui</code>组件，可以选择全部引入也可以选择按需加载。</p>
<p>还有各种懒加载，比如图片懒加载，树形结构的懒加载，我们只加载当前需要的东西。</p>
<p>参考资料：</p>
<ul>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之迪米特法则--我只依赖我需要的类</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-%E6%88%91%E5%8F%AA%E4%BE%9D%E8%B5%96%E6%88%91%E9%9C%80%E8%A6%81%E7%9A%84%E7%B1%BB.html</url>
    <content><![CDATA[<h1 id="设计原则之迪米特法则–我只依赖我需要的类"><a href="#设计原则之迪米特法则–我只依赖我需要的类" class="headerlink" title="设计原则之迪米特法则–我只依赖我需要的类"></a>设计原则之迪米特法则–我只依赖我需要的类</h1><p><code>迪米特法则（Law of Demeter） LOD</code>。这个原则是说我只依赖我确实需要的类，也叫最小知识原则。</p>
<p>这个原则的英文<strong>Each unit should have only limited knowledge about other units:only units ‘closely’ related to the current unit. Or:Each unit should only talk to its friends; Don’t talk to strangers.</strong></p>
<p>每个模块之应该了解哪些与他关系密切的模块的有限知识。或者说，每个模块只和自己的朋友说话，而不和陌生人说话。</p>
<p>如果说用好了<code>单一职责</code>可以写出高内聚的代码，那么用好了<code>迪米特</code>就可以实现低耦合。</p>
<p>在类的结构上，<strong>每一个类都应当尽量降低成员的访问权限</strong>。这样可以避免别人调用不应该调用的方法。我们只对外暴露应该暴露的方法。</p>
<p>这么做有什么好处呢？如果你的依赖越少，或者依赖你的类越少，那么当你修改的时候，你影响到的也越少，出bug的概率也越少。</p>
<p>我们应该设计好类之间的依赖关系。谁也不想管理一团乱麻的代码。如果你现在的项目依赖关系混乱，那么你可能根本不敢修改任何一个地方，生怕整个系统崩溃。依赖关系过多也会导致不好测试。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之依赖倒置原则--我的依赖被反转了</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99-%E6%88%91%E7%9A%84%E4%BE%9D%E8%B5%96%E8%A2%AB%E5%8F%8D%E8%BD%AC%E4%BA%86.html</url>
    <content><![CDATA[<h1 id="设计原则之依赖倒置原则–我的依赖被反转了"><a href="#设计原则之依赖倒置原则–我的依赖被反转了" class="headerlink" title="设计原则之依赖倒置原则–我的依赖被反转了"></a>设计原则之依赖倒置原则–我的依赖被反转了</h1><p><code>依赖倒置原则（Dependency Inversion Principle）DIP</code>。这个原则的英文是<code>high-level modules shouldn&#39;t depend on low-level modules. both modules should depend on abstractions. In addition, abstractions shouldn&#39;t depend on details.Details depend on abstractions.</code>。意思是高层模块不要依赖底层模块。高层模块和底层模块都应该依赖抽象。抽象不要依赖具体实现，具体实现应该依赖抽象。</p>
<h2 id="什么是依赖倒置原则"><a href="#什么是依赖倒置原则" class="headerlink" title="什么是依赖倒置原则"></a>什么是依赖倒置原则</h2><p>通常来说，调用者属于高层模块，被调用者就是低层模块。为什么叫依赖倒置或者依赖反转呢？正常开发来说类A调用类B，类A属于高层模块，类B是低层模块。高层模块依赖低层模块，需要调用低层模块的方法。直接和低层模块高度耦合。</p>
<p>如果这时候我们的低层模块需要适配不同的高层模块，那么就无法复用。因为低层模块和以前的高层模块耦合在一起，如果修改适配新模块可能会导致以前的高层模块出现问题。</p>
<p>依赖倒置原则就是把这个依赖关系进行反转。以前是高层模块依赖低层模块，现在我不依赖你了。咋俩都依赖抽象。我们使用抽象类或者接口。我们的实现都基于这个接口来进行，而不是产生直接的依赖关系。我们都依赖同样的接口，同样的抽象。</p>
<p>比如我们的电脑有CPU,键盘，鼠标，内存，硬盘，显示器这些东西，我们只要组装起来就是电脑，这些东西就像高内聚的程序。内聚在一起，他们依赖相同的接口进行调用，你的<code>罗技鼠标</code>和<code>雷蛇鼠标</code>都使用同一个接口。那么电脑就可以正常运转。</p>
<h2 id="如何使用依赖倒置原则"><a href="#如何使用依赖倒置原则" class="headerlink" title="如何使用依赖倒置原则"></a>如何使用依赖倒置原则</h2><p>我们进行软件设计的时候应该由上而下的设计，先进行抽象设计，然后来具体实现。如果先写出具体实现在进行抽象设计，那么抽象出来的东西就容易依赖具体实现。因为具体实现很可能会变，但是抽象一般不会改变。所以抽象使得程序更加稳定。</p>
<p>那么为什么抽象一般不会改变呢？这就是之前说的<a href="https://blog.csdn.net/Thepatterraining/article/details/105880396" target="_blank" rel="noopener">里氏替换原则</a>。子类可以替换父类，需要改变我们只需要扩展具体实现就可以而不是修改抽象。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//电脑需要一个能插入usb接口的鼠标</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">computer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(USB $mouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mouse = $mouse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//雷蛇鼠标实现了usb接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">snakeMouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//罗技鼠标实现了usb接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">luoMouse</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">usb</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，不管是哪个鼠标都可以使用，如果我们依赖具体的鼠标，那么就无法灵活更换了。两边，调用者和被调用者，高层模块和低层模块都依赖抽象。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之接口隔离原则--如何通过接口隔离职责</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E8%81%8C%E8%B4%A3.html</url>
    <content><![CDATA[<h1 id="设计原则之接口隔离原则–如何通过接口隔离职责"><a href="#设计原则之接口隔离原则–如何通过接口隔离职责" class="headerlink" title="设计原则之接口隔离原则–如何通过接口隔离职责"></a>设计原则之接口隔离原则–如何通过接口隔离职责</h1><p><code>接口隔离原则（Interface Segregation Principle） ISP</code>。这个原则是说客户端不应该依赖他不需要的接口。</p>
<p>这个原则的英文是<code>Clients should not be forced to depend upon interfaces that they do not use</code>。</p>
<h2 id="如何使用接口隔离原则"><a href="#如何使用接口隔离原则" class="headerlink" title="如何使用接口隔离原则"></a>如何使用接口隔离原则</h2><p>这里面的接口不同于我们的API接口，也不是电脑的USB接口这种，而是我们程序中使用的<code>接口Interface</code>。</p>
<p>我们通过让程序实现不同的接口来完成不同的职责。这个原则和单一职责原则也有点类似。比如一个类既有查询功能还有修改功能。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在有一个类需要使用这个类的查询功能。它只需要使用查询，但是他还是可以知道这个类有修改功能，可以使用他的修改功能。另外有一个类只需要修改却同样被迫加载了查询功能。</p>
<p>如果我们增加两个接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">list</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">list</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">update</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">class</span> <span class="title">demo</span> <span class="title">implements</span> <span class="title">list</span>, <span class="title">update</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(list $demo)</span> </span>&#123;</span><br><span class="line">        $demo-&gt;list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testUpdate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(update $demo)</span> </span>&#123;</span><br><span class="line">        $demo-&gt;update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们通过接口将查询和更新分离开，查询方只依赖查询接口，只能感知到查询操作，更新方只依赖更新接口，只能感知到更新操作，不需要知道这个类其他的功能，也防止了误操作。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之里氏替换原则--子类可以替换父类吗</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9B%BF%E6%8D%A2%E7%88%B6%E7%B1%BB%E5%90%97.html</url>
    <content><![CDATA[<h1 id="设计原则之里氏替换原则–子类可以替换父类吗"><a href="#设计原则之里氏替换原则–子类可以替换父类吗" class="headerlink" title="设计原则之里氏替换原则–子类可以替换父类吗"></a>设计原则之里氏替换原则–子类可以替换父类吗</h1><p><code>里氏替换原则（Liskov Substitution Principle）LSP</code>，这个原则是说子类应该可以替换父类进行使用。</p>
<p>这个原则的英文描述是<code>functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it</code>。子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<h2 id="为什么要使用里氏替换原则"><a href="#为什么要使用里氏替换原则" class="headerlink" title="为什么要使用里氏替换原则"></a>为什么要使用里氏替换原则</h2><p>在我们的日常开发中很常用<code>依赖注入</code>，简单来说就是通过外部传入对象而不是内部<code>new</code>对象。传入参数的时候我们可以通过标识父类或者接口。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span><span class="params">(Idemo $demo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    $demo-&gt;run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我不关心你传进来的是个什么玩意，只要你实现了Idemo这个接口的对象就可以。或者是继承了Idemo这个类的自类对象也可以，只要你实现了run这个方法，并且属于Idemo这个类或者接口。我们经常使用这个方法来增加程序的测试行，扩展性，灵活性。比如我们需要一个支付接口的时候。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">(Payment $payment)</span> </span>&#123;</span><br><span class="line">    $payment-&gt;pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们购买东西的时候，只要知道我要支付就可以了，至于你传进来的是支付宝支付还是微信支付我不需要知道。</p>
<p>在这里面，支付宝或者微信支付就是具体的自类，而<code>Payment</code>就是他们的父类。这些子类对象可以替换他们的父类对象，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>
<h2 id="里氏替换和多态"><a href="#里氏替换和多态" class="headerlink" title="里氏替换和多态"></a>里氏替换和多态</h2><p>其实我们上面使用的就是面向对象里面的<code>多态</code>。但是多态并不是里氏替换。类的多态特性允许我们重新实现父类的函数，我们可以根据不同的需求来改写。但是里氏替换原则要求不能修改原来的逻辑行为和正确性。</p>
<p>比如父类中这个函数返回了异常而子类没有，那么这就违反了里氏替换原则。</p>
<p>比如原来内容是123，而子类改成了456，那么同样违反了里氏替换原则。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之开闭原则--对扩展开发对修改关闭</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AF%B9%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD.html</url>
    <content><![CDATA[<h1 id="设计原则之开闭原则–对扩展开发对修改关闭"><a href="#设计原则之开闭原则–对扩展开发对修改关闭" class="headerlink" title="设计原则之开闭原则–对扩展开发对修改关闭"></a>设计原则之开闭原则–对扩展开发对修改关闭</h1><p><code>开闭原则(Open Closed Principle) OCP</code>，这个原则是说对扩展可以开放，但是对修改要关闭。</p>
<p>这个原则的英文描述是<code>software entities(modules,classes,functions,etc.) should be open for extension, but closed for modification.</code>。</p>
<h2 id="为什么要使用开闭原则"><a href="#为什么要使用开闭原则" class="headerlink" title="为什么要使用开闭原则"></a>为什么要使用开闭原则</h2><p>引用<code>大话设计模式</code>书中的故事。在香港澳门回归的时候，我国使用了<code>一国两制</code>的方针。<strong>这其实就是没有修改任何地方，但却扩展了我国的领土。</strong>这也就是对修改关闭，对扩展开放。</p>
<p><code>开放封闭原则</code>，是说软件实体应该可以扩展，但是不可修改。</p>
<p>在现在的开发中，改需求是一个很常见的事情，我们经常需要<strong>这个需求要改成这样，明天上线！！</strong>这种事情。这时候我们加班加点改完一个类实现了新需求。这个时候发现由于这个类的依赖太多，我们的修改引起了其他地方的bug，那我们需要整体测试，然后各种修改，还可能引起更多的bug，如此耗时耗力。</p>
<p>在思考另外一个场景，同样我们实现了需求，这个时候没出其他问题，但是！！！<strong>这个需求要改回去，你把之前的代码拿出来吧</strong>。我相信你一定很不爽的，如果我们可以通过git来回滚到之前的代码还好，如果我们之前的代码在本地没有提交这个时候我们又修改完了，那，呵呵，再改回去吧，鬼知道之前代码啥样。</p>
<p>如果我们遵循<code>开闭原则</code>，不是通过修改类来完成，而是通过扩展类的方式来完成这个新需求，那么我们就避免了这些问题，扩展不会引起其他的未知bug。不会影响到其他的类。如果要改回去我们原来的代码也还在。这就是开闭原则的好处了。</p>
<h2 id="如何使用开闭原则"><a href="#如何使用开闭原则" class="headerlink" title="如何使用开闭原则"></a>如何使用开闭原则</h2><p>无论模块是多么的封闭，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对那种变化封闭做出选择。<strong>它必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离哪些变化</strong>。</p>
<p>我们开发中，最开始的时候，很难预测接下来的变化。但是，一旦发生变化我们可以根据变化来采取行动，进行抽象重构。使得接下来通过扩展和少量的必要修改来应对需求的变化。</p>
<p>开闭原则是面向对象设计的核心所在。<strong>遵循这个原则可以带来面向对象技术所生成的巨大好处，也就是可维护，可扩展，可复用，灵活性好。</strong>我们应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>
<p>我们可以在开发的开始阶段对接下来能预测到的变化留出扩展空间，然后再不断的持续重构开发代码中一直遵循开闭原则。</p>
<p>很多设计模式都是以提高扩展性为目的。最常用的方法有：多态，依赖注入，基于接口编程等。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则之单一职责--为什么要设计成单一职责</title>
    <url>/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3.html</url>
    <content><![CDATA[<h1 id="设计原则之单一职责–为什么要设计成单一职责"><a href="#设计原则之单一职责–为什么要设计成单一职责" class="headerlink" title="设计原则之单一职责–为什么要设计成单一职责"></a>设计原则之单一职责–为什么要设计成单一职责</h1><p><code>单一职责原则(Single Responsibility Principle) SRP</code>的意思是，就一个类而言，应该仅有一个引起他变化的原因。</p>
<p>这个原则的英文描述是<code>A class or module should have a single reponsibility</code>。一个类或者模块只有一个职责。</p>
<h2 id="为什么要使用单一职责"><a href="#为什么要使用单一职责" class="headerlink" title="为什么要使用单一职责"></a>为什么要使用单一职责</h2><p>借用<code>大话设计模式</code>一书中使用的例子。比如现在科技高度发达，<code>手机</code>成为了日常使用中不可替代的产品。手机的功能很多，可以拍照，可以上网，可以打电话，聊天，打游戏等。假设我们没有手机，那么我们拍照需要摄像机，打游戏需要游戏机，听歌需要mp3，但是现在不用带这么多东西，只需要一个手机就搞定了。觉得很方便。但是呢，手机的拍照功能并没有单反好，游戏性能和游戏数量也比不上ps4和xbox以及ns。</p>
<p>如果放在代码中就是你的所有代码都写在一起，像一团乱麻一样。严重影响了可读性，扩展性，维护性等。相信没有人喜欢看到这样的代码。所以这就是<code>单一职责</code>。对代码要有结构，要清晰明了，其实代码中到处都体现了这个原则。比如<code>mvc</code>的分层架构，比如前后端分离，比如<code>docker</code>的兴起，比如我们日常使用的框架也分离了我们的职责，使得我们只需要关注一些实现就好了。再生活中也有比如公司分成了各个部门，人类分成了男人女人，由各个职业。每个人只需要关注自己的事情，简单明了。这就是单一职责的好处。</p>
<p>如果一个类承担的<code>职责</code>过多，就等于把这些职责耦合在一起，一个变化会引起其他意想不到的变化，使得整个程序脆弱不堪。我们经常说要写<code>高内聚，低耦合</code>的代码，如果违反了单一职责那么就只能写出高耦合的代码了。</p>
<h2 id="如何使用单一职责"><a href="#如何使用单一职责" class="headerlink" title="如何使用单一职责"></a>如何使用单一职责</h2><p><strong>如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责</strong>。如果类的职责多了，我们就需要把他们分离开来，当然了，这个原则比较具有主观性。有的人觉得这个类不是单一职责，有的人觉得是单一职责。</p>
<p>判断是否单一职责要结合具体的业务场景和使用，如果你有多个引起这个类变化的地方，那么就需要重新考虑一下这个类是否符合单一职责了。</p>
<p>在我们平常开发中，没必要一开始纠结是否符合单一职责，随着开发的演进，程序越来越庞大，我们需要随着业务的发展将类分的越来越细才好，要持续重构。一定不要等到已经往一个类里面塞了很多代码才考虑划分成单一职责。那样的话拆分起来很费劲而且耗时耗力。<strong>在添加新功能的时候要想一想这个功能应该添加到哪里，是否符合单一职责</strong>。</p>
<p>开发中可以根据下面几点来判断是否满足单一职责：</p>
<ul>
<li>类中的代码过多，影响了代码的可读性和维护性。</li>
<li>和这个类有依赖关系的类比较多，耦合过高。</li>
<li>比较难给类命名，不清楚这个类是干啥的了。</li>
<li>类中大量的方法都是集中操作类的某几个属性。</li>
</ul>
<h2 id="类的职责是否越单一越好"><a href="#类的职责是否越单一越好" class="headerlink" title="类的职责是否越单一越好"></a>类的职责是否越单一越好</h2><p>显然不是的，如果一个类过于职责单一，比如加密类，有一个加密方法和解密方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们执着于单一职责，要把这个类拆分成两个类。一个加密类一个解密类。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashDecode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashEncode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这时候根据新的需求，我们的加密算法需要改变，那么解密算法也需要改变，我们要同时改变两个类，如果忘记其中一个，那么整个程序就会崩溃。我们的最终目标是写出<code>高内聚低耦合</code>的代码。而不是生搬硬套某一个设计原则或者设计模式。<strong>设计原则是总结出来指导我们进行程序设计的方针。合理使用可以使得我们的程序更加健壮</strong>。</p>
<p>参考资料：</p>
<ul>
<li>大话设计模式</li>
<li>极客时间设计模式之美</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计原则</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD领域驱动设计和充血模型</title>
    <url>/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html</url>
    <content><![CDATA[<h1 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h1><p>什么是<code>贫血模型</code>？</p>
<p><code>贫血模型</code>就是缺血了，缺东西，也就是只有数据但是没有业务逻辑或者有业务逻辑但是没有数据。</p>
<p>比如你有一个计算类，他有一个加法计算的方法。但是他不持有计算的数据。</p>
<p>和贫血模型对应的就是充血模型。</p>
<p>什么是<code>充血模型</code>？</p>
<p><code>充血模型</code>就是不缺血了，有数据同样有业务逻辑。</p>
<p>比如你的计算类现在不只有加法计算，还有需要的数据。</p>
<p>我们现在进行的开发基本上都是基于贫血模型开发的。</p>
<p>比如一个电商系统，有商品模型，但是一个商品模型只有商品的基本信息，数据。如果需要获取一个商品的总价，那么我们需要调用model里面的一个方法来计算。这就是典型的贫血模型。</p>
<p>如果我们在商品模型里面提供一个计算总价的方法。把数据和业务逻辑放在一起，这就是充血模型。</p>
<h1 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h1><p>充血模型要将数据和业务高度内聚在一个类中，使得类更加饱满，也是高内聚低耦合的一种实践。不过充血模型需要更好的设计整个类才能实现。因为要考虑到扩展性，测试性，可读性，复用性等。充血模型注定比贫血模型更加耗费时间，更加难以实现。</p>
<p>现在更推崇敏捷开发。快速实现需求，慢慢迭代升级。如果使用充血模型也容易搞得四不像。也因此贫血模型更让人喜欢。贫血模型也更容易设计和实现，日常开发中随便写的都是贫血模型。而充血模型需要进行好好的设计。那怎么设计充血模型呢？可以根据<code>DDD领域驱动设计</code>来实现。</p>
<h1 id="领域驱动设计DDD"><a href="#领域驱动设计DDD" class="headerlink" title="领域驱动设计DDD"></a>领域驱动设计DDD</h1><p>DDD的概念很早就有了，但是一直没有火起来。现在又出现了<code>充血模型</code>的概念。</p>
<p>DDD的核心思想其实就是根据不同的领域，功能来设计建模，划分模块。微服务的划分就可以借鉴DDD的思想，根据不同的业务领域来划分。</p>
<p>DDD可以用来指导我们如果做软件设计，但是想要用好DDD，需要对自身的业务足够理解，足够熟练。</p>
<p><code>领域</code>是一个组织所做的事情以及其包含的一切。领域驱动设计就是从自身的领域出发，分析自身领域内的一切关联关系，根据其设计我们的软件。构造充血模型。也就是充血模型是和业务高度耦合的，完全从自身的领域出发进行设计。可以先将自身的领域细分出多个子领域，然后再每个子领域中设计出各自的领域模型。也就是充血模型。</p>
<p>比如电商领域可以分成用户，商品，订单，物流等子领域。然后设计出各自的实体对象，根据全局领域的上下文来分析需要承担哪些责任也就是哪些数据和业务逻辑。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么很多人不推荐mysql连表join查询</title>
    <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%8E%A8%E8%8D%90mysql%E8%BF%9E%E8%A1%A8join%E6%9F%A5%E8%AF%A2.html</url>
    <content><![CDATA[<h1 id="为什么很多人不推荐mysql连表join查询"><a href="#为什么很多人不推荐mysql连表join查询" class="headerlink" title="为什么很多人不推荐mysql连表join查询"></a>为什么很多人不推荐mysql连表join查询</h1><p>join查询是什么？是连表查询，我们需要两个表的数据，就会使用join来进行连表。那么mysql里面是怎么连表的呢？它和我们自己查询出一张表的数据在遍历去查询另外一个表是不是一样呢？</p>
<h2 id="join查询"><a href="#join查询" class="headerlink" title="join查询"></a>join查询</h2><p>join查询还可以写成left join，表示的是根据左边的表来查询右边的表。但实际上，优化器会进行优化，选择合适的表来做驱动表，不一定是左边的表。</p>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><p>NLJ算法，这是一种基于索引的算法，如果你的连表用到了索引，则会使用这个算法。</p>
<p>比如下面的查询语句：</p>
<p>b.uid字段有索引，并且假设a是小表，优化器选择了a表作为驱动表，b表作为被驱动表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id = b.uid;</span><br></pre></td></tr></table></figure>

<p>执行流程大致如下：</p>
<ol>
<li>读取表a的第一行数据</li>
<li>使用表a的id去b表的索引树上查询到对应的b表id</li>
<li>通过查询的b表id回表查询b表数据</li>
<li>把a表和b表数据放在一起</li>
<li>重复上面的步骤直到a表遍历完成</li>
<li>返回数据</li>
</ol>
<p>可以看到这和我们自己查询出一张表然后遍历查询过程是一样的。</p>
<p>但是它的优势是省略了多次连接数据库，连接数据库是比较耗费资源和时间的，这样来看，使用join是更加好的选择。当然前提是你的join被驱动表有索引。</p>
<p>这个过程扫描了整个表a和表a的id对应的每一行表b。假设a表的数据量是n，那么扫描了n + n行，当然不算回表。如果算上回表其实相当于n + n + n行。</p>
<p>我们再看一下这个算法的时间复杂度。</p>
<p>b+树中，定位一个记录的时间复杂度大约是log(m)。m是b表的数据行数。为什么这里使用了b表的数据行数而不是上面说的a表的行数呢，因为这里指的是b表索引树的时间复杂度，当然是跟b表索引树大小挂钩也就是b表数据大小挂钩了。如果在算上回表查询，那么时间复杂度大约是2log(m)。</p>
<p>a表要进行全表扫描，那么a表的时间复杂度就是n，再加上每一行要去b表中查询，那么去b表查询的时间就是n * 2log(m)。加起来就是n + (2nlog(m))。</p>
<p>这里面2是常量可以忽略不记，而且2是因为回表造成的，如果我们使用覆盖索引，那么这个2就可以去掉了。</p>
<p>nlog(m) 比 n小，所以显然n的影响是最大的。也就是说n越小，那么我们连表的速度就越快。所以我们连表的时候要使用更小的那张表作为驱动表，然后给被驱动表的连表字段上面加上索引或者覆盖索引。这样我们的连表其实还是很快的。</p>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><p>如果你的被驱动表字段上面没有索引，那么mysql就会使用另外一种算法。这个算法叫BNL算法。</p>
<p>本来没有索引的情况下，按照上面的流程应该是下面这样：</p>
<ol>
<li>读取表a的第一行数据</li>
<li>使用表a的id去b表上进行全表扫描查询到对应的b表数据</li>
<li>把a表和b表数据放在一起</li>
<li>重复上面的步骤直到a表遍历完成</li>
<li>返回数据</li>
</ol>
<p>这样的话对于每一行表a的数据都要进行b表的全表扫描，也就是如果表a记为n行，表b记为m行，那么需要扫描n * m + n行数据。和上面的n + (2nlog(m))相比，可以看到慢了多少倍。</p>
<p>所以mysql使用了另外一种方法，也就是BNL算法，这个算法做了一下优化，流程变成了下面这样：</p>
<ol>
<li>读取表a的所有数据放入join buffer</li>
<li>对表b进行全表扫描，然后把每一条数据和join buffer中的数据做对比。</li>
<li>把满足条件的数据返回。</li>
</ol>
<p>这样的话，也就是扫描了一遍表a和表b，那么需要扫描n + m行数据。可以看到比上面的n + (n<em>m)来说少了n倍的扫描量。当然了，这个算法，还需要在join buffer中进行n</em>m次对比数据，但是这样内存判断也要比上面的方法好很多。</p>
<p>同样的这个算法对于两张表都是全表扫描，也就无所谓上面说的需要小表做驱动表了，反正都一样，都要全表扫描。</p>
<p>join buffer存在内存中，那么他就有大小的限制，参数<code>join_buffer_size</code>就是限制join buffer大小的。默认值是256k。如果表a的数据大于join buffer的大小，那么就会分段，也就是分多次进行。</p>
<p>但是分多次执行就会有一个问题了。比如分成了c次，那么表b就要经历c次的全表扫描。所以内存允许，当然Join buffer大一点速度会快一些。</p>
<p>这样的话就不是上面的n + m了，而是变成了n + (c*m)，c是根据join buffer大小和n的大小来决定的。如果n越小或者join buffer size越大，那么c就越小。也就是说，如果我们使用小表作为驱动表，那么在遇到数据量超过join buffer的时候，速度也会比较快。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，Join的时候注意下面几点：</p>
<ul>
<li>总是用小表作为驱动表比较好。</li>
<li>能加索引就在被驱动表join字段上面加索引，使用NLJ算法而不是BNL算法。</li>
<li>在没有索引，并且驱动表数据量过大时，可以通过调大join_buffer_size的值来加速连表查询。</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlorderby详解-sortbuffer是什么东西</title>
    <url>/mysqlorderby%E8%AF%A6%E8%A7%A3-sortbuffer%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF.html</url>
    <content><![CDATA[<h1 id="mysql是怎么操作order-by来进行排序的"><a href="#mysql是怎么操作order-by来进行排序的" class="headerlink" title="mysql是怎么操作order by来进行排序的"></a>mysql是怎么操作order by来进行排序的</h1><p>mysql的排序用到了sort buffer，sort buffer是一个内存块。</p>
<p>mysql会先取出需要排序的数据，然后把数据放入sort buffer，当所有数据都放入sort buffer或者sort buffer满了就开始排序，然后将排序好的结果返回给客户端。</p>
<p>参数<code>sort_buffer_size</code>显示的就是sort buffer的大小。</p>
<p>如果数据量超过sort buffer，那么就会通过磁盘临时文件辅助进行排序，如果数据量比较小，则可以直接在内存中进行。</p>
<p>在内存中排序会使用<code>快排算法</code>，而通过磁盘临时文件则会使用<code>归并排序算法</code>。</p>
<p>排序步骤可以分为以下几步：</p>
<ol>
<li>取出select的数据存入sort buffer。</li>
<li>在sort buffer中进行快排或者归并排序算法。</li>
<li>如果有limit按照limit取相应的结果集进行返回。</li>
</ol>
<h3 id="rowid排序算法"><a href="#rowid排序算法" class="headerlink" title="rowid排序算法"></a>rowid排序算法</h3><p>这里面select出来的数据量可能会很大，跟你要查询的列多少有关，如果你的列很多，那么mysql可能会使用另外一种排序方法，叫做<code>rowid</code>排序。</p>
<p>rowid算法不管你查询出来的结果集，它只把必要的字段放入sort buffer中，这样sort buffer就可以存入更多的数据来进行排序。</p>
<p>必要的字段也就是你排序需要的字段和主键字段，比如<code>order by time</code>那么他只会放入id 和 time，然后按照time字段排序完成后再通过主键id回表查询一遍数据，然后返回数据。</p>
<p>显然rowid算法还需要再次回表，所以效率上要低一些，所以不是mysql默认使用的排序方法。</p>
<p>只有当你的内存不够用，查询的列太多的时候，mysql才会使用这种算法。</p>
<p>排序步骤可以分为以下几步：</p>
<ol>
<li>取出排序的字段和id存入sort buffer。</li>
<li>在sort buffer中进行快排或者归并排序算法。</li>
<li>按照排序结果和limit数量回表查询然后返回数据。</li>
</ol>
<h3 id="不需要排序的方法"><a href="#不需要排序的方法" class="headerlink" title="不需要排序的方法"></a>不需要排序的方法</h3><p>既然这样，我们为了更快速，可以避免mysql排序。</p>
<p>innoDB的索引是有序的，也就是说，如果我们要排序的字段本身就是有序的，那么就不用排序了。</p>
<p>所以我们可以在排序字段上建立索引，而如果我们查询的字段不多，甚至可以建立覆盖索引，那么速度会快很多。</p>
<p>mysql到底有没有进行排序，可以通过explain的执行计划来看。如果最后有using filesort，就表示使用了排序算法。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你搞懂为什么大家都推荐count*而不是countid</title>
    <url>/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E9%83%BD%E6%8E%A8%E8%8D%90count-%E8%80%8C%E4%B8%8D%E6%98%AFcountid.html</url>
    <content><![CDATA[<h1 id="一文带你搞懂为什么大家都推荐count-而不是count-id"><a href="#一文带你搞懂为什么大家都推荐count-而不是count-id" class="headerlink" title="一文带你搞懂为什么大家都推荐count(*)而不是count(id)"></a>一文带你搞懂为什么大家都推荐count(*)而不是count(id)</h1><p>在开发中，我们经常用到count这个函数来计算行数，尤其是后台列表展示。</p>
<p>那么究竟应该使用count(<em>)还是count(id)呢？很多人，很多书籍都推荐使用count(</em>)。</p>
<h3 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h3><p>在每个引擎里面其实是不一样的，比如myisam引擎，会把总行数存起来，如果你需要总行数，那么直接返回，那速度嗖嗖嗖的。</p>
<p>我们常用的innoDB引擎呢，他就真的是一行行计数了。</p>
<p>那为什么一行行计数还推荐count(*)呢？</p>
<p>innoDB是索引树组织表，不仅有主键索引树还有其他索引树，而count(*)反正是要全表扫描，那么优化器会去遍历最小的索引树，普通索引树的叶子节点只有id，当然要更小一些。</p>
<p>执行这个的时候innoDB遍历全表，但不取值，并且不判断，因为count(*)肯定不是null，直接累加。</p>
<h3 id="count-id"><a href="#count-id" class="headerlink" title="count(id)"></a>count(id)</h3><p>执行这个的时候innoDB遍历全表，把每一行数据的id值取出来返回给mysql，mysql拿到数据以后判断不为空则+1。累加后返回。</p>
<h3 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h3><p>执行这个的时候innoDB遍历全表，但不取值，直接返回给mysql，mysql收到返回值，给返回值赋值1，然后判断，累加。</p>
<h3 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a>count(字段)</h3><p>这个和count(id)类似，只不过如果允许为空的话，需要把值取出来做个判断，多个判断。如果不允许为空，那就一样了。</p>
<p>这么一对比，就看出来了，显然count(<em>)更快，这也是因为mysql对count(</em>)这个语句专门做了优化。所以更推荐count(*)</p>
<blockquote>
<p>count(字段) 慢于 count(id) 慢于 count(1) 慢于 count(*)</p>
</blockquote>
<p>除了这些我们同样可以自己实现计数。</p>
<p>我们可以使用缓存系统，将计数放入缓存，然后持久化。比如redis。</p>
<p>我们也可以直接创建一个计数的表，把计数字段放入表里。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一些学习网站</title>
    <url>/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99.html</url>
    <content><![CDATA[<h1 id="推荐一些学习网站"><a href="#推荐一些学习网站" class="headerlink" title="推荐一些学习网站"></a>推荐一些学习网站</h1><h2 id="coursera"><a href="#coursera" class="headerlink" title="coursera"></a>coursera</h2><p><a href="https://www.coursera.org/" target="_blank" rel="noopener">coursera</a>是国际最大的高校慕课网站。上面有很多很火的课程，可以选择免费旁听，只不过免费的没法做作业。但是课件都是一样的，很多都有了中文字幕。也可以选择付费学习或者申请助学金，如果申请助学金成功就不用掏钱了。</p>
<p><img src="../images/coursera.png" alt="coursera"></p>
<h2 id="edx"><a href="#edx" class="headerlink" title="edx"></a>edx</h2><p><a href="https://www.edx.org/" target="_blank" rel="noopener">edX</a>是麻省理工和哈佛大学于2012年4月联手创建的大规模开放在线课堂平台。</p>
<p>这上面也有很多免费的优秀课程。</p>
<p><img src="../images/edx.png" alt="coursera"></p>
<h2 id="优达学城"><a href="#优达学城" class="headerlink" title="优达学城"></a>优达学城</h2><p><a href="https://cn.udacity.com/courses/all" target="_blank" rel="noopener">优达学城 Udacity</a> 是来自硅谷的前沿技术平台，由 Google无人车之父 Sebastian Thrun 创立，与 Google、Facebook、Amazon 等全球顶尖技术公司联合开发了一系列的专业认证项目，为前沿技术领域培育了数万名顶尖专业人才，已与百度、腾讯、滴滴出行等中国前沿技术企业开发了一系列的课程项目</p>
<h2 id="中国大学mooc"><a href="#中国大学mooc" class="headerlink" title="中国大学mooc"></a>中国大学mooc</h2><p><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学mooc</a>是国内高校慕课平台，里面都是高校老师授课，还是免费的。让你在家学习高校课程。</p>
<h2 id="学堂在线"><a href="#学堂在线" class="headerlink" title="学堂在线"></a>学堂在线</h2><p><a href="https://next.xuetangx.com/" target="_blank" rel="noopener">学堂在线</a>是由清华大学研发出的中文MOOC（大规模开放在线课程，简称慕课）平台，于2013年10月10日正式启动，面向全球提供在线课程。任何拥有上网条件的学生均可通过该平台，在网上学习课程视频。</p>
<h2 id="极客时间"><a href="#极客时间" class="headerlink" title="极客时间"></a>极客时间</h2><p><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a>极客邦科技出品的 IT 类知识服务产品，内容包含专栏订阅、极客新闻、热点专题、直播、视频和音频等多种形式的知识服务。 [1]  产品形态包括移动 App，移动端网站、PC 端网站、微信平台等。</p>
<p>不过极客时间是收费的，虽然不贵，学生还有半价优惠，平时也有活动。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>vscode</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引详解-你的数据库用对索引了嘛</title>
    <url>/mysql%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3-%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%A8%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BA%86%E5%98%9B.html</url>
    <content><![CDATA[<h1 id="mysql索引详解-你的数据库用对索引了嘛"><a href="#mysql索引详解-你的数据库用对索引了嘛" class="headerlink" title="mysql索引详解-你的数据库用对索引了嘛"></a>mysql索引详解-你的数据库用对索引了嘛</h1><p>mysql的索引一般分为主键索引，唯一索引，普通索引，联合索引，覆盖索引等。</p>
<p>索引这么多，到底该怎么用，用哪个索引适合，需不需要索引呢？</p>
<h2 id="innoDB的索引"><a href="#innoDB的索引" class="headerlink" title="innoDB的索引"></a>innoDB的索引</h2><p>innoDB里面一般采用b+树索引模型，当然还有其它比如哈希索引，全文索引，空间索引。但是常用的还是b+树索引。</p>
<p>B+树是一个N叉平衡树。为什么不用二叉平衡树呢，因为二叉平衡树高度太高了，n叉平衡树可以控制树的高度，大概在3-4的高度，而树的根节点一般存在内存中，这样只需要做2-3次磁盘操作就可以了。大量的减少了磁盘操作。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p><code>主键索引</code>是一种聚簇索引，什么是<code>聚簇索引</code>呢，就是和数据放在一起的。b+树的叶子节点存放的是页，每个页的默认大小是16kb。主键索引树的叶子节点存放的是主键id和数据。一般我们都会用id做为主键。如果一个表不指定主键，Innodb会使用row id作为主键。</p>
<p>我们使用主键查询数据，来看一下执行计划。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> auth_users <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql03.png" alt="执行计划"></p>
<p>可以看到里面key列显示的是primary，表示使用了主键索引。row列是1，表示扫描了一行。通过树搜索的方式快速定位了主键id的位置并且取出数据进行了返回。</p>
<p>为什么主键推荐使用<code>递增id</code>呢，这是因为对索引树的增删改查要更加快速。所以一般使用自增主键。也避免了插入引起的<code>页分裂</code>和删除引起的<code>页合并</code>。</p>
<p>如果现在表里有id=4,5,6的数据，你插入了一条id=3的数据。这时候存放id=4,5,6数据的数据页满了，就需要页分裂，变成两个数据页。</p>
<p>页合并就是相邻的两个数据页的数据都挺少的，可以合并到一起，那么就会页合并。</p>
<p>使用自增主键则只需要不断往后写入就可以了，不需要担心中间的插入。而且自增主键占用的空间同样相对较小。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p><code>二级索引</code>也是<code>非聚簇索引</code>。包括<code>唯一索引</code>和<code>普通索引</code>。他们同样是b+树的方式存放，只是他们的叶子节点中存放的并不是真正的数据，而是主键id。那么通过这种索引怎么找到数据呢，其实是先找到对应的主键id，再去主键索引树中通过主键id找到对应的数据，也叫<code>回表</code>。</p>
<p>唯一索引和普通索引的区别在于查询的时候，唯一索引查询到条件对应的数据后不会接着查询了，而普通索引会接着查询，直到不满足条件为止。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><code>覆盖索引</code>是一种优化的手段。覆盖索引也是一种<code>联合索引</code>。</p>
<p>比如我们查询用户信息的时候，如果需要根据用户名查询用户名和密码。我们在用户名字段创建了一个索引。那么查询的时候就会走索引，但是查到的是id，还需要再去主键中找到数据，取出用户名和密码两个字段。</p>
<p>如果我们在用户名的索引树中不仅存了id，还存了我们需要的密码字段，不就不需要再去回表了吗？那我们就需要创建一个<code>用户名和密码的联合索引</code>。这样我们就不需要再回表了，这也就是覆盖索引。覆盖了我们要查询的字段。当然，你通过索引查询的时候，执行计划显示的行数还是1.这是因为回表这个操作是在innoDB里面做的，mysql是感觉不到的。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引下推也是一种优化。比如我们要查询<code>用户名是张三</code>，<code>密码是123456</code>的用户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'张三'</span> <span class="keyword">and</span> pwd = <span class="string">'123456'</span></span><br></pre></td></tr></table></figure>

<p>在mysql5.6以前，只能查询到张三这个数据以后回表找到数据在判断密码。</p>
<p>而mysqll5.6增加索引下推的优化之后，可以在索引遍历过程中，对name和pwd两个字段同时做判断。</p>
<h2 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h2><p>这两个索引到底该怎么选择，比如用户名字段，用户名当然是不能重复的了。那么它应该使用唯一索引还是普通索引呢？</p>
<p>一般用户注册的时候我们会判断用户名是否重复。所以用户名字段加唯一索引的价值并不大，我们的业务已经能保证它不重复了。</p>
<p>我们在上面说过，查询的时候，唯一索引查询到数据直接就返回了，显然要比普通索引快一些。</p>
<p>但是真的也就快了那么一点，因为InnoDB引擎在读取的时候，是读取一个数据页的数据。它会先把一个数据页读取到内存中，然后查询，那么在内存中多查一次其实没啥感觉。</p>
<p>在看一下更新的时候。</p>
<h4 id="数据在内存里面"><a href="#数据在内存里面" class="headerlink" title="数据在内存里面"></a>数据在内存里面</h4><p>如果数据在内存中，那么唯一索引会判断更新后是否会破坏唯一性，如果不破坏则更新。</p>
<p>普通索引则直接更新。</p>
<p>这里显示普通索引更好，不用判断。但是这个影响页很小，和上面一样，在内存中操作的。</p>
<h4 id="数据不在内存中"><a href="#数据不在内存中" class="headerlink" title="数据不在内存中"></a>数据不在内存中</h4><p>如果数据不在内存中，那么唯一索引就需要从磁盘读取数据，然后判断，更新。</p>
<p>普通索引则直接写入<code>change buffer</code>，然后就完成了，而change buffer则是在内存中，内存操作，少了磁盘操作。</p>
<p>整体来看，普通索引貌似比唯一索引更友好，唯一索引为了唯一性牺牲了插入和修改的性能。</p>
<h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>这个是一块内存中的空间，顾名思义，他就是为了修改而生的，如果你修改了数据，不需要直接更新磁盘，而是放入change buffer.change buffer满了，或者一定时间，或者当出现查询操作的时候，会merge数据，比如你更新了手机号，然后要查询这个用户的手机号。那么这时候内存中没有这个数据，从磁盘查询，磁盘查询到的是以前的手机号，因为数据没有更新到磁盘。这时候change buffer就会把更新数据合并到内存中的数据，使得查询到的是最新数据。</p>
<p>那么为什么唯一索引不适用change buffer，因为他需要判断唯一性。</p>
<p>但是向刚才举得例子，更新完立即查询，其实和唯一索引的更新没有啥区别了，反而因为change buffer还麻烦了。所以，change buffer更适合更新完不立即查询的场景。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务详解-4种事务隔离界别该怎么选择</title>
    <url>/mysql%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3-4%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%95%8C%E5%88%AB%E8%AF%A5%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9.html</url>
    <content><![CDATA[<h1 id="mysql事务详解-4种事务隔离级别该怎么选择"><a href="#mysql事务详解-4种事务隔离级别该怎么选择" class="headerlink" title="mysql事务详解-4种事务隔离级别该怎么选择"></a>mysql事务详解-4种事务隔离级别该怎么选择</h1><p>事务要保证ACID,其中就有隔离性。</p>
<p>当我们有多个事务在执行的时候，如果保证每个事务都是隔离的，而不是数据混乱的呢？sql标准的四种隔离级别如下：</p>
<ul>
<li>读未提交 RU(Read Uncommitted),在这个级别下，是所有数据共享的，A事务在执行的任何操作，B事务都能看见，不管有没有提交。</li>
<li>读已提交 RC(Read Committed),在这个级别下，只有A事务提交的数据，B事务才能看见。提交前的数据对其他事务是不可见的。</li>
<li>可重复读 RR(Repeatable Read),在这个级别下，一个事务内读取的数据都是重复的，也就是都是一致的，就算别的事务提交了数据，你读取的还是原来的数据。</li>
<li>串行化 (serializable)， 对于同一行记录，写会加写锁，读会加读锁。</li>
</ul>
<h2 id="事务隔离的原理"><a href="#事务隔离的原理" class="headerlink" title="事务隔离的原理"></a>事务隔离的原理</h2><p>这些是怎么做到的呢？因为事务是具备回滚功能的，如果一旦事务出错就会回滚整个事务。</p>
<p>用过github的应该都知道，github上的代码是具备回滚功能的，如果上线之后发现bug，会回滚到上一个版本，github就是基于版本控制的。</p>
<p>事务同样是基于版本控制的。有一个<code>undo log</code>回滚日志来记录这些版本。比如对于一行用户数据：</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456}</p>
</blockquote>
<p>事务1进行了修改手机号操作,这时候还没有提交。数据库就会有两个版本的数据。这些都记录在undo log里面，这也就是所谓的<code>MVCC</code>的概念。</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本</p>
</blockquote>
<p>事务2同时启动，但是稍后进行查询操作，获取用户信息，如果你是读未提交级别，那么读取的是事务1版本数据：</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本</p>
</blockquote>
<p>如果你是其他级别，那么你读取的是原始版本数据：</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本</p>
</blockquote>
<p>如果事务1已经提交了修改，那么事务2在读已提交级别下获取的也是事务1版本数据。</p>
<p>这个是怎么判断的呢？</p>
<p>每个事务有自己的事务id，这个id是单调递增的。在每行数据的版本上会记录事务id。在事务启动的时候，会维护一个已经启动但没有提交的事务的<code>有序数组</code>。有序也就是从小到大，排好序了。如果事务id小于这个数组中第一个id，那么这个事务一定是一个已经提交的事务。如果事务id大于这个数组，那么这个事务是在我之后启动的事务。如果事务id在这个数组中，那么他在我启动的时候一定是未提交的。</p>
<p>拿上面的数据举例，原始版本的事务id为100，事务1的事务id为101，事务2的事务id为102。</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本 100<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本 101</p>
</blockquote>
<p>当事务2启动后，事务数组为[101]，假设这时候事务1未提交。</p>
<p>如果是可重复读级别下，那么当查询到最新版本事务id=101,在数组中，那么不可见，接着查询上一个版本，上一个版本事务id = 100，发现小于数组最小值，那么这个值是正确的，取出这个版本的数据。</p>
<p>这样就算后面有事务提交，但是它提交后的版本的事务id不满足要求，那么查看到的数据永远都是同一个版本的数据，这也就是<code>一致性读</code>。</p>
<p>但是如果你在事务2中先更新了密码再执行查询，那么就会有三个版本的数据</p>
<blockquote>
<p>{id: 1, name: 张三, mobile:13245678976, pwd: 123456} 原始版本 100<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456} 事务1版本 101<br>{id: 1, name: 张三, mobile:12322223333, pwd: 123456789} 事务2版本 102</p>
</blockquote>
<p>这时候查询，事务数组为[101,102]。</p>
<p>再可重复读级别下，查询到最新数据事务id=102，发现和自己的一样，那么是可见的。因为是自己修改的，自己修改的不能不让自己看到啊，所以这时候查询到的数据会是最新数据。这也就是<code>当前读</code>。</p>
<p>可重复读级别和读已提交级别的区别如下：</p>
<ul>
<li>可重复读是再事务开始时候创建一致性视图，数组，这些东西，它只认事务启动前提交的数据。</li>
<li>读已提交级别则是每次执行sql语句的时候创建一致性视图，数组，这些东西，它认的是语句启动前提交的数据。</li>
</ul>
<p>这四个隔离级别，常用的就是读已提交和可重复读两个级别。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql事务怎么实现的，什么是两阶段提交</title>
    <url>/mysql%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.html</url>
    <content><![CDATA[<h1 id="mysql事务怎么实现的，什么是两阶段提交"><a href="#mysql事务怎么实现的，什么是两阶段提交" class="headerlink" title="mysql事务怎么实现的，什么是两阶段提交"></a>mysql事务怎么实现的，什么是两阶段提交</h1><p>我们都知道使用mysql的事务，准确来说是innoDB引擎的事务，可以保证数据的一致性，原子性等。那么为什么呢？</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>innoDB里面用到了一个叫做<code>redo log</code>（重做日志）的东西。</p>
<p>当你进行数据库操作的时候，innoDB并不会直接操作磁盘数据，因为这样很慢很慢。它使用了<code>wal</code>的机制，所有的操作先记录在redo log。等没事干了或者redo log满了再把数据刷到磁盘里面。这样的话他刷盘的时候就是顺序io，避免了使用随机io。redo log的大小我们可以通过参数设置。</p>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>在innoDB里面还有一个缓冲池，buffer_pool，这个缓冲池是在内存中的。为啥有缓冲池，因为磁盘的速度太慢了，如果每次都直接操作磁盘，那就完犊子了。就需要用到内存来缓冲一下，提升性能。</p>
<p>从innoDB里面读取数据的时候，实际上读取的是缓冲池，只有当缓冲池中没有记录的时候，才会读取磁盘，并且将记录放入缓冲池方便下次读取。</p>
<p>缓冲池的大小可以通过<code>innodb_buffer_pool_size</code>参数来指定。</p>
<p>缓存池中基本有以下组件：</p>
<ul>
<li>索引页</li>
<li>数据页</li>
<li>undo页</li>
<li>插入缓冲（insert buffer)</li>
<li>自适应哈希索引</li>
<li>锁信息</li>
<li>数据字典</li>
<li>redo log buffer</li>
</ul>
<p>缓冲池既然是在内存中，有固定大小，就会有淘汰机制，缓冲池使用的是LRU机制，也就是最近最少使用的会被淘汰掉。</p>
<p>这里面还有一个redo log buffer，这里面存储的就是上面说的redo log的信息了，会先写入这个buffer，然后再刷入redo log里面。有一个参数<code>innodb_log_buffer_size</code>来控制redo log buffer的大小。这个不用太大，因为一般每秒都会把这里面的刷新到redo log。</p>
<p>redo log buffer刷新到redo log的三种情况：</p>
<ul>
<li>每秒刷新</li>
<li>事务提交时候刷新</li>
<li>当redo log buffer剩余空间少于一半的时候刷新</li>
</ul>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log是innoDB引擎的日志，那mysql自己同样有日志，就是这个binlog日志。binlog 里面记载了mysql的所有变化，可以用来恢复数据库，创建备库，从库等。可以查看我的<a href="https://blog.csdn.net/Thepatterraining/article/details/105248917" target="_blank" rel="noopener">mysql读写分离</a>。</p>
<p>那为什么有两个日志呢，这是因为mysql最开始默认使用的是myisam引擎，myisam引擎没有redo log，mysql就有自己的binlog。innoDB引擎是后来加入mysql的。所以他们各自有各自的日志。</p>
<p>这两个日志有什么区别呢？</p>
<ol>
<li>rodo log是innoDB引擎的，binlog 是mysql的，binlog所有引擎都可以使用。</li>
<li>redo log记录的是“再某个数据页上修改了啥”，binlog记录的是你的sql。</li>
<li>redo log是固定大小，循环写入的，binlog没有大小限制，不断追加。</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>那一个事务怎么执行的呢，比如更新一个登录时间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> login_time = ? <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>走完了前面的连接器，分析器，优化器，执行器。执行器会去innoDB更新数据了。</li>
<li>他会先取出这条数据，取出id = 1的数据，id是主键索引，和数据在一起。innoDB直接查找主键索引树找到对应数据就返回了。当然，如果数据再缓冲池，那么直接返回了。</li>
<li>执行器拿到以后再修改登陆时间，然后再次调用innoDB引擎的接口。</li>
<li>innoDB把数据更新到内存中，同时更新redo log，把redo log标记成待提交状态。</li>
<li>执行器写入binlog。</li>
<li>执行器调用innoDB引擎的接口，innoDB把redo log标记成提交状态。</li>
</ul>
<p>这个时候整个更新事务完成。</p>
<p>为什么要这么做呢？</p>
<p>因为有两个日志的原因，所以两个日志都要写入，要保证这两个日志的一致性。那么如果不使用两阶段提交的方式，直接写入redo log然后写入binlog有什么问题呢？</p>
<p>假设，写完redo log，系统挂了。那么重启后innoDB引擎会根据redo log日志来恢复数据库。这时候数据库里面的数据是正确的。但是binlog丢失了啊。如果你有从库，那么从库的数据就错误了。因为从库的数据是通过binlog同步的。</p>
<p>如果把这两个步骤反过来呢，先写入binlog 再写入redo log呢？</p>
<p>那么就会redo log丢失，数据库实际上没有更新。但是从库通过binlog更新了。还是数据不一致。</p>
<p>所以需要<code>两阶段提交</code>来保证数据一致性。如果这时候写完redo log后挂掉了，因为redo log和binlog都没有数据，所以会回滚事务。<br>如果binlog和redo log都写入了，但是没有提交，那么重启后会提交事务。这样binlog和数据库就都有数据了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>一条mysql语句的奇幻之旅</title>
    <url>/%E4%B8%80%E6%9D%A1mysql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85.html</url>
    <content><![CDATA[<h1 id="一条mysql语句的奇幻之旅"><a href="#一条mysql语句的奇幻之旅" class="headerlink" title="一条mysql语句的奇幻之旅"></a>一条mysql语句的奇幻之旅</h1><p>我们平常都会用到mysql，但是你真的知道sql语句是怎么执行的吗？</p>
<p>比如下面的sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>

<p>这条sql语句大致会经过下面的阶段：</p>
<ol>
<li>连接器 – 连接器负责建立，管理mysql的连接，你首先要连接到mysql服务器，才能操作mysql。</li>
<li>分析器 – 分析器会进行词法分析和语法分析，语法错误会在这个阶段被返回。</li>
<li>优化器 – 优化器会自动优化我们的sql语句，如果它发现你的sql语句可以进行优化的话。优化器选择是否使用索引，索引怎么用。优化器还会选择更优的执行计划，最后会输出一个执行计划。</li>
<li>执行器 – 执行器会根据输出的执行计划进行最终的执行。他会调用底层存储引擎的接口，比如innoDB引擎。</li>
</ol>
<p>当我们最开始连接数据库实例的时候，我们要输入用户名密码，这时候连接器会从数据库的用户信息中判断你是否有<code>权限</code>连接数据库进行操作，有哪些权限。</p>
<p>如果你输入的用户名密码错误或者没有权限，那么你会收到下面的报错信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Access denied for user 'root'@'localhost'(using password: YES)</span><br></pre></td></tr></table></figure>

<p>这里我们要搞清楚一个概念，数据库和数据库实例，我们使用的都是数据库实例，用实例来操作数据库。</p>
<p>连接成功以后开始执行上面的查询语句。<code>分析器</code>会分析这个语句的词法，语法，语义这些信息。通俗来讲就是看到<code>select</code>,<code>update</code>这些关键字，知道你要来干啥，看看你是不是来搞破坏的，来捣蛋的。看看你是查询哪个表啊，有什么条件啊，这些玩意。最后会输出一个词法树。当然了这一步还会分析你的语法有没有错误，比如你把<code>select</code>打错试试。打成<code>elect</code>，会出现下面的报错信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax: <span class="keyword">check</span> the maual that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'elect * from users'</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>遇到这种<code>sql</code>语法错误，他会告诉你在哪出现了错误，其实就是分析器往后分析的时候发现，这不对啊，这不是我要的东西啊，你这偷梁换柱啊。</p>
<p>当这一步的考验你也通过了，那么骚年，你离飞升不远了。。。</p>
<p>进入优化器阶段，优化器接过语法树，会调整你的语法，比如他觉得你这么写它执行起来慢，执行的不爽，那么他会换个姿势再来一次。包括你的语法，执行的顺序，使用的索引，连表怎么连。最终优化完成会输出一个执行计划。</p>
<p>这个执行计划我们可以通过<code>explain</code>关键字查看，比如执行下面的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>

<p>他会输出下面的信息。我们可以看到<code>type</code>这一列是<code>all</code>。这代表全表扫描。</p>
<p><img src="../images/mysql01.png" alt="Image text"></p>
<p>我们现在在执行另外一个看看。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>看看这个执行结果。可以看到<code>type</code>这一列是<code>const</code>。这代表是常量。还有<code>key</code>这一列是<code>primary</code>，这代表我们这次使用了主键索引。而主键索引是聚簇索引，他的<code>page</code>页里面存储的就是这一行信息，所以只会查询一次。</p>
<p><img src="../images/mysql02.png" alt="Image text"></p>
<p>上面输出的执行计划会最终由执行器来执行，执行器会调用<code>存储引擎</code>层的接口。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>其实，在这中间还有一个缓存组件。最开始查询的时候会先查询缓存组件的信息，如果没有缓存，才会走到分析器，然后往下走。如果命中缓存，那么直接返回，也就没后面什么事情了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel-react实战打造企业级高并发分布式电商小程序（三）--权限管理的前端</title>
    <url>/laravel-react%E5%AE%9E%E6%88%98%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%9A%84%E5%89%8D%E7%AB%AF.html</url>
    <content><![CDATA[<h1 id="laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端"><a href="#laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端" class="headerlink" title="laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端"></a>laravel-react实战打造企业级高并发分布式电商小程序（三）–权限管理的前端</h1><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p>我们前端使用<code>react</code>来做，我们这个后台基于<code>antd pro</code>。使用<code>npm</code>创建它。</p>
<blockquote>
<p>npm create umi</p>
</blockquote>
<p>选择 <code>ant-design-pro</code></p>
<hr>
<p> Select the boilerplate type (Use arrow keys)<br>❯ ant-design-pro  - Create project with an layout-only ant-design-pro boilerplate, use together with umi block.<br>  app             - Create project with a simple boilerplate, support typescript.<br>  block           - Create a umi block.<br>  library         - Create a library with umi.<br>  plugin          - Create a umi plugin.</p>
<hr>
<p>Ant Design Pro 脚手架将会自动安装。</p>
<h5 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h5><blockquote>
<p>npm install<br>npm start</p>
</blockquote>
<p>启动完成后会自动打开浏览器访问 <a href="http://localhost:8000，你看到下面的页面就代表成功了。">http://localhost:8000，你看到下面的页面就代表成功了。</a></p>
<p><img src="../images/laravel-react07.png" alt="Image text"></p>
]]></content>
      <categories>
        <category>laravel+react实战打造企业级高并发分布式电商小程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>高并发</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode无法执行npm等脚本的问题</title>
    <url>/vscode%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8Cnpm%E7%AD%89%E8%84%9A%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="vscode无法执行npm等脚本的问题"><a href="#vscode无法执行npm等脚本的问题" class="headerlink" title="vscode无法执行npm等脚本的问题"></a>vscode无法执行npm等脚本的问题</h1><p>这是因为在windows系统上面powershell的执行策略问题。</p>
<p>可以运行下面的命令查看当前执行策略</p>
<blockquote>
<p>Get-ExecutionPolicy</p>
</blockquote>
<p>使用下面的命令更改执行策略</p>
<blockquote>
<p>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</p>
</blockquote>
<p><code>-scope</code>参数是 限制在当前用户下面更改 策略更改为<code>RemoteSigned</code>策略。</p>
<h5 id="RemoteSigned"><a href="#RemoteSigned" class="headerlink" title="RemoteSigned"></a>RemoteSigned</h5><ul>
<li>Windows服务器计算机的默认执行策略。</li>
<li>脚本可以运行。</li>
<li>需要从可信任的发布者处获得从互联网下载的脚本和配置文件的数字签名，其中包括电子邮件和即时消息传递程序。</li>
<li>不需要在本地计算机上编写且未从Internet下载的脚本上进行数字签名。</li>
<li>如果脚本不受阻碍（例如使用Unblock-Filecmdlet），则运行从Internet下载且未签名的脚本。</li>
<li>可能会运行来自Internet以外的其他来源的未签名脚本和可能有害的已签名脚本。</li>
</ul>
<h5 id="Restricted"><a href="#Restricted" class="headerlink" title="Restricted"></a>Restricted</h5><ul>
<li>Windows客户端计算机的默认执行策略。</li>
<li>允许使用单个命令，但不允许使用脚本。</li>
<li>阻止运行所有脚本文件，包括格式和配置文件（.ps1xml），模块脚本文件（.psm1）和PowerShell配置文件（.ps1）。</li>
</ul>
<h5 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h5><ul>
<li>当前范围中未设置执行策略。</li>
<li>如果所有作用域中的执行策略均为Undefined，则有效的执行策略为Restricted，这是默认的执行策略。</li>
</ul>
<h5 id="Unrestricted"><a href="#Unrestricted" class="headerlink" title="Unrestricted"></a>Unrestricted</h5><ul>
<li>非Windows计算机的默认执行策略，不能更改。</li>
<li>未签名的脚本可以运行。有运行恶意脚本的风险。</li>
<li>在运行非本地Intranet区域中的脚本和配置文件之前警告用户。</li>
</ul>
<p>更多问题可以参考<code>powershell</code>的官方文档</p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>javascript</tag>
        <tag>vscode</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel+react实战打造企业级高并发分布式电商小程序（一）--基础建设</title>
    <url>/laravel-react%E5%AE%9E%E6%88%98%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE.html</url>
    <content><![CDATA[<h1 id="laravel-react实战打造企业级高并发分布式电商小程序（一）"><a href="#laravel-react实战打造企业级高并发分布式电商小程序（一）" class="headerlink" title="laravel+react实战打造企业级高并发分布式电商小程序（一）"></a>laravel+react实战打造企业级高并发分布式电商小程序（一）</h1><p>整体使用laravel7+react打造整个电商小程序。里面会涉及到高并发的知识，mysql的分库分表，主从读写分离的配置，redis集群的使用，缓存系统的使用，队列系统的使用等。</p>
<p>先初始化一个laravel的项目。然后配置好<code>.env</code>文件。</p>
<h2 id="基础建设"><a href="#基础建设" class="headerlink" title="基础建设"></a>基础建设</h2><p>我们使用前后端分离就要考虑跨域问题和安全问题。跨域使用<code>cors</code>解决，laravel7里面内置了<code>cors</code>的解决方案，我们只要修改<code>config/cors.php</code>配置文件就好了。</p>
<p>把里面的值更改一下。修改这个值的原因是因为我们会使用jwt传一个token的请求头过来进行验证。这个时候还是报跨域的错误，所以将<code>supports_credentials</code>值修改为true，如果不报错就不需要修改了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'supports_credentials'</span> =&gt; <span class="keyword">true</span>,</span><br></pre></td></tr></table></figure>

<p>把这个参数的值修改为true。</p>
<p>安全问题使用<code>jwt</code>的解决方案，安装<code>jwt</code>的包。</p>
<blockquote>
<p>composer require lcobucci/jwt</p>
</blockquote>
<p>在routes/api.php路由文件中增加下面的路由</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//获取jwt token</span></span><br><span class="line">Route::post(<span class="string">'/require_token'</span>, <span class="string">'JWT\RequireTokenController@requireToken'</span>);</span><br></pre></td></tr></table></figure>

<p>在config下面新建<code>jwt.php</code>文件，里面内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'JWT_SECRET'</span> =&gt; env(<span class="string">'JWT_SECRET'</span>,<span class="string">'DvYUz+woS7vVJe6ldY+PqWoUbhIyY9rShzM0NAfzxdU='</span>),</span><br><span class="line">    <span class="string">'JWT_EXP_TIME'</span> =&gt; env(<span class="string">'JWT_EXP_TIME'</span>,<span class="string">'36000'</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>在<code>.env</code>中增加下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># jwt</span></span><br><span class="line">JWT_SECRET=DvYUz+woS7vVJe6ldY+PqWoUbhIyY9rShzM0NAfzxdU=   </span><br><span class="line">JWT_EXP_TIME=<span class="number">36000</span>  <span class="comment">//过期时间</span></span><br></pre></td></tr></table></figure>

<p>在<code>app/http/middleware</code>中创建中间件<code>jwtCheck.php</code>,内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Middleware</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Sys</span>\<span class="title">ErrorModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Closure</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Parser</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Signer</span>\<span class="title">Hmac</span>\<span class="title">Sha256</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jwtCheck</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle an incoming request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  \Illuminate\Http\Request  $request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  \Closure  $next</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        $parser = <span class="keyword">new</span> Parser;</span><br><span class="line">        $signer = <span class="keyword">new</span> Sha256;</span><br><span class="line">        $secret = config(<span class="string">'jwt.JWT_SECRET'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($request-&gt;hasHeader(<span class="string">'Authorization'</span>))&#123;</span><br><span class="line">            $token = $request-&gt;header(<span class="string">'Authorization'</span>);</span><br><span class="line">            <span class="comment">//解析token</span></span><br><span class="line">            $parse = $parser-&gt;parse($token);</span><br><span class="line">            <span class="comment">//验证token合法性</span></span><br><span class="line">            <span class="keyword">if</span> (!$parse-&gt;verify($signer, $secret)) &#123;</span><br><span class="line">                <span class="keyword">return</span> response()-&gt;json([<span class="string">'code'</span>=&gt;ErrorModel::JWT_ERROR, <span class="string">'msg'</span>=&gt;<span class="string">'令牌错误！'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//验证是否已经过期</span></span><br><span class="line">            <span class="keyword">if</span> ($parse-&gt;isExpired()) &#123;</span><br><span class="line">                <span class="keyword">return</span> response()-&gt;json([<span class="string">'code'</span>=&gt;ErrorModel::JWT_ERROR, <span class="string">'msg'</span>=&gt;<span class="string">'令牌过期！'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> response()-&gt;json([<span class="string">'code'</span>=&gt;ErrorModel::JWT_ERROR, <span class="string">'msg'</span>=&gt;<span class="string">'令牌缺失！'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把token放到参数里面</span></span><br><span class="line">        request()-&gt;offsetSet(<span class="string">'token'</span>, $token);</span><br><span class="line">        <span class="keyword">return</span> $next($request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>app/http</code>下面的<code>Kernel.php</code>文件里面的<code>$routeMiddleware</code>变量里面增加下面内容，把中间件注册到系统中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'jwtCheck'</span> =&gt; \App\Http\Middleware\jwtCheck::class,</span><br></pre></td></tr></table></figure>

<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>创建控制器</p>
<p>在<code>app/http/controller</code>下面创建<code>jwt</code>文件夹，然后在<code>jwt</code>文件夹里面创建<code>RequireTokenController.php</code>文件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">JWT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Builder</span>;</span><br><span class="line"><span class="keyword">use</span> \<span class="title">Lcobucci</span>\<span class="title">JWT</span>\<span class="title">Signer</span>\<span class="title">Hmac</span>\<span class="title">Sha256</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequireTokenController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">requireToken</span><span class="params">(Builder $builder, Sha256 $signer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        $secret = config(<span class="string">'jwt.JWT_SECRET'</span>);</span><br><span class="line">        $time = time();</span><br><span class="line">        $expTime = config(<span class="string">'jwt.JWT_EXP_TIME'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//设置header和payload，以下的字段都可以自定义</span></span><br><span class="line">            $builder-&gt;setIssuer(<span class="string">"cmp.wliot.com"</span>) <span class="comment">//发布者</span></span><br><span class="line">                    -&gt;setAudience(<span class="string">"cmp.wliot.com"</span>) <span class="comment">//接收者</span></span><br><span class="line">                    -&gt;setId(<span class="string">"abc"</span>, <span class="keyword">true</span>) <span class="comment">//对当前token设置的标识</span></span><br><span class="line">                    -&gt;setIssuedAt($time) <span class="comment">//token创建时间</span></span><br><span class="line">                    -&gt;setExpiration($time + $expTime) <span class="comment">//过期时间</span></span><br><span class="line">                    <span class="comment">// -&gt;setNotBefore($time + 5) //当前时间在这个时间前，token不能使用</span></span><br><span class="line">                    -&gt;set(<span class="string">'uid'</span>, <span class="number">30061</span>); <span class="comment">//自定义数据</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置签名</span></span><br><span class="line">            $builder-&gt;sign($signer, $secret);</span><br><span class="line">            <span class="comment">//获取加密后的token，转为字符串</span></span><br><span class="line">            $token = (string)$builder-&gt;getToken();</span><br><span class="line">        &#125; <span class="keyword">while</span> (Redis::exists($token));</span><br><span class="line">        <span class="comment">//存入redis</span></span><br><span class="line">        <span class="comment">// Redis::setex($token, $expTime, json_encode([]));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success($token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里面使用到了<code>$this-&gt;success()</code>方法，这个方法来自controller类，我们需要编写这个方法。</p>
<p>在<code>app/http</code>下面创建<code>Utils</code>文件夹，在里面创建<code>Success.php</code>文件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Utils</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Sys</span>\<span class="title">ErrorModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> Success &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">success</span><span class="params">($data = [])</span> </span>&#123;</span><br><span class="line">        $res = [<span class="string">'code'</span>=&gt;<span class="string">'0'</span>,<span class="string">'msg'</span>=&gt;<span class="string">'请求成功！'</span>, <span class="string">'data'</span>=&gt;$data];</span><br><span class="line">        <span class="keyword">return</span> response()-&gt;json($res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>app/http/controllers/controller.php</code>文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Utils</span>\<span class="title">Success</span>;  <span class="comment">//引入刚才的文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">AuthorizesRequests</span>, <span class="title">DispatchesJobs</span>, <span class="title">ValidatesRequests</span>, <span class="title">Success</span>;  <span class="comment">//在这里添加Success 也就是刚才的文件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这里面使用到了redis，所以我们需要启动你本地的redis服务器。启动之后就可以访问我们上面填写的路由了，使用postman访问你的路由。</p>
<p><img src="../images/laravel-react01.png" alt="Image text"></p>
<p>可以看到返回了正确的token。</p>
<p>在后面的访问请求中我们需要使用这个token。我们把它加入请求头。在请求头新建一个<code>Authorization</code>的key，他的值就是我们的token。</p>
]]></content>
      <categories>
        <category>laravel+react实战打造企业级高并发分布式电商小程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>高并发</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel+react实战打造企业级高并发分布式电商小程序（二）--权限管理</title>
    <url>/laravel-react%E5%AE%9E%E6%88%98%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%94%B5%E5%95%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<h1 id="laravel-react实战打造企业级高并发分布式电商小程序（二）"><a href="#laravel-react实战打造企业级高并发分布式电商小程序（二）" class="headerlink" title="laravel+react实战打造企业级高并发分布式电商小程序（二）"></a>laravel+react实战打造企业级高并发分布式电商小程序（二）</h1><p>整体使用laravel7+react打造整个电商小程序。里面会涉及到高并发的知识，mysql的分库分表，主从读写分离的配置，redis集群的使用，缓存系统的使用，队列系统的使用等。</p>
<p>先初始化一个laravel的项目。然后配置好<code>.env</code>文件。</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>既然是电商肯定有后台，要做权限管理这块。</p>
<p>先创建表，这里使用<code>laravel</code>的<code>migration</code>。下面是后台用户表。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUsersTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::create(<span class="string">'auth_users'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">            $table-&gt;bigIncrements(<span class="string">'id'</span>);</span><br><span class="line">            $table-&gt;string(<span class="string">'name'</span>, <span class="number">100</span>)-&gt;unique();</span><br><span class="line">            $table-&gt;string(<span class="string">'email'</span>, <span class="number">100</span>)-&gt;unique();</span><br><span class="line">            $table-&gt;timestamp(<span class="string">'email_verified_at'</span>)-&gt;nullable();</span><br><span class="line">            $table-&gt;string(<span class="string">'password'</span>);</span><br><span class="line">            $table-&gt;rememberToken();</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::dropIfExists(<span class="string">'auth_users'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是角色表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateRolesTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::create(<span class="string">'auth_roles'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">            $table-&gt;bigIncrements(<span class="string">'id'</span>);</span><br><span class="line">            $table-&gt;string(<span class="string">'name'</span>, <span class="number">100</span>)-&gt;unique();</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::dropIfExists(<span class="string">'auth_roles'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是权限表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreatePermissionsTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::create(<span class="string">'auth_permissions'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">            $table-&gt;bigIncrements(<span class="string">'id'</span>);</span><br><span class="line">            $table-&gt;string(<span class="string">'name'</span>,<span class="number">100</span>)-&gt;unique();</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::dropIfExists(<span class="string">'auth_permissions'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是用户角色关联表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUserRolesTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::create(<span class="string">'auth_user_roles'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">            $table-&gt;bigIncrements(<span class="string">'id'</span>);</span><br><span class="line">            $table-&gt;bigInteger(<span class="string">'user_id'</span>);</span><br><span class="line">            $table-&gt;bigInteger(<span class="string">'role_id'</span>);</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::dropIfExists(<span class="string">'auth_user_roles'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是角色和权限关联表</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateRolePerimissionsTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::create(<span class="string">'auth_role_permissions'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">            $table-&gt;bigIncrements(<span class="string">'id'</span>);</span><br><span class="line">            $table-&gt;bigInteger(<span class="string">'user_id'</span>)-&gt;default(<span class="number">0</span>);</span><br><span class="line">            $table-&gt;bigInteger(<span class="string">'role_id'</span>);</span><br><span class="line">            $table-&gt;bigInteger(<span class="string">'perimission_id'</span>);</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::dropIfExists(<span class="string">'auth_role_permissions'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这张是系统错误信息表，这里会返回错误信息，这些错误信息全部存放在这张表里。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Migrations</span>\<span class="title">Migration</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Schema</span>\<span class="title">Blueprint</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Schema</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateSysErrorsTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::create(<span class="string">'sys_errors'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Blueprint $table)</span> </span>&#123;</span><br><span class="line">            $table-&gt;bigIncrements(<span class="string">'id'</span>);</span><br><span class="line">            $table-&gt;string(<span class="string">'code'</span>,<span class="number">100</span>)-&gt;unique()-&gt;comment(<span class="string">'错误编码'</span>);</span><br><span class="line">            $table-&gt;string(<span class="string">'msg'</span>)-&gt;comment(<span class="string">'错误信息'</span>);</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Schema::dropIfExists(<span class="string">'sys_errors'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完这些执行迁移命令就可以了。</p>
<blockquote>
<p>php artisan migrate</p>
</blockquote>
<p>当然了，在这之前确保你的<code>.env</code>文件已经配置好了数据库连接。</p>
<p>我们有了后台数据还需要一个管理员账户，使用<code>seed</code>填充。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">UserModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Seeder</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Hash</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersTableSeeder</span> <span class="keyword">extends</span> <span class="title">Seeder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the database seeds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">(UserModel $user)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $user-&gt;name = <span class="string">'admin'</span>;</span><br><span class="line">        $user-&gt;email = <span class="string">'admin@admin.com'</span>;</span><br><span class="line">        $user-&gt;password = Hash::make(<span class="string">'123456'</span>);</span><br><span class="line">        $user-&gt;save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行填充命令</p>
<blockquote>
<p>php artisan db:seed</p>
</blockquote>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>这里我们使用一个<code>laravel</code>的扩展包，使用composer安装他</p>
<blockquote>
<p>composer require thepatter/query-common</p>
</blockquote>
<p>安装完后查看我的这个文章来使用这个包，根据文章里面做完之后再回来看下面的内容。</p>
<blockquote>
<p><a href="https://blog.csdn.net/Thepatterraining/article/details/105408363" target="_blank" rel="noopener">https://blog.csdn.net/Thepatterraining/article/details/105408363</a></p>
</blockquote>
<p>接下来使用<code>artisan</code>命令创建我们的控制器。</p>
<blockquote>
<p>php artisan make:queryController Auth/UserController</p>
</blockquote>
<p>创建完之后在创建model</p>
<blockquote>
<p>php artisan make:model Models/Auth/UserModel</p>
</blockquote>
<p>修改刚才的<code>Auth/UserModel</code>，在里面增加<code>table</code>属性。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">protected</span> $table = <span class="string">'auth_users'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改刚才的<code>Auth/UserController</code>控制器。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">QueryCommon</span>\<span class="title">QueryController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">UserModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">UserRoleModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">QueryController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典数组</span></span><br><span class="line"><span class="comment">     * ['表里的字段名' =&gt; '字典code',...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $dicArr = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * ['搜索字段' =&gt; '表字段',...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $filedsAdapter = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时候的字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * ['输入字段' =&gt; '表字段']</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $createAdapter = [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'name'</span>,</span><br><span class="line">        <span class="string">'email'</span> =&gt; <span class="string">'email'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义表名 格式: table as t</span></span><br><span class="line">    <span class="keyword">protected</span> $shortTableName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;model = <span class="keyword">new</span> UserModel;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们对用户的增删改查操作就完成了，是不是超级简单呢。这主要依赖于我们的<code>query-common</code>扩展包。</p>
<p>我们接下来只需要添加对应的路由就可以了。在<code>routes</code>下面创建<code>Api/Auth</code>文件夹。在里面创建<code>index.php</code>路由文件。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Route</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Route::prefix(<span class="string">'auth'</span>)-&gt;namespace(<span class="string">'Auth'</span>)-&gt;group(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//后台创建用户</span></span><br><span class="line">    Route::post(<span class="string">'user'</span>, <span class="string">'UserController@createInfo'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台查询管理员列表</span></span><br><span class="line">    Route::get(<span class="string">'users'</span>, <span class="string">'UserController@queryList'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台更新管理员信息</span></span><br><span class="line">    Route::put(<span class="string">'user/&#123;id&#125;'</span>, <span class="string">'UserController@updateInfo'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台删除管理员</span></span><br><span class="line">    Route::delete(<span class="string">'user/&#123;id&#125;'</span>, <span class="string">'UserController@deleteInfo'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>添加完路由文件后我们需要自动加载路由文件，请看我的这篇文章，路由自动加载。</p>
<blockquote>
<p><a href="https://blog.csdn.net/Thepatterraining/article/details/105386868" target="_blank" rel="noopener">https://blog.csdn.net/Thepatterraining/article/details/105386868</a></p>
</blockquote>
<p>接下来可以使用<code>postman</code>来测试了。</p>
<p>获取用户列表</p>
<p><img src="../images/laravel-react02.png" alt="Image text"></p>
<p>其他的就不放图了。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>有了用户就有角色了，我们的角色表在之前已经创建好了，我们现在同样的方法创建controller和model。</p>
<p>执行下面的命令。<code>-m</code>参数是model，这里指定model后，如果model不存在会自动创建。</p>
<blockquote>
<p>php artisan make:queryController Auth/RoleController -m Models/Auth/RoleModel</p>
</blockquote>
<p>修改刚才的<code>Auth/RoleModel</code>，在里面增加<code>table</code>属性。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">protected</span> $table = <span class="string">'auth_roles'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>app/Http/Controllers/Auth/RoleController</code>文件内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">QueryCommon</span>\<span class="title">QueryController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>\<span class="title">RoleModel</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleController</span> <span class="keyword">extends</span> <span class="title">QueryController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典数组</span></span><br><span class="line"><span class="comment">     * ['表里的字段名' =&gt; '字典code',...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $dicArr = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * ['搜索字段' =&gt; '表字段',...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $filedsAdapter = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时候的字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * ['输入字段' =&gt; '表字段']</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $createAdapter = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义表名 格式: table as t</span></span><br><span class="line">    <span class="keyword">protected</span> $shortTableName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;model = <span class="keyword">new</span> RoleModel();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在刚才的<code>routes/Api/Auth/index</code>路由文件中增加下面的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//后台查询角色列表</span></span><br><span class="line">    Route::get(<span class="string">'roles'</span>, <span class="string">'RoleController@queryList'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建角色</span></span><br><span class="line">    Route::post(<span class="string">'role'</span>, <span class="string">'RoleController@createInfo'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新角色</span></span><br><span class="line">    Route::put(<span class="string">'role/&#123;id&#125;'</span>, <span class="string">'RoleController@updateInfo'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除角色</span></span><br><span class="line">    Route::delete(<span class="string">'role/&#123;id&#125;'</span>, <span class="string">'RoleController@deleteInfo'</span>);</span><br></pre></td></tr></table></figure>

<p>增加后是下图这样</p>
<p><img src="../images/laravel-react03.png" alt="Image text"></p>
<p>同样使用postman测试。</p>
<p><img src="../images/laravel-react04.png" alt="Image text"></p>
<h4 id="用户和角色关联"><a href="#用户和角色关联" class="headerlink" title="用户和角色关联"></a>用户和角色关联</h4><p>有了用户和角色就要把这两个关联起来了，我们通过在创建用户和修改用户的时候关联角色，在这时候就要更改之前的<code>Auth/UserController</code>了。</p>
<p>增加下面的函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建完用户后执行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createAfter</span><span class="params">($id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;userRole($id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新完主表之后可以进行的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">updateAfter</span><span class="params">($id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//更新完用户信息需要更新用户角色关联</span></span><br><span class="line">    <span class="comment">//先删除所有关联，再重新创建</span></span><br><span class="line">    UserRoleModel::where(<span class="string">'user_id'</span>, $id)-&gt;delete();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;userRole($id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户角色操作，先删除用户的所有角色，再创建角色关联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $id 用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">userRole</span><span class="params">($id)</span> </span>&#123;</span><br><span class="line">    $ids = <span class="keyword">$this</span>-&gt;request-&gt;input(<span class="string">'roleIds'</span>);</span><br><span class="line">    <span class="comment">//组织数据</span></span><br><span class="line">    $insertDatas = [];</span><br><span class="line">    <span class="keyword">foreach</span> ($ids <span class="keyword">as</span> $roleId) &#123;</span><br><span class="line">        $insertData = [];</span><br><span class="line">        $insertData[<span class="string">'user_id'</span>] = $id;</span><br><span class="line">        $insertData[<span class="string">'role_id'</span>] = $roleId;</span><br><span class="line">        $insertData[<span class="string">'created_at'</span>] = date(<span class="string">'Y-m-d H:i:s'</span>);</span><br><span class="line">        $insertDatas[] = $insertData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一次性插入</span></span><br><span class="line">    UserRoleModel::insert($insertDatas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createAfter</code>方法是在创建完用户后执行的，<code>updateAfter</code>方法是更新完用户信息后执行的。传入用户id。我们在这里删除之前的用户和角色关联，把新的循环添加到数组中，一次性插入数据库。因为循环插入会进行多次<code>数据库io</code>操作，而数据库io是比较耗费资源和时间的，所以我们尽可能少进行数据库操作。</p>
<p>在创建和更新时候我们还需要验证参数，我们再添加下面的方法。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在创建之前调用，用来验证参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">createBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测页码和每页数量</span></span><br><span class="line">    $rules = [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'required|unique:auth_users,name'</span>,</span><br><span class="line">        <span class="string">'email'</span> =&gt; <span class="string">'required|email|unique:auth_users,email'</span>,</span><br><span class="line">        <span class="string">'password'</span> =&gt; <span class="string">'required'</span>,</span><br><span class="line">        <span class="string">'roleIds'</span> =&gt; <span class="string">'required|array'</span>,</span><br><span class="line">    ];</span><br><span class="line">    $messages = [</span><br><span class="line">        <span class="string">'name.required'</span> =&gt; <span class="string">'用户名为必填项'</span>,</span><br><span class="line">        <span class="string">'name.unique'</span> =&gt; <span class="string">'用户已经存在'</span>,</span><br><span class="line">        <span class="string">'email.required'</span> =&gt; <span class="string">'邮箱为必填项'</span>,</span><br><span class="line">        <span class="string">'email.unique'</span> =&gt; <span class="string">'邮箱已经存在'</span>,</span><br><span class="line">        <span class="string">'email.email'</span> =&gt; <span class="string">'请输入正确的邮箱格式'</span>,</span><br><span class="line">        <span class="string">'password.required'</span> =&gt; <span class="string">'密码为必填项'</span>,</span><br><span class="line">        <span class="string">'roleIds.required'</span> =&gt; <span class="string">'角色为必填项'</span>,</span><br><span class="line">        <span class="string">'roleIds.array'</span> =&gt; <span class="string">'角色必须是数组类型'</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">$this</span>-&gt;valid($rules, $messages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断角色数组是不是在数据库都存在</span></span><br><span class="line">    $roleNum = RoleModel::whereIn(<span class="string">'id'</span>, <span class="keyword">$this</span>-&gt;request-&gt;roleIds)-&gt;count();</span><br><span class="line">    <span class="keyword">if</span> ($roleNum != count(<span class="keyword">$this</span>-&gt;request-&gt;roleIds)) &#123;</span><br><span class="line">        <span class="comment">//角色id不对</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CommonException(ErrorModel::ROLE_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在创建之前调用，用来验证参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">updateBefore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测页码和每页数量</span></span><br><span class="line">    $rules = [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'required'</span>,</span><br><span class="line">        <span class="string">'email'</span> =&gt; <span class="string">'required|email'</span>,</span><br><span class="line">        <span class="string">'roleIds'</span> =&gt; <span class="string">'required|array'</span>,</span><br><span class="line">    ];</span><br><span class="line">    $messages = [</span><br><span class="line">        <span class="string">'name.required'</span> =&gt; <span class="string">'用户名为必填项'</span>,</span><br><span class="line">        <span class="string">'email.required'</span> =&gt; <span class="string">'邮箱为必填项'</span>,</span><br><span class="line">        <span class="string">'email.email'</span> =&gt; <span class="string">'请输入正确的邮箱格式'</span>,</span><br><span class="line">        <span class="string">'roleIds.required'</span> =&gt; <span class="string">'角色为必填项'</span>,</span><br><span class="line">        <span class="string">'roleIds.array'</span> =&gt; <span class="string">'角色必须是数组类型'</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">$this</span>-&gt;valid($rules, $messages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断角色数组是不是在数据库都存在</span></span><br><span class="line">    $roleNum = RoleModel::whereIn(<span class="string">'id'</span>, <span class="keyword">$this</span>-&gt;request-&gt;roleIds)-&gt;count();</span><br><span class="line">    <span class="keyword">if</span> ($roleNum != count(<span class="keyword">$this</span>-&gt;request-&gt;roleIds)) &#123;</span><br><span class="line">        <span class="comment">//角色id不对</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CommonException(ErrorModel::ROLE_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createBefore</code>方法在创建用户之前调用，<code>updateBefore</code>方法在更新之前调用，用来验证参数信息。验证角色在数据库中不存在后要返回错误，直接throw抛出异常即可，因为在外部已经用<code>try catch</code>捕获了，这里返回的是一个<code>error code</code>，在<code>Sys/ErrorModel</code>中定义一个错误信息。为了方便管理，所有的错误以常量的方式定义在errorModel里面。真正的错误信息在我们一开始创建的<code>sys_error</code>数据表中。我们在数据表中添加一条错误信息，<code>code</code>是100002的，<code>msg</code>是角色未定义！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> ROLE_NOT_FOUND = <span class="string">'100002'</span>; <span class="comment">//角色未定义！</span></span><br></pre></td></tr></table></figure>

<p>我们可以传一些错误的角色id给到接口中，使用postman来测试一下。因为这个用户已经创建了，所以返回了用户已经存在的错误信息。</p>
<p><img src="../images/laravel-react05.png" alt="Image text"></p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>我们使用同样的方式创建权限的<code>controller</code>和<code>model</code>。</p>
<blockquote>
<p>php artisan make:queryController Auth/PermissionController -m Models/Auth/PermissionModel</p>
</blockquote>
<p>和上面一样，修改刚才的<code>Auth/PermissionModel</code>，在里面增加<code>table</code>属性。后面的就不再说这里了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermissionModel</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">protected</span> $table = <span class="string">'auth_permissions'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加路由。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//后台查询权限列表</span></span><br><span class="line">Route::get(<span class="string">'permissions'</span>, <span class="string">'PermissionController@queryList'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建权限</span></span><br><span class="line">Route::post(<span class="string">'permission'</span>, <span class="string">'PermissionController@createInfo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新权限</span></span><br><span class="line">Route::put(<span class="string">'permission/&#123;id&#125;'</span>, <span class="string">'PermissionController@updateInfo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除权限</span></span><br><span class="line">Route::delete(<span class="string">'permission/&#123;id&#125;'</span>, <span class="string">'PermissionController@deleteInfo'</span>);</span><br></pre></td></tr></table></figure>

<p>使用postman测试。</p>
<p><img src="../images/laravel-react06.png" alt="Image text"></p>
<p>现在呢，我们权限管理的后端接口就算做完了，当然了，后面还会根据需要调整。</p>
]]></content>
      <categories>
        <category>laravel+react实战打造企业级高并发分布式电商小程序</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>javascript</tag>
        <tag>react</tag>
        <tag>高并发</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>带你解密laravel数据库动静态混合调用的秘密</title>
    <url>/%E5%B8%A6%E4%BD%A0%E8%A7%A3%E5%AF%86laravel%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A8%E9%9D%99%E6%80%81%E6%B7%B7%E5%90%88%E8%B0%83%E7%94%A8%E7%9A%84%E7%A7%98%E5%AF%86.html</url>
    <content><![CDATA[<h1 id="laravel-orm"><a href="#laravel-orm" class="headerlink" title="laravel orm"></a>laravel orm</h1><p>laravel 使用 orm 调用数据库查询的时候很方便，我们只需要配置完数据库连接后创建model。</p>
<p>比如我们查询用户，我们首先要有一个<code>user model</code>。</p>
<p>可以使用 <code>artisan</code>创建</p>
<blockquote>
<p>php artisan make:model userModel</p>
</blockquote>
<p>如果我们需要查询一个用户信息，只需要这样</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">userModel::where(<span class="string">'id'</span>, <span class="number">1</span>)-&gt;first();</span><br><span class="line">(<span class="keyword">new</span> userModel)-&gt;where(<span class="string">'id'</span>, <span class="number">1</span>)-&gt;first();</span><br></pre></td></tr></table></figure>

<p>上面的两种方法都可以实现查询用户id为1的用户信息。那他们有什么区别呢？第一种方法更为优雅。</p>
<p>那这个是怎么实现的呢，一般我们要么定义一个静态方法用来静态调用，要么定义一个对象方法需要使用对象调用。</p>
<p>其实很简单，他只是用到了<code>php</code>的<code>魔术方法</code>。</p>
<p>来看一下下面两个魔术方法：</p>
<ul>
<li>__call()</li>
<li>__callStatic()</li>
</ul>
<p>看一下php文档中的介绍</p>
<h3 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h3><p>在对象中调用一个不可访问方法时，__call() 会被调用。</p>
<blockquote>
<p>public __call ( string $name , array $arguments ) : mixed</p>
</blockquote>
<h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h3><p>在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。</p>
<blockquote>
<p>public static __callStatic ( string $name , array $arguments ) : mixed</p>
</blockquote>
<p>$name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。</p>
<p>我们要让一个对象方法可以静态调用就要通过<code>__callStatic()</code>魔术方法了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">__callStatic</span><span class="params">( string $name , array $arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="keyword">static</span>)-&gt;$name(...$arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话当我们调用<code>userModel::where()</code>的时候实际上它内部会创建一个对象然后再对象调用<code>where</code>。</p>
<p>但是这样会产生一个问题，如果当我们调用的方法不存在的时候怎么办呢。</p>
<p>可以通过<code>try catch</code>来捕获错误进行错误处理。laravel内部就是这么实现的。在laravel的model文件下，是这么运用<code>__call()</code>的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handle dynamic method calls into the model.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  array  $parameters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method, $parameters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_array($method, [<span class="string">'increment'</span>, <span class="string">'decrement'</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$method(...$parameters);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;forwardCallTo(<span class="keyword">$this</span>-&gt;newQuery(), $method, $parameters);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他里面调用了<code>forwardCallTo</code>方法，我们来看一下这个方法。</p>
<p>这个方法存在<code>ForwardsCalls</code>这个<code>trait</code>中。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Forward a method call to the given object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  mixed  $object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  array  $parameters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \BadMethodCallException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">forwardCallTo</span><span class="params">($object, $method, $parameters)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> $object-&gt;&#123;$method&#125;(...$parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error | BadMethodCallException $e) &#123;</span><br><span class="line">            $pattern = <span class="string">'~^Call to undefined method (?P&lt;class&gt;[^:]+)::(?P&lt;method&gt;[^\(]+)\(\)$~'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!preg_match($pattern, $e-&gt;getMessage(), $matches)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> $e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($matches[<span class="string">'class'</span>] != get_class($object) ||</span><br><span class="line">                $matches[<span class="string">'method'</span>] != $method) &#123;</span><br><span class="line">                <span class="keyword">throw</span> $e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">static</span>::throwBadMethodCallException($method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>他在调用的时候通过try catch来捕获错误。</p>
<p>还有另外一种方法同样可以判断这个类有没有这个方法，那就是先通过<code>get_class_methods($className)</code>这个函数获取到类的所有方法，然后我们就可以自己判断了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($method, $parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $classFuns = get_class_methods(<span class="keyword">$this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!in_array($method, $classFuns)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"没有这个方法"</span>; <span class="comment">//返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$method(...$parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也不失为一种方法啊，大家还有其他好方法的话欢迎交流。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel神器教你一秒搞定增删改查业务模块</title>
    <url>/laravel%E7%A5%9E%E5%99%A8%E6%95%99%E4%BD%A0%E4%B8%80%E7%A7%92%E6%90%9E%E5%AE%9A%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97.html</url>
    <content><![CDATA[<h1 id="laravel神器教你一秒搞定增删改查业务模块"><a href="#laravel神器教你一秒搞定增删改查业务模块" class="headerlink" title="laravel神器教你一秒搞定增删改查业务模块"></a>laravel神器教你一秒搞定增删改查业务模块</h1><p>还在为了不断写增删改查而烦恼不堪嘛？还在为了重复写代码而头疼嘛？这个laravel神器拯救你的大脑，解放你的双手。让你有更多的时间去写出更好的代码。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先使用composer安装</p>
<blockquote>
<p>composer require thepatter/query-common</p>
</blockquote>
<p>安装之后创建一个command</p>
<blockquote>
<p>php artisan make:command MakeQueryCommand</p>
</blockquote>
<a id="more"></a>

<p>把下面的内容复制粘贴进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Console</span>\<span class="title">Commands</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Str</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">InvalidArgumentException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Console</span>\<span class="title">GeneratorCommand</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">Console</span>\<span class="title">Input</span>\<span class="title">InputOption</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeQueryCommand</span> <span class="keyword">extends</span> <span class="title">GeneratorCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The console command name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $name = <span class="string">'make:queryController'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The console command description.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $description = <span class="string">'Create a new queryController class'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type of class being generated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $type = <span class="string">'QueryController'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the stub file for the generator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getStub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resource_path(<span class="string">'stubs/queryController.stub'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the default namespace for the class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $rootNamespace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefaultNamespace</span><span class="params">($rootNamespace)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $rootNamespace.<span class="string">'\Http\Controllers'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the class with the given name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Remove the base controller import if we are already in base namespace.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildClass</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $controllerNamespace = <span class="keyword">$this</span>-&gt;getNamespace($name);</span><br><span class="line"></span><br><span class="line">        $replace = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;option(<span class="string">'model'</span>)) &#123;</span><br><span class="line">            $replace = <span class="keyword">$this</span>-&gt;buildModelReplacements($replace);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $replace[<span class="string">"use &#123;$controllerNamespace&#125;\Controller;\n"</span>] = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str_replace(</span><br><span class="line">            array_keys($replace), array_values($replace), <span class="keyword">parent</span>::buildClass($name)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build the model replacement values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  array  $replace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildModelReplacements</span><span class="params">(array $replace)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $modelClass = <span class="keyword">$this</span>-&gt;parseModel(<span class="keyword">$this</span>-&gt;option(<span class="string">'model'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! class_exists($modelClass)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;confirm(<span class="string">"A &#123;$modelClass&#125; model does not exist. Do you want to generate it?"</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;call(<span class="string">'make:model'</span>, [<span class="string">'name'</span> =&gt; $modelClass]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array_merge($replace, [</span><br><span class="line">            <span class="string">'DummyFullModelClass'</span> =&gt; $modelClass,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the fully-qualified model class name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string  $model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseModel</span><span class="params">($model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// if (preg_match('([^A-Za-z0-9_/\\\\])', $model)) &#123;</span></span><br><span class="line">        <span class="comment">//     throw new InvalidArgumentException('Model name contains invalid characters.');</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        $model = trim(str_replace(<span class="string">'/'</span>, <span class="string">'\\'</span>, $model), <span class="string">'\\'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! Str::startsWith($model, $rootNamespace = <span class="keyword">$this</span>-&gt;laravel-&gt;getNamespace())) &#123;</span><br><span class="line">            $model = $rootNamespace.$model;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the console command options.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getOptions</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            [<span class="string">'model'</span>, <span class="string">'m'</span>, InputOption::VALUE_OPTIONAL, <span class="string">'Generate a query controller for the given model.'</span>],</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resources文件夹下创建stubs文件夹，在stubs文件夹下面创建QueryController.stub文件，把下面内容复制粘贴进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DummyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">DummyRootNamespaceHttp</span>\<span class="title">Controllers</span>\<span class="title">QueryList</span>\<span class="title">QueryController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Exceptions</span>\<span class="title">CommonException</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> <span class="keyword">extends</span> <span class="title">QueryController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字典数组</span></span><br><span class="line"><span class="comment">     * ['表里的字段名' =&gt; '字典code',...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $dicArr = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * ['搜索字段' =&gt; '表字段',...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $filedsAdapter = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时候的字段映射 可选，不填默认转成下划线格式</span></span><br><span class="line"><span class="comment">     * ['输入字段' =&gt; '表字段']</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $createAdapter = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义表名 格式: table as t</span></span><br><span class="line">    <span class="keyword">protected</span> $shortTableName;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="string">"DummyFullModelClass"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> get.api/lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getList</span><span class="params">(Request $request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//检查页码，搜索条件等</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;pageValid();</span><br><span class="line">            <span class="comment">//返回数据</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success(<span class="keyword">$this</span>-&gt;pageList());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> post.api/info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createInfo</span><span class="params">(Request $request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;create($request-&gt;all());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> put.api/info/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span><span class="params">(Request $request, $id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//查询记录</span></span><br><span class="line">            $detail = <span class="keyword">$this</span>-&gt;getModel()-&gt;find($id);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>($detail)) &#123;</span><br><span class="line">                <span class="comment">//补充错误信息</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CommonException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;update($id,$request-&gt;all());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询一条记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> get.api/info</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">detail</span><span class="params">(Request $request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            $rules = [</span><br><span class="line">                <span class="string">'id'</span>=&gt;<span class="string">'required'</span>,</span><br><span class="line">            ];</span><br><span class="line">            $messages = [</span><br><span class="line">                <span class="string">'id.required'</span>=&gt;<span class="string">'id为必填项'</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="comment">//验证</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;valid($request, $rule, $messages);</span><br><span class="line">            <span class="comment">//查询记录</span></span><br><span class="line">            $detail = <span class="keyword">$this</span>-&gt;getModel()-&gt;find($id);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>($detail)) &#123;</span><br><span class="line">                <span class="comment">//补充错误信息</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CommonException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success($detail);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一条记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@route</span> delete.api/info/&#123;id&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deleteInfo</span><span class="params">(Request $request, $id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//查询记录</span></span><br><span class="line">            $model = <span class="keyword">$this</span>-&gt;getModel();</span><br><span class="line">            $detail = $model-&gt;find($id);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">empty</span>($detail)) &#123;</span><br><span class="line">                <span class="comment">//补充错误信息</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CommonException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行删除</span></span><br><span class="line">            $res = $model-&gt;where(<span class="string">'id'</span>, $id)-&gt;delete();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建业务逻辑"><a href="#创建业务逻辑" class="headerlink" title="创建业务逻辑"></a>创建业务逻辑</h2><p>这时候执行创建的<code>artisan</code>命令就可以了</p>
<blockquote>
<p>php artisan make:queryController your controller path -m your model path</p>
</blockquote>
<p>这时候在你的Controller下面就会多出一个Controller文件，你只需要在路由中添加路由就可以了。</p>
<p>这个库的github地址在下面，感兴趣的朋友可以看一下。</p>
<blockquote>
<p><a href="https://github.com/Thepatterraining/queryCommon" target="_blank" rel="noopener">https://github.com/Thepatterraining/queryCommon</a></p>
</blockquote>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel路由自动加载</title>
    <url>/laravel%E8%B7%AF%E7%94%B1%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD.html</url>
    <content><![CDATA[<h1 id="laravel路由自动加载"><a href="#laravel路由自动加载" class="headerlink" title="laravel路由自动加载"></a>laravel路由自动加载</h1><p>laravel 自带的路由文件有四个</p>
<ul>
<li>api.php 文件存放 api 路由，会自动加载api前缀和一些中间件。</li>
<li>channels.php 文件用于注册应用支持的所有事件广播频道。</li>
<li>console.php 文件用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行 IO 方法进行交互，尽管这个文件并不定义 HTTP 路由，但是它定义了基于控制台的应用入口（路由）。</li>
<li>web.php 如果应用无需提供无状态的、RESTful 风格的 API，那么路由基本上都要定义在 web.php 文件中。会自动加载web中间件。</li>
</ul>
<p>我们常用的无非是api和web路由，一开始我们可以都写在里面，那当程序不断扩大，路由达到几千个，几万个甚至更多，放在一个文件里显示难以维护，难以查找。</p>
<p>这时候我们需要把路由分到不同的路由文件中去，我们在routes目录下创建api文件夹，来存放相关的api路由。</p>
<a id="more"></a>

<p>这时候我们自己创建的路由文件是不被框架认可的，不被加载的。那我们怎么做呢，最简单的方法是加载到api.php路由文件内。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Route</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> base_path(<span class="string">'routes/api/user.php'</span>);  <span class="comment">//加载api文件夹下的用户路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">| API Routes</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Here is where you can register API routes for your application. These</span></span><br><span class="line"><span class="comment">| routes are loaded by the RouteServiceProvider within a group which</span></span><br><span class="line"><span class="comment">| is assigned the "api" middleware group. Enjoy building your API!</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Route::middleware(<span class="string">'auth:api'</span>)-&gt;get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Request $request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $request-&gt;user();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这样的方式有着很大的缺点，难道我们每增加一个路由文件，都要修改这个api.php文件嘛？</p>
<p>我们还有更好的方式，在laravel中，服务提供者是一个很重要的模块，其实这里的所有路由都是通过<code>RouteServiceProvider.php</code>这个服务提供者来加载的。所以我们只需要更改这个服务提供者就可以了。</p>
<p>这里面有一个<code>mapApiRoutes</code>函数来加载api路由，我们可以写一个函数<code>requireRoutes</code>来加载我们自己创建的路由。然后在<code>mapApiRoutes</code>函数里面调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Define the "api" routes for the application.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * These routes are typically stateless.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">mapApiRoutes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Route::prefix(<span class="string">'api'</span>)     <span class="comment">//前缀</span></span><br><span class="line">           -&gt;middleware(<span class="string">'api'</span>)  <span class="comment">//中间件</span></span><br><span class="line">           -&gt;namespace(<span class="keyword">$this</span>-&gt;namespace)  <span class="comment">//命名空间</span></span><br><span class="line">           -&gt;group(base_path(<span class="string">'routes/api.php'</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">$this</span>-&gt;requireRoutes(<span class="string">'routes/Api'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 遍历文件夹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">requireRoutes</span><span class="params">($path)</span> </span>&#123;</span><br><span class="line">       $dirs = scandir(base_path($path));</span><br><span class="line">       <span class="keyword">foreach</span> ($dirs <span class="keyword">as</span> $dir) &#123;</span><br><span class="line">           <span class="keyword">if</span> (is_dir(base_path($path.<span class="string">'/'</span>.$dir))) &#123;</span><br><span class="line">               <span class="keyword">if</span>($dir==<span class="string">'.'</span> || $dir==<span class="string">'..'</span>)&#123;<span class="comment">//判断是否为系统隐藏的文件.和..  如果是则跳过否则就继续往下走，防止无限循环再这里。</span></span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">$this</span>-&gt;requireRoutes($path.<span class="string">'/'</span>.$dir);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//文件，加载进来</span></span><br><span class="line">               Route::prefix(<span class="string">'api'</span>)</span><br><span class="line">               -&gt;middleware(<span class="string">'api'</span>)</span><br><span class="line">               -&gt;middleware(<span class="string">'jwtCheck'</span>)</span><br><span class="line">               -&gt;namespace(<span class="keyword">$this</span>-&gt;namespace)</span><br><span class="line">               -&gt;group(base_path($path.<span class="string">'/'</span>.$dir));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker快速搭建多平台laravel环境-laradock</title>
    <url>/%E5%9F%BA%E4%BA%8Edocker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%A4%9A%E5%B9%B3%E5%8F%B0laravel%E7%8E%AF%E5%A2%83-laradock.html</url>
    <content><![CDATA[<h1 id="基于docker快速搭建多平台laravel环境-laradock"><a href="#基于docker快速搭建多平台laravel环境-laradock" class="headerlink" title="基于docker快速搭建多平台laravel环境-laradock"></a>基于docker快速搭建多平台laravel环境-laradock</h1><p>现在docker技术越来越火，docker的应用也越来越多。</p>
<p>我们为什么要用docker呢，因为它能提供你一个纯净的环境，能统一所有开发人员的环境，公司的技术有很多人，那每个人装的环境都可能不一样，你是php7.3，他是php7.0，你是mysql8.0，他是mysql5.6，这些环境上的差异有时候会导致代码的错误。</p>
<p>还有环境这东西装一次就够用了，你家里的电脑环境和公司的环境也有可能不一致。使用docker装环境之后，我们可以装完之后打包起来，在任何一个docker上运行这个配置文件都可以生成相同的环境。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote>
<p> git clone <a href="https://github.com/Laradock/laradock.git" target="_blank" rel="noopener">https://github.com/Laradock/laradock.git</a></p>
</blockquote>
<a id="more"></a>

<p>把这个库克隆下来以后，进入目录</p>
<blockquote>
<p>cd [your work]/laradock</p>
</blockquote>
<p>复制env-example文件到.env文件</p>
<blockquote>
<p>cp env-example .env</p>
</blockquote>
<p>修改.env配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DB_HOST&#x3D;mysql</span><br><span class="line">REDIS_HOST&#x3D;redis</span><br></pre></td></tr></table></figure>

<p>在.env中配置工作目录,如果你的目录wwwroot和laradock目录同级则这样设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP_CODE_PATH_HOST&#x3D;..&#x2F;wwwroot</span><br></pre></td></tr></table></figure>

<p>配置nginx文件，打开 ./nginx/sites/default.conf，修改下面两行</p>
<p><code>/var/www</code>目录相当于上面配置的../wwwroot目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_name your server name;</span><br><span class="line">root &#x2F;var&#x2F;www&#x2F;[your dir]&#x2F;public;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>启动docker 程序</p>
<blockquote>
<p>docker-compose up -d nginx redis mysql</p>
</blockquote>
<p>如果启动中报错</p>
<blockquote>
<p>ERROR: Service ‘mysql’ failed to build: Get <a href="https://registry-1.docker.io/v2/" target="_blank" rel="noopener">https://registry-1.docker.io/v2/</a>: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</p>
</blockquote>
<p>报这种错误，那么你需要一个docker镜像加速器了，可以使用daocloud的加速器。</p>
<blockquote>
<p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">https://www.daocloud.io/mirror#accelerator-doc</a></p>
</blockquote>
<p>按照配置添加完以后再次运行命令就可以了</p>
<h2 id="env文件参数介绍"><a href="#env文件参数介绍" class="headerlink" title=".env文件参数介绍"></a>.env文件参数介绍</h2><p>PHP_VERSION=7.3 这个参数是php的版本，默认php7.3</p>
<p>PHALCON_VERSION=3.4.5 phalcon的版本</p>
<p>PHP_INTERPRETER=php-fpm php解释器，默认php-fpm</p>
<p>nginx 配置</p>
<p>NGINX_HOST_HTTP_PORT=80  //nginx http 端口<br>NGINX_HOST_HTTPS_PORT=443 //nginx https 端口<br>NGINX_HOST_LOG_PATH=./logs/nginx/  //nginx 日志<br>NGINX_SITES_PATH=./nginx/sites/   //nginx 配置<br>NGINX_PHP_UPSTREAM_CONTAINER=php-fpm //nginx 使用php-fpm连接php<br>NGINX_PHP_UPSTREAM_PORT=9000  //php端口<br>NGINX_SSL_PATH=./nginx/ssl/ //ssl</p>
<p>mysql配置</p>
<p>MYSQL_VERSION=5.7    mysql版本 默认是8.0 建议修改成5.7<br>MYSQL_DATABASE=default  数据库<br>MYSQL_USER=default      用户名<br>MYSQL_PASSWORD=secret   密码<br>MYSQL_PORT=3306         mysql 端口<br>MYSQL_ROOT_PASSWORD=root mysql root 密码<br>MYSQL_ENTRYPOINT_INITDB=./mysql/docker-entrypoint-initdb.d</p>
<p>REDIS_PORT=6379 redis端口</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的队列使用技巧</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
    <content><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>队列是一种先进先出的数据结构</p>
</blockquote>
<p>我们的程序在什么情况下会用到队列呢？<code>异步处理</code>。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们一般写的web程序都是同步执行的，比如前端发送一个登录请求，后端一步一步的处理，查询用户，判断密码等等，返回登陆成功或者错误信息，前端阻塞等到后端返回后进行下一步处理。</p>
<p>那么这种程序有一个什么问题呢，首先，前后端建立的http连接是有超时时间的，当后端处理请求时间过长会返回超时错误。</p>
<p>就算没有超时的限制，对于用户体验来讲，当你的程序响应很慢，那么用户就会觉得，这什么玩意，真垃圾！！！</p>
<h3 id="导出场景"><a href="#导出场景" class="headerlink" title="导出场景"></a>导出场景</h3><p>基于这些原因，我们可以需要快速的处理用户请求。像导出大文件的时候，没办法很快的给用户响应怎么办呢，我们可以用异步的方式处理，先给用户返回正在导出，或者导出成功。</p>
<p>这个时候我们后台程序真的导出了嘛？没有，我们可以将这个导出请求放入一个队列中，等待另外一个处理程序将队列中的数据取出进行处理，这个处理程序一直监听队列，如果发现队列有消息，就去取出来进行处理。在处理程序中可以根据数据类型的不同，把它送到具体的处理类中，比如导出数据，处理程序会分发给导出类进行处理，由导出类处理完成后，返回处理完成。</p>
<a id="more"></a>

<p>这时候我们可以有一个下载管理进行下载，或者发送站内信，邮件等方式将导出文件发给用户。</p>
<p>这个案例中，用户发起导出请求后，可以快速得到响应，而且这种方式还有一个作用，那就是<code>松耦合</code>，他将我们的具体处理程序分离开了，不在耦合到一起。</p>
<p>除了这个还有什么作用嘛，有，秒杀！</p>
<h3 id="秒杀场景"><a href="#秒杀场景" class="headerlink" title="秒杀场景"></a>秒杀场景</h3><p>我们经常能遇到10点秒杀，限量100件这种。那他是怎么实现的呢，要知道，当9点59的时候，很多用户就会不断刷新，等待10点开枪。</p>
<p>首先，不断刷新页面，就会有不断的请求过来，几千万的查询请求一瞬间涌入服务器，这个还好说，可以用缓存解决。那一到10点，他们全部都发出购买请求，但是这时候，我们只有100件卖出，100个人能买到，其他人都买不到。这时候我们也可以使用消息队列，先将购买请求放入消息队列，返回正在抢购，然后队列处理程序取出消息进行处理，取出一条就卖出相应的数量，进行库存的删减。我们在做这些操作的时候，为了防止超卖，最好是加上锁，只有拿到锁的程序才可以进行处理，后面的程序会阻塞直到锁被解开。这样的话数量上就会有保证了，但是这样会消耗性能。</p>
<p>这次消息队列使用其实相当于把瞬间的高并发流量挡住了，然后慢慢处理，缓解我们服务器的压力。</p>
<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><p>其实很多时候都可以使用消息队列来解耦，异步处理。只要我们的主要流程不受影响就可以了。比如我之前的一个项目，在注册时候，如果填写了邀请码就会发放优惠券，这个步骤就是可以放到消息队列中处理的。还有比如群发通知这种，也可以放到消息队列来处理。</p>
<p>总结来说：</p>
<ul>
<li>解耦</li>
<li>异步处理</li>
<li>削峰填谷</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>消息队列虽然有这些好处，但是也存在问题，比如注册发放优惠券，但是优惠券没有发放成功怎么办，为什么出现这种问题呢，有可能是消息丢失，或者处理失败。</p>
<ul>
<li>消息放入消息队列的时候丢失</li>
<li>消息在消息队列中丢失</li>
<li>消息在处理的时候丢失</li>
</ul>
<h3 id="消息在放入消息队列的时候丢失"><a href="#消息在放入消息队列的时候丢失" class="headerlink" title="消息在放入消息队列的时候丢失"></a>消息在放入消息队列的时候丢失</h3><p>这种时候消息丢失一般是因为网络抖动，队列宕机才会发生。为了防止因为这些产生的消息丢失，可以发送没成功的时候重复发送几次，一般重试2-3次就可以了。</p>
<p>但是这样可能会导致消息处理端重复处理，为了解决这种情况，可以给每一个消息生产一个唯一id。</p>
<h3 id="消息在消息队列中丢失"><a href="#消息在消息队列中丢失" class="headerlink" title="消息在消息队列中丢失"></a>消息在消息队列中丢失</h3><p>消息存储在消息队列中的时候，不是立即写入磁盘的。为了减少磁盘io，会先将信息写入系统的Page Cache，当Page Cache中的数据达到一定量或者达到一定时间的时候会一起写入磁盘中进行持久化的存储，那再还没有写入磁盘，系统宕机导致系统的Page Cache丢失，那这时候这些数据就会丢失了。</p>
<p>解决方案：</p>
<p>可以布置队列的集群，这样就算一个宕机还有其他的存储着信息不会导致信息丢失。</p>
<p>Kafka集群中，由leader负责写入和消费，有多个follower负责数据的备份，有些follower被叫做ISR(in-sync replicas)。消息进入kafka会由leader先写入，然后异步的同步给其他follower，当leader挂掉之后，会从ISR中选取新的leader，由于leader是异步发送给follower的，那如果还没发送leader就挂掉了，消息还是会丢失。kafka中提供了’acks’这么一个选项，这个选项设置为’all’的话，会等到leader同步给所有follower之后才返回写入成功，这样会保证消息不丢失，但是会降低性能。</p>
<h3 id="消息在处理的时候丢失"><a href="#消息在处理的时候丢失" class="headerlink" title="消息在处理的时候丢失"></a>消息在处理的时候丢失</h3><p>这里除了消息丢失还有消息重复的问题，消息丢失可能是网络抖动或者处理程序错误引起的。</p>
<p>消息重复是因为消息重复放入了队列，前面也提到了，可以给每一个消息生产一个唯一id。我们收到消息之后先判断这个id是否被处理过，如果已经处理就丢弃这个消息。如果没有处理，则进行处理。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用队列的时候，我们需要监控队列的使用情况，比如队列中堆积了多少未处理信息，当堆积信息越来越多的时候我们就要思考为什么堆积了，是什么原因导致的。</p>
<p>除了看堆积信息，还可以发送特殊的监控信息到队列中，处理程序接受到监控信息的时候，对比它的进入时间，看看时间差是多少，如果超过了一定阈值，那么就需要注意了，我们的程序可能处理太慢了。</p>
<p>解决方案：</p>
<ul>
<li><p>横向扩展<br>横向扩展其实有点类似集群，我们可以部署多个处理程序，来加快处理进度</p>
</li>
<li><p>纵向扩展<br>纵向扩展就是提高我们处理程序的性能，优化他的代码，加快处理时间。</p>
</li>
</ul>
<p>还可以提高队列的存储介质，这样也可以加快队列的速度。</p>
<p>一个消息从队列取出的过程：</p>
<ul>
<li>读取存储到系统缓冲区</li>
<li>从系统缓冲区到用户缓冲区</li>
<li>从用户缓冲区到socket缓冲区</li>
<li>从socket缓冲区到网卡缓冲区</li>
</ul>
<p>我们如果能加快这四个步骤，也是可以加快队列的速度的。</p>
<p>比如操作系统提供的<code>sendfile</code>函数。</p>
]]></content>
      <categories>
        <category>队列</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>分布式</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html</url>
    <content><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>上一节提到了缓存穿透的问题，如果查询不存在的值怎么办，布隆过滤器可以完美解决这个问题。</p>
<p>当查询的时候，我们只需要确定这个值不存在，那我们就不用再查询了，也就减少了数据库，缓存的压力，减少了服务器压力，避免了一些攻击。</p>
<p><code>布隆过滤器</code>是个什么东西呢，它是由一串<code>二进制</code>组成的串，这个串中，只有<code>0</code>和<code>1</code>。</p>
<p>0代表不存在，1代表存在。</p>
<p>我们用hash算法计算之后，对布隆过滤器的长度进行取余操作，确定这个值应该存在布隆过滤器的哪个位置上。确定之后，将这个位置的值设置为<code>1</code>。</p>
<p>例如：</p>
<p>有一个长度为32的布隆过滤器</p>
<a id="more"></a>

<blockquote>
<p>00000 00000 00000 00000 00000 00000 00</p>
</blockquote>
<p>我们缓存了值<code>张三</code></p>
<blockquote>
<p>hash(张三) % 32 = 2</p>
</blockquote>
<p><code>布隆过滤器</code>变成下面这样</p>
<blockquote>
<p>01000 00000 00000 00000 00000 00000 00</p>
</blockquote>
<p>我们又缓存了<code>李四</code></p>
<blockquote>
<p>hash(李四) % 32 = 8</p>
</blockquote>
<p><code>布隆过滤器</code>变成下面这样</p>
<blockquote>
<p>01000 00100 00000 00000 00000 00000 00</p>
</blockquote>
<p>当我们查询<code>张三</code>的时候我们进行hash取余操作后是2，那我们就只要确定布隆过滤器的第二位是不是1就行了。</p>
<p>如果是<code>1</code>，代表了<code>张三</code>这个值有可能存在，为什么是有可能呢，因为我们不能保证hash冲突，也就是别的值经过hash取余操作后也是2。比如<code>王五</code>hash后也是2，那么我们查询王五的时候，不能确定是王五存在还是张三存在，但是我们能确定，他有存在的可能。</p>
<p>如果是<code>0</code>，代表了<code>张三</code>这个值一定不存在。</p>
<p>这样已经达到了我们的目的，我们就是想把不存在的筛出去。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>判断元素有误判的可能</li>
</ol>
<p>上面也说了，有hash冲突，那么怎么办呢？</p>
<p>我们可以经过多次hash，如果多次hash后取余的结果都是<code>1</code>，那么可能存在，这种方法可以减少hash冲突的概率。</p>
<p>不过只要我们的需求是要筛选掉<code>一定不存在</code>的，那么这个缺点就无所谓了。</p>
<ol start="2">
<li>不支持删除操作</li>
</ol>
<p>这个和上面的问题点类似，因为有误判的可能，如果删除，那么可能会影响到其他值。</p>
<p>解决方案：</p>
<p>我们可以存储计数器，不再使用二进制。</p>
<p>比如<code>张三</code>, <code>王五</code>都命中了2，那么布隆过滤器变成下面这样：</p>
<blockquote>
<p>02000 00100 00000 00000 00000 00000 00</p>
</blockquote>
<p>当我们删除的时候，计数器减1就好了</p>
<p>这样也存在问题，本身二进制存储很节省空间，但是存储数值类型的话，空间耗费就会增加了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用之前先思考一下使用场景，布隆过滤器适用于筛除<code>一定不存在</code>的元素。比如我们的缓存穿透。</p>
<p>布隆过滤器有误判的风险，可以使用多个hash来减少误判的概率。</p>
<p>布隆过滤器不支持删除操作，可以用耗费空间的方式使它支持。</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会用缓存吗</title>
    <url>/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E7%94%A8%E7%BC%93%E5%AD%98%E5%90%97.html</url>
    <content><![CDATA[<h1 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h1><p>当数据的读取量非常大的时候，为了缓解数据库的压力，会大量的使用到缓存。</p>
<p>那什么是缓存呢，我觉得是这样的</p>
<blockquote>
<p>两种存储介质a,b，只要a比b快，就可以用a来做b的缓存</p>
</blockquote>
<p>数据库一般都是存储在磁盘上面，但是磁盘的访问速度比较慢，当我们想快速获取到数据的时候，显然磁盘已经满足不了我们的需求了。</p>
<p>这时候我们一般会用到Redis, Memchached这种把数据存放在内存之中的NoSql数据库，用他们来缓存我们的数据，因为内存中的读取要比磁盘快的多。</p>
<p>那么缓存到底要怎么用呢？是只要把数据放到Redis里面，然后读取就可以了吗？</p>
<p>如果只是这么简单就好了，在缓存的时候我们要考虑几点东西。</p>
<p>缓存既然是在内存中，那么他们能存储的量就不大，那么哪些数据要放在缓存中呢？缓存的命中率应该达到多少呢？</p>
<p>在什么时候写入缓存呢？该怎么读取缓存呢？</p>
<p>怎么防止缓存穿透和缓存雪崩呢？</p>
<a id="more"></a>

<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><h3 id="Cache-Aside-旁路缓存-策略"><a href="#Cache-Aside-旁路缓存-策略" class="headerlink" title="Cache Aside(旁路缓存)策略"></a>Cache Aside(旁路缓存)策略</h3><p>当我们有缓存的时候，我们就要考虑怎么写入缓存，更新缓存，删除缓存，查询缓存。</p>
<p>写入缓存一般是在创建数据的时候，比如这么一个场景，我之前的一个项目跟房产有关，房产数据在创建的时候写入缓存。</p>
<p>这时候，缓存中存在这么一条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;id:1,name:1号房产,space:80,price:10000&#125; &#x2F;&#x2F;80平米，每平米单价1万</span><br></pre></td></tr></table></figure>

<p>这时候这个房子的价格变动了，更新为每平米2万了，那么我们更新数据库，那这时候缓存要不要更新呢。</p>
<ul>
<li>更新缓存</li>
</ul>
<p>当并发线程的时候更新，两个线程同时更新就会导致脏数据的产生。</p>
<p>a要修改成2万，b要修改成3万，a先修改，b在修改，但是b的程序执行的快，b先修改了缓存中的数据，a才修改了缓存中的数据，那么这时候数据库是3万，缓存是2万。</p>
<p>解决方案，直接删除缓存，将缓存删除，查询的时候再回种到缓存中，保证缓存和数据库信息的一致性。</p>
<p>这就是<code>Cache Aside策略</code>。</p>
<p>当写入的时候：</p>
<ul>
<li>写入数据库信息</li>
<li>写入缓存信息</li>
</ul>
<p>当更新的时候：</p>
<ul>
<li>更新数据库信息</li>
<li>删除缓存信息</li>
</ul>
<p>当读取的时候：</p>
<ul>
<li>读取缓存</li>
<li>缓存存在直接返回数据</li>
<li>缓存不存在读取数据库</li>
<li>创建缓存，返回数据</li>
</ul>
<p>但是这个策略也存在问题，当更新很多数据的时候，会导致很多缓存失效，那么数据库的压力会增加。</p>
<p>解决方案：</p>
<ul>
<li>更新的时候更新缓存信息，但是增加锁机制，同一时间只有一个程序在更新缓存，但是对性能有影响。</li>
<li>更新的时候更新缓存信息，给缓存的过期时间设置的短一些，就算有脏数据也会尽快过期，会产生脏数据。</li>
</ul>
<h3 id="Read-Write-Through（读穿-写穿-策略）"><a href="#Read-Write-Through（读穿-写穿-策略）" class="headerlink" title="Read/Write Through（读穿/写穿 策略）"></a>Read/Write Through（读穿/写穿 策略）</h3><p>这个策略是你的程序只和缓存打交道，你只读写缓存，然后由缓存把数据同步给数据库。</p>
<p>写入的时候有两种做法：</p>
<ul>
<li>写入缓存 让缓存同步给数据库</li>
<li>写入数据库，当读取的时候回种缓存，这种速度快，因为没写入缓存</li>
</ul>
<p>更新的时候：</p>
<ul>
<li>更新缓存数据</li>
</ul>
<p>读取的时候：</p>
<ul>
<li>读取缓存</li>
<li>缓存存在直接返回数据</li>
<li>缓存不存在读取数据库</li>
<li>创建缓存，返回数据</li>
</ul>
<h3 id="Write-Back-回写策略"><a href="#Write-Back-回写策略" class="headerlink" title="Write Back (回写策略)"></a>Write Back (回写策略)</h3><p>这个策略是写入数据时候只写入缓存，然后将缓存标记为脏。当下次使用的时候把脏缓存的数据写入到数据库。</p>
<p>写入的时候：</p>
<ul>
<li>写入缓存</li>
<li>标记为脏</li>
</ul>
<p>更新的时候：</p>
<ul>
<li>判断缓存是否为脏</li>
<li>如果是脏，将缓存数据写入数据库，然后更新缓存</li>
<li>如果不是脏，直接更新缓存，并标记为脏</li>
</ul>
<p>读取的时候：</p>
<ul>
<li>读取缓存</li>
<li>缓存存在直接返回数据</li>
<li>缓存不存在，寻找一个可用的缓存块，判断缓存是否为脏</li>
<li>如果是脏，将缓存数据写入数据库，查询数据库信息，回写缓存</li>
<li>如果不是脏，查询数据库信息，回写缓存</li>
<li>返回数据</li>
</ul>
<p>这个策略读取的时候有一些改变，当缓存命中，没有改变。</p>
<p>缓存没有命中会寻找一个缓存块，查看是否是脏缓存，脏缓存意味着缓存信息有变动，需要同步到数据库，所以先同步到数据库在查询。如果不是脏缓存，意味着缓存已经同步到数据库，可以直接查询回写缓存。</p>
<p>上面几种策略其实都是写入更新时候有变动，只有最后一个策略在读取的时候稍微有改变。</p>
<p>一般情况下，使用前两种已经足够。</p>
<h2 id="缓存可用性"><a href="#缓存可用性" class="headerlink" title="缓存可用性"></a>缓存可用性</h2><p>如果这时候，缓存挂掉了，就会有大量请求穿透到数据库层，严重情况下，会导致整个系统挂掉。那么这种情况怎么办呢。</p>
<p>我们可以横向扩展缓存，分布式布置多个缓存节点，那么其中一个节点挂掉，我们还有其他的缓存节点可以使用。</p>
<h3 id="客户端方案"><a href="#客户端方案" class="headerlink" title="客户端方案"></a>客户端方案</h3><p>这里的客户端指的是使用缓存的客户端，也就是我们的服务器。</p>
<h4 id="写入的时候"><a href="#写入的时候" class="headerlink" title="写入的时候"></a>写入的时候</h4><p>当写入分布式缓存的时候，我们要怎么写入呢。</p>
<p>这个和分库分表差不多，都是横向扩展嘛，那我们写入也可以差不多啊，使用<code>hash取余算法</code>，来计算数据写入哪个节点。</p>
<p>但是这样存在一个问题，当我们的节点需要增加或者减少的时候怎么办，我们要重新取余，数据重新存储，这就难搞了啊。</p>
<p>解决方案：</p>
<ul>
<li>一致性哈希算法</li>
</ul>
<p>我们假设一个环，将所有节点<code>hash取余</code>之后放到环上，将要缓存的数据也<code>hash取余</code>之后放到环上，怎么确定数据存在哪个节点呢？将数据顺时针移动，遇到的第一个节点就是数据存储的节点。</p>
<p>这个算法增加或减少节点的时候会发生什么呢</p>
<ul>
<li>增加的时候，部分数据移动到新增节点</li>
<li>减少的时候，减少的节点的数据移动到另一个节点</li>
</ul>
<p>看上去好像没什么问题，但是如果环上的节点分布不均匀，某一个节点数据很多，当这个节点宕机后，他的数据转移到下一个节点，下一个节点压力骤增，如果节点扛不住，那么重复这些操作，会导致整个缓存系统的雪崩。</p>
<p>解决方案：</p>
<p>上面说了，是环上的节点分布不均匀导致的，那我们就让他分布均匀就好了。或者将一个节点放在环上多个位置，这样的话，这个节点挂掉，他的数据会移动到其他很多节点上，每个节点的压力就不会大增了。</p>
<h4 id="读取的时候"><a href="#读取的时候" class="headerlink" title="读取的时候"></a>读取的时候</h4><p>读取缓存的时候也可以像mysql学习，配置<code>主从读取</code>，先从从库读取，读取不到再从主库读取，这样就算从库挂掉，那么还有主库可以读取缓存，读流量不会直接到数据库层。</p>
<p>除了配置主从，还可以配置<code>多副本</code>，副本也就是缓存的缓存，我们在缓存层前面再加一层缓存层，如果这个副本读取不到再去读取主从，回写副本，这样副本中都是最热的缓存，基于成本的考虑，副本容量一般很小。</p>
<h3 id="中间层方案"><a href="#中间层方案" class="headerlink" title="中间层方案"></a>中间层方案</h3><p>客户端方案已经可以支撑分布式缓存，但是客户端方案存在一个问题，他受限于语言，如果将他单拿出来，那么所有的请求经过中间层，就不会受限于语言了</p>
<h3 id="服务端方案"><a href="#服务端方案" class="headerlink" title="服务端方案"></a>服务端方案</h3><p>redis sentinel是redis 2.4版本中增加的，这个东西可以在redis master节点挂掉之后，在从节点中选取新的主节点，不至于主节点挂掉整个程序挂掉。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>当缓存发生缓存穿透怎么办，前面已经说了一致性hash算法中会引起的缓存雪崩及解决方案，这里就来看看缓存穿透。</p>
<p>如果查询一条数据库不存在的数据，就肯定会引起缓存穿透，因为数据库都没有，缓存更没有了。</p>
<p>这种情况可以<code>回写空值</code>，这样虽然数据库没有，但是缓存有，请求就会被拦截在缓存层中。</p>
<p>但是空值会占用空间而且无意义，如果缓存中存在大量空值，将会占用大量空间。</p>
<p>除了<code>回写空值</code>，还可以使用布隆过滤器。</p>
<p>下一篇文章讲布隆过滤器。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式必备发号器</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BF%85%E5%A4%87%E5%8F%91%E5%8F%B7%E5%99%A8.html</url>
    <content><![CDATA[<h1 id="发号器"><a href="#发号器" class="headerlink" title="发号器"></a>发号器</h1><p>生成唯一id的需求很多，我们经常会用到，不管是单库单表中的唯一，还是分布式的唯一。</p>
<h2 id="SnowFlake-算法"><a href="#SnowFlake-算法" class="headerlink" title="SnowFlake 算法"></a>SnowFlake 算法</h2><p>说一下SnowFlake算法，这个算法是一个生成唯一id的算法。</p>
<p>使用的是一个64位的二进制串，把这个串分成了几个部分。</p>
<ul>
<li>符号位 占一个位置 0 为正</li>
<li>时间戳位 占41个位置，使用毫秒级时间戳</li>
<li>机器位 占10个位置， 可以支持2的10次方-1个机器使用</li>
<li>序号位 占12个位置， 同一毫秒内可以生成2的12次方-1个id</li>
</ul>
<a id="more"></a>

<p>但是我们的业务很少用到这个级别的发号器，所以可以把时间改为秒级，下面是我改版后的SnowFlake算法组成：</p>
<ul>
<li>符号位 占一个位置 0 为正</li>
<li>时间戳位 占38个位置，使用秒级时间戳</li>
<li>机器位 占5个位置， 可以支持2的5次方-1个机器使用</li>
<li>业务位 占8个位置， 可以支持2的8次方-1个业务</li>
<li>序号位 占12个位置， 同一毫秒内可以生成2的12次方-1个id</li>
</ul>
<p>我这里面增加了业务位，因为这样可以把每个业务都分开，保证每个业务每个机器每秒内可以生成1024个id。</p>
<p>看一下我们php的实现代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> FIRST = <span class="number">0</span>; <span class="comment">//首位 符号位 表示正负0为正 1为负</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> TIME_LENGTH = <span class="number">38</span>; <span class="comment">//时间戳位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> MACHINE_LENGTH = <span class="number">5</span>; <span class="comment">//机器码位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> BUSINESS_LENGTH = <span class="number">8</span>; <span class="comment">//业务位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> SEQUENCE_LENGTH = <span class="number">12</span>; <span class="comment">//序列号位数 二进制的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $machineId = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一次发号时间</span></span><br><span class="line">    <span class="keyword">private</span> $oldTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $sequence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务对应的业务id</span></span><br><span class="line">    <span class="keyword">private</span> $businessArr = [</span><br><span class="line">        <span class="string">'order'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($machineId = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strlen(decbin($machineId)) &gt; <span class="keyword">self</span>::MACHINE_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'机器id超长！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;machineId = $machineId;</span><br><span class="line">        <span class="comment">//初始化时间戳</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;oldTime = <span class="keyword">$this</span>-&gt;getTime();</span><br><span class="line">        <span class="comment">//初始化序号</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;sequence = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成唯一id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $businessType 业务类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">generate</span><span class="params">($businessType)</span> </span>&#123;</span><br><span class="line">        $time = <span class="keyword">$this</span>-&gt;getTime();</span><br><span class="line">        <span class="comment">//比较时间戳</span></span><br><span class="line">        <span class="keyword">if</span> ($time == <span class="keyword">$this</span>-&gt;oldTime) &#123;</span><br><span class="line">            <span class="comment">//在同一毫秒内创建，序号递增</span></span><br><span class="line">            <span class="keyword">if</span> (strlen(decbin(<span class="keyword">$this</span>-&gt;sequence)) &gt;= <span class="keyword">self</span>::SEQUENCE_LENGTH) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'到达最大发号个数'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++<span class="keyword">$this</span>-&gt;sequence; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//到达下一个时间，重置序号</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;sequence = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $businessId = <span class="keyword">$this</span>-&gt;getBusinessId($businessType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符位偏移量</span></span><br><span class="line">        $firstShift = <span class="keyword">self</span>::TIME_LENGTH + <span class="keyword">self</span>::MACHINE_LENGTH + <span class="keyword">self</span>::BUSINESS_LENGTH + <span class="keyword">self</span>::SEQUENCE_LENGTH;</span><br><span class="line">        <span class="comment">//时间戳偏移量</span></span><br><span class="line">        $timeShift = <span class="keyword">self</span>::MACHINE_LENGTH + <span class="keyword">self</span>::BUSINESS_LENGTH + <span class="keyword">self</span>::SEQUENCE_LENGTH;</span><br><span class="line">        <span class="comment">//机器位偏移量</span></span><br><span class="line">        $machineShift = <span class="keyword">self</span>::BUSINESS_LENGTH + <span class="keyword">self</span>::SEQUENCE_LENGTH;</span><br><span class="line">        <span class="comment">//业务偏移量</span></span><br><span class="line">        $businessShift = <span class="keyword">self</span>::SEQUENCE_LENGTH;</span><br><span class="line"></span><br><span class="line">        $res = <span class="keyword">self</span>::FIRST &lt;&lt; $firstShift | $time &lt;&lt; $timeShift | <span class="keyword">$this</span>-&gt;machineId &lt;&lt; $machineShift | $businessId &lt;&lt; $businessShift | <span class="keyword">$this</span>-&gt;sequence;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入时间</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;oldTime = $time;</span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取毫秒级时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取业务id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBusinessId</span><span class="params">($businessType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;businessArr[$businessType];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步是把每个部分归位，左移相应的偏移量，到达相应的位置，比如时间戳：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1011110100000010111110100010100 &lt;&lt; 25 &#x3D; 10111101000000101111101000101000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>机器位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&lt; 20 &#x3D; 100000000000000000000</span><br></pre></td></tr></table></figure>

<p>业务位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&lt; 12 &#x3D; 1000000000000</span><br></pre></td></tr></table></figure>

<p>序号位不用左移</p>
<p>最后将这些进行<code>或操作</code>，二进制的<code>或操作</code>就是将每一位进行对比，如果都是0则返回0，有一个1就返回1，两个都是1也返回1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间戳或上机器位就是这个结果，这也相当于两个加在一起了</span><br><span class="line">10111101000000101111101000101000000000000000000000000000 | 100000000000000000000 &#x3D; 10111101000000101111101000101000000100000000000000000000</span><br><span class="line"></span><br><span class="line">再或上业务位和符号位</span><br><span class="line"></span><br><span class="line">10111101000000101111101000101000000100000000000000000000 | 1000000000000 | 1 &#x3D; 10111101000000101111101000101000000100000010000000000001</span><br></pre></td></tr></table></figure>

<p>最后把每部分<code>或操作</code>之后就是我们要的最终结果，不管是左移操作还是或操作，实际上都是对变量里面的二进制进行的操作，操作之后会转换成我们看到的十进制消息，也就是<code>53202044035534850</code>。</p>
<p>在这里面还用到了<code>decbin()</code>这个函数，这个函数的作用就是将十进制转换成二进制。</p>
<p>我们使用这个发号器生成的唯一id隐含了我们的业务性，也保证了唯一性，如果你的业务很庞大，可以使用毫秒级时间戳或者扩大序号位，都可以根据实际使用情况调整。</p>
<p>下面是这个算法的github地址</p>
<blockquote>
<p><a href="https://github.com/Thepatterraining/design-pattern/tree/master/app/Http/Models/SnowFlake" target="_blank" rel="noopener">https://github.com/Thepatterraining/design-pattern/tree/master/app/Http/Models/SnowFlake</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>分布式</tag>
        <tag>SnowFlake</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql分库分表</title>
    <url>/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html</url>
    <content><![CDATA[<h3 id="mysql-分库分表"><a href="#mysql-分库分表" class="headerlink" title="mysql 分库分表"></a>mysql 分库分表</h3><p>上一篇文章我们介绍了mysql的主从读写分离，这里我们介绍分库分表的应用。</p>
<p>什么是分库分表呢，分就是拆分，也就是将一个数据表（库）拆分成多个。那有什么作用呢，可以分散流量，和主从类似，主从是将读写流量分开，方便扩展，这里是将表（库）分开方便扩展。同时流量分散，比如一张上亿数据的表，那么查询起来肯定很慢，但是要是水平拆分成多张表，每张表的数据量就会很小，查询速度就会变快。</p>
<p>分库分表一般分为两种，一种是水平拆分，一种是垂直拆分。</p>
<a id="more"></a>

<h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>垂直拆分，比如你现在所有的表都放在一个库中，那么这个库会很庞大，那我们可以按照业务来拆分成多个数据库，比如用户相关的用户库，交易相关的交易库等等。</p>
<p>这种拆分理念和微服务的理念差不多，微服务同样是按照业务来划分。</p>
<p>这样处理用户相关的只会访问用户库，不会对其他数据库造成压力，同样的，我们用户库有压力也方便单独扩展。</p>
<p>表的垂直拆分同样的道理，不过一般在表设计的时候就已经拆分好了，不应该出现一张表还能进行拆分的情况。</p>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>水平拆分，比如你现在表数据量过大，一张表拥有上亿的数据量，这时候就要把一张表拆分成多张表。</p>
<p>怎么拆分呢，一般有两种方法，比如</p>
<h6 id="取余法"><a href="#取余法" class="headerlink" title="取余法"></a>取余法</h6><p>假设我们现在将一张千万级的表拆分成100个表，每张表的数据大概在十万量级。那我们怎么确定一条数据应该存在哪张表中呢，我们可以对数据的id进行取余操作，也就是 id % 100 = 1那就存放在一号表中， 2就放在2号表，以此类推。也可以hash一下再取余，比如hash(id) % 100。</p>
<h6 id="分段法"><a href="#分段法" class="headerlink" title="分段法"></a>分段法</h6><p>也就是我们确定区间，比如前十万用户存在一号表，然后十万十万的类推，或者根据时间，每个月的用户一张表都可以。</p>
<h4 id="join问题"><a href="#join问题" class="headerlink" title="join问题"></a>join问题</h4><p>那现在有一个问题，比如查询用户的时候需要查询出用户的余额，以前我们是join的方式联查，那现在分成多个表之后就没法join了，我们只能先查询出用户信息，然后再查询出这个用户的余额</p>
<h4 id="条件查询问题"><a href="#条件查询问题" class="headerlink" title="条件查询问题"></a>条件查询问题</h4><p>经过分表之后，数据分布在不同的地方，我们如果是查询id是5的用户，很简单，5 % 100就可以知道在哪张表中了，但是我们要查询姓名是张三的用户怎么办呢。我们要去查询哪张表呢，这个时候我们就需要做一个映射了，比如有一张表存储id 和 姓名的映射，我们通过这张映射表查询到张三的id，在id % 100来确定查询哪张表。这张映射表同样要分表，那我们怎么确定张三在哪张映射表中呢，我们可以用hash(张三) % 100的方式确定在哪张映射表中。</p>
<h4 id="主键唯一问题"><a href="#主键唯一问题" class="headerlink" title="主键唯一问题"></a>主键唯一问题</h4><p>还有一个问题，原来我们在一张表中，主键只要做到表唯一，我们现在100张表，怎么保证这条记录的主键id在这100张表中都是唯一的呢。</p>
<p>有一种方法，我们生成唯一的uuid就可以了，但是这样有几个问题</p>
<ul>
<li>有序性</li>
</ul>
<p>一般来说，我们都会使用自增id，保持id有序并且单调递增，为什么呢，因为mysql的innoDb引擎使用B+树存储索引数据，而主键就是一种索引。</p>
<p>索引数据在B+树种有序存储，这样不管是写入还是查询的效率都会很高，而如果是无序的，那么写入和查询的效率就会降低。</p>
<p>因为有序的时候可以使用很多搜索算法提高查询效率。</p>
<ul>
<li>表达性</li>
</ul>
<p>uuid不具备任何表达性，没办法看到从种看到这个uuid是属于哪个业务的。</p>
<p>知道了问题所在，我们就可以解决了。</p>
<p>在一下篇文章中会介绍snowFlake算法来解决这个问题。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql主从读写分离</title>
    <url>/mysql%E4%B8%BB%E4%BB%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html</url>
    <content><![CDATA[<h3 id="mysql主从读写分离"><a href="#mysql主从读写分离" class="headerlink" title="mysql主从读写分离"></a>mysql主从读写分离</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>mysql主从复制的常见使用场景，当我们的读写流量过大的情况下，尤其是读流量过大的情况下，mysql主从读写分离就很有必要了。</p>
<p>我们使用主库写入，读取从库来分离读写流量，而这时候读流量不断增加，那我们只需要扩展从库就可以了。</p>
<a id="more"></a>


<h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><p>数据库是怎么完成主从复制的呢，这里就要说到binlog了，这是存储数据库行为的二进制日志文件。从库会有一个io线程来读取这个binlog，读取之后写入一个叫做<code>relay log</code>的日志文件中，而主库也会创建一个log dump的线程来发送binlog给从库；同时，从库会创建一个sql线程将<code>relay log</code>中的内容写入从库。来实现主库数据到从库数据的一致性。</p>
<p>log dump线程是异步操作，也就是当你有数据写入主库的时候，不会等到数据同步到从库之后再返回写入成功，而是直接返回写入成功。</p>
<p>从库获取数据先写入<code>relay log</code>是因为直接写入从库可能很耗时，导致主从同步的延迟变长。</p>
<p>既然写入主库之后就返回成功，然后同步数据，那这时候就有可能发送主从数据不一致的问题，因为如果主库的数据还没有写入到binlog文件中的时候主库宕机了，那么就会导致binlog文件缺失，从而从库数据和主库数据不一致的问题，但是这种情况很少很少，<code>而基于性能来考虑，这种情况还在我们可接受范围之内</code>。</p>
<h4 id="主从读写分离的优缺点"><a href="#主从读写分离的优缺点" class="headerlink" title="主从读写分离的优缺点"></a>主从读写分离的优缺点</h4><p>主从读写分离固然可以让我们更好的应对大量的读写请求，但是读请求量非常大的情况下，并不是盲目的扩展从库就可以了，因为大量的从库会有大量的<code>io线程</code>来读取binlog，这样主库的压力就会变大。</p>
<p>还有主从数据库的同步肯定会有一些延迟，考虑以下情况，我之前的一个项目，用到了分红功能，后台审核之后会给用户发放分红，这是一个异步操作，我们会在审核之后把分红数据的id放到队列中，然后取出队列中的分红id到从库之中查询分红数据，那么这时候从库要是没有同步到数据，就会出现查到的数据状态不对或者数据不存在的问题。那么分红就进行不下去了。</p>
<p>怎么办呢，我们后来采用了直接将所有分红数据放到队列之中的方法，这样取出来就不用再次查询了，但是这样的弊端就是队列中的数据量会变大，但是这在我们的可接受范围之内。</p>
<p>除此之外还有其他的办法，比如将数据放到缓存之中，取出来id到缓存中查询，但是这样缓存也会很大。而且要保证缓存数据的一致性，那么像更新这种操作就会很危险，建议只有创建操作使用缓存。</p>
<p>还有一种方法是取出来查询的时候直接查询主库，但是这样主从读写分离就失去了意义。</p>
<p>总结一下三种方法：</p>
<ul>
<li>数据冗余到队列中，免去再次查询的步骤</li>
<li>数据放到缓存中，直接查询缓存保证一致性</li>
<li>直接查询主库，不查询从库</li>
</ul>
<p>这里我们分析了主从读写分离的执行过程和优缺点，今天就到这里啦</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的javascript</title>
    <url>/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript.html</url>
    <content><![CDATA[<h1 id="你不知道的-javascript"><a href="#你不知道的-javascript" class="headerlink" title="你不知道的 javascript"></a>你不知道的 javascript</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域了解了 lhs 和 rhs 两种查找方式</p>
<ul>
<li>lhs, 赋值左侧查找，需要找到变量，然后进行赋值，如果没找到，在非严格模式下会创建变量，严格模式会抛出 ReferenceError 异常</li>
<li>rhs，非赋值左侧查找，在引用的时候使用这种查找，在作用域里面如果没有查到，会直接抛出 ReferenceError 异常，而如果你查到了，但是操作不合法，比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么会抛出 TypeError 异常</li>
</ul>
<p><code>ReferenceError</code>和作用域的判别失败有关，而<code>TypeError</code>则是代表作用域里面找到了，但是对结果的操作是非法或者不合理的</p>
<a id="more"></a>

<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><p>动态作用域和词法作用域的区别，词法作用域是在写代码或者说定义时候确定的，而动态作用域是在运行时确定的。（this 也是），词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</p>
<p>比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>基于词法作用域的规则，函数 bar 可以访问外部的变量 a(这个例子中的 a 是一个 rhs 查询)</p>
<p>上面的代码从技术来讲，也许是闭包，但根据前面的定义，确切的说并不是。</p>
<p>下面的代码清晰的展示了闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); <span class="comment">//2           这就是闭包的效果</span></span><br></pre></td></tr></table></figure>

<p>函数 bar()的词法作用域能够访问 foo()的内部作用域。然后我们将 bar()函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数本身当作返回值</p>
<p>在 foo()执行后，其返回值（也就是内部的 bar()函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()</p>
<p>bar()显然可以被正常执行，但是在这个例子中，他在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo()执行后，通常会期待 foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器来释放不再使用的内存空间。由于看上去 foo()的内容不会再被使用，所以很自然的会考虑对其进行回收。</p>
<p>拜 bar()所声明的位置所赐，它拥有涵盖 foo()内部作用域的闭包，使得该作用域能够一直存活，以供 bar()在之后任何时间进行引用</p>
<p>bar()依然持有对该作用域的引用，而这个引用就叫做闭包</p>
<pre><code>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>首先是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则</p>
<p>思考一下下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>你应该注意到的，当我们调用 foo()时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</p>
<p>在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则</p>
<p>如果使用严格模式，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">//typeError: this is undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导</p>
<p>思考下面代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个代码里面，使用 obj.foo()来调用，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它</p>
<p>无论你如何称呼这个模式，当 foo()被调用时，它的落脚点确实指向 obj 对象。当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo()时，this 被绑定到 obj，因此 this.a 和 obj.a 时一样的</p>
<p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">42</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure>

<h6 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h6><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式</p>
<p>思考下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">//函数别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">//oops global</span></span><br></pre></td></tr></table></figure>

<p>一种更微妙，更常见并且更出乎意料的情况发生在传入回调函数时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//fn其实引用的是foo</span></span><br><span class="line">  fn(); <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line">doFoo(obj.foo); <span class="comment">//oops, global</span></span><br></pre></td></tr></table></figure>

<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样</p>
<p>如果把函数传入语言内置的函数而不是你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line">setTimeout(obj.foo, <span class="number">100</span>); <span class="comment">//oops, global</span></span><br></pre></td></tr></table></figure>

<p>js 内置的 setTimeout 函数实现和下面的伪代码类似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//等待delay毫秒</span></span><br><span class="line">  fn(); <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像我们看到的，回调函数丢失 this 绑定是非常常见的。无论哪种情况，this 的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没有办法控制会影响绑定的调用位置，之后我们会介绍如何通过固定 this 来修复这个问题</p>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>js 中的“所有”函数都有一些有用的特性，可以用来显示绑定，比如 call 和 apply 方法。严格来说，js 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见。</p>
<p>可惜，显示绑定仍然无法解决我们之前提出的丢失绑定问题</p>
<p>但是显示绑定的一个变种可以解决这个问题</p>
<h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>思考下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">//2</span></span><br><span class="line">setTimeout(bar, <span class="number">100</span>); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//硬绑定的bar不可能再修改它的this</span></span><br><span class="line">bar.call(<span class="built_in">window</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>由于硬绑定是一种非常常用的模式，所以在 es5 中内置了 Function.prototype.bind 方法，bind 返回一个硬编码的新韩淑，他会把参数设置 this 的上下文并调用原始函数</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>这是最后一条 this 的绑定规则，在讲解它之前我们首先需要澄清一个非常常见的关于 js 中函数和对象的误解</p>
<p>在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。通常的形式是这样的：</p>
<pre><code>something = new MyClass()</code></pre><p>js 也有一个 new 操作符，使用方法看起来一样，然而，js 中 new 的机制实际上和面向类的语言完全不同</p>
<p>js 中的构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，他们甚至都不能说时一种特殊的构造函数，他们只是被 new 的普通函数而已。</p>
<p>这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</p>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作</p>
<ol>
<li>创建一个全新的对象</li>
<li>这个新对象会被执行【【原型】】连接</li>
<li>这个新对象会绑定到函数调用的 this</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>这些规则如果同时出现，就需要一个优先级类进行判断是用的哪一条规则</p>
<p>毫无疑问，默认绑定的优先级是最低的，所以我们可以先不考虑它</p>
<p>隐式和显示哪个优先级更高呢，我们来测试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(); <span class="comment">//2</span></span><br><span class="line">obj2.foo(); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2); <span class="comment">//3</span></span><br><span class="line">obj2.foo.call(obj1); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>可以看到，显示的优先级更高，也就是说在判断时应当先考虑是否可以应用显示绑定</p>
<p>现在我们需要搞清楚 new 绑定和隐式绑定的优先级</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.a); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显示绑定谁的优先级更高呢</p>
<p>我们可以用硬绑定来试一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj1);</span><br><span class="line"></span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.a); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>判断 this</p>
<ol>
<li>如果用 new，那么 this 绑定的是新创建的对象</li>
<li>如果通过 call,apply 或者 bind，this 绑定的是指定的对象</li>
<li>函数是否在某个上下文对象中调用，如果是的话，绑定的是上下文对象，比如 obj.foo()</li>
<li>如果都不是，那么默认绑定到全局对象，如果严格模式，就绑定到 undefined</li>
</ol>
<h3 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h3><p>规则总有例外，这里也一样</p>
<p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call,apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo.call(<span class="literal">null</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//this 继承自foo()</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1);</span><br><span class="line"></span><br><span class="line">bar.call(obj2); <span class="comment">//2 不是 3</span></span><br></pre></td></tr></table></figure>

<p>foo 内部的箭头函数会捕获调用时 foo 的 this，由于 foo 的 this 绑定到 obj1,bar 的 this 也会绑定到 obj1，箭头函数的绑定无法被修改</p>
<p>箭头函数最常用于回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这里的this继承自foo</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的重要性体现在它用更常见的词法作用域取代了传统的 this 机制。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>js 一开始就没有设计成面向类的语言，所以也没有<code>class</code>, <code>extends</code>这种继承机制，但是<code>class</code>是一个一切皆对象的语言。<br>class 需要<code>new</code>来实例化一个对象，而<code>new</code>的过程中会执行构造函数，所以 js 的<code>new</code>操作符，就是直接把<code>普通函数</code>当成<code>构造函数</code>执行，用这样的方式来实现实例化，那么怎么实现<code>继承</code>机制呢，就引入了<code>prototype</code>，prototype 指向一个新的对象，这个对象里面存放了可以<code>共享</code>的属性。我们一般把 prototype 指向的这个属性叫做<code>原型对象</code>。</p>
<p>看下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，obj 有一个<strong>proto</strong>属性指向 Foo.prototype 这个对象，这就是原型链，<strong>proto</strong>这个属性可以一直往上查找，直到原型链的顶层 Object.prototype 这里，这也就是在 js 里面可以用 map,foreach 这些方法的原因，他们本身是没有这些方法的，所以 js 会通过原型链进行查找，直到找到这个方法进行调用，如果没有找到，则会抛出 TypeError 异常，比如在上面的 obj 对象中调用 obj.log 方法，就会报错了。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>在 es6 中，引入了 class 语法，让 js 用起来像其他的面向对象一样，但其实不一样的，class 只是一个语法糖，他本身还是使用的 prototype 来实现的。</p>
<h3 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h3><p>js 里面完全可以使用一种对象委托的方式来实现继承，而不是类的形式，比如用类来完成一件事的话大概像下面一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.msg = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.identify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype);</span><br><span class="line"></span><br><span class="line">Bar.prototype.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.identify()&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p>子类 Bar 继承了父类 Foo，然后生成了 b1,b2 两个实例</p>
<p>下面我们看看使用对象委托的方式来写同样的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Foo = &#123;</span><br><span class="line">  init(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = msg;</span><br><span class="line">  &#125;,</span><br><span class="line">  identify() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bar = <span class="built_in">Object</span>.create(Foo);</span><br><span class="line"></span><br><span class="line">Bar.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.identify()&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b1.init(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Object</span>.create(Bar);</span><br><span class="line">b2.init(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p>这段代码看起来是不是简洁了呢，我们只是把对象关联了起来，而不用再去模仿类的行为。</p>
<p>当然了，es6 引入的 class 语法也会让你觉得简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = msg;</span><br><span class="line">  &#125;</span><br><span class="line">  identify() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  identify() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  speak() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">$&#123;<span class="keyword">this</span>.identify()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> Bar(<span class="string">"b1"</span>);</span><br><span class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> Bar(<span class="string">"b2"</span>);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p>但是 class 只是把内部实现隐藏了起来，他的本质依旧是我们上面写的那样，依旧是使用的 prototype。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我觉得 class 和对象委托这两种设计模式，他们的本质都是使用 prototype，只不过一种是在模仿类，而一种则是不用模仿类，我遇到这个请求的时候，我就把请求委托给另外一个对象。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>你不知道的javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 的一些事儿</title>
    <url>/vue-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B%E5%84%BF.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>node面试总结</title>
    <url>/node%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>k8s之etcd节点竞选</title>
    <url>/k8s%E4%B9%8Betcd%E8%8A%82%E7%82%B9%E7%AB%9E%E9%80%89.html</url>
    <content><![CDATA[<h3 id="竞选流程"><a href="#竞选流程" class="headerlink" title="竞选流程"></a>竞选流程</h3><p>etcd内部采用raft协议来实现，所以在etcd里面，节点有3个状态，一开始都是follower节点，然后接收leader的心跳信息，如果接收不到，就进入candidate进入下一轮term发起竞选，等到收到集群多数节点的投票时，该节点就会转变成新的leader节点。leader节点有可能出现故障，导致follower接收不到心跳，这时候就会发生上面的竞选，新的leader产生以后，旧的leader就会变成follower。其实就是有新的leader之后，所有其他节点都会变成follower。</p>
<p>成为leader也是有条件的，比如你的数据完整性，在竞选投票的时候，如果其他节点发现你的数据不完整，是不会给你投票的。</p>
<h3 id="节点损坏"><a href="#节点损坏" class="headerlink" title="节点损坏"></a>节点损坏</h3><p>节点可能会因为各种原因损坏，导致无法正常工作。如果是leader节点那么就会导致follower收不到心跳而触发竞选机制，如果是follower节点，那么我们可以将这个节点删除以后在创建新的节点。因为损坏的节点依然会被计算在etcd总节点之中。</p>
<p>etcd采用基于仲裁模型的分布式共识，即（n + 1) / 2成员（多数）必须就提案一致才能提交给集群。因此当有follower损坏的时候，我们需要先删除在创建，而不能先创建在删除。</p>
<p>比如：如果有一个3个成员的集群，有一个成员损坏，那么这个集群仍然可以正常工作，这个时候删除损坏成员，该集群依然可以正常工作，然后添加新节点，这个行为是存在风险的，因为他可能会导致配置错误或无法加入集群，这种情况下，集群依然可以正常工作。而如果正确加入，依然可以正常工作。那我们想一下先增加新成员，如果增加失败，那么该集群总成员数量变成4个，而其中有1个早已损坏，还有一个刚添加的同样算是损坏，这将会使仲裁失效，所以默认情况下，etcd会拒绝这种成员的添加。</p>
<a id="more"></a>


<h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><p>etcd采用强一致性，实时同步，所以读的话，你从哪个节点读取都一样。对于写入来说，写入请求总会被leader先获取，然后leader节点广播给其他节点，当多数节点通过以后，这次写入会被提交，然后同步follower节点。一个已提交的数据才是真正存储下来的数据。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>etcd旨在可靠地存储不经常更新的数据并提供可靠的监视查询。etcd公开了以前版本的键值对，以支持快照和观看历史事件（“时间旅行查询”）。持久的多版本并发控制数据模型非常适合这些用例。</p>
<p>etcd将数据存储在多版本持久键值存储中。持久键值存储在其值被新数据取代时，保留键值对的先前版本。键值存储实际上是不可变的; 它的操作不会直接更新结构，而是始终生成新的结构。所有以前版本的密钥仍然可以访问，并且在修改后可以观看。为了防止数据存储随着时间的推移无限增长以及维护旧版本，可以压缩存储以删除最旧版本的数据。</p>
<h4 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h4><p>对于数据的存储保留了多个版本，每个原子变异操作（例如，事务操作可以包含多个操作）在<code>key space</code>上创建新的版本。之前修订的所有数据保持不变。旧版本的<code>key</code>仍可通过以前的版本访问。同样，版本也被编入索引; 对观察者进行修订是有效的。如果压缩存储以节省空间，则将删除紧凑版本之前的版本。版本在群集的生命周期内单调递增。</p>
<p>一个<code>key</code>的生命周期，从创造到删除。每个key可以有一个或多个生命周期。创建key会增加该key的版本，如果当前版本中不存在key，则从1开始。删除key会生成key的逻辑删除，通过将key的版本重制为0来结束key的当前生命周期。key的每次修改都会增加其版本；因此，版本在key的一个生命周期中单调增加。一旦压缩发生，之前设置的值将被删除。</p>
<h4 id="物理视图"><a href="#物理视图" class="headerlink" title="物理视图"></a>物理视图</h4><p>etcd将物理数据存储为持久b+树中的键值对。存储状态的每个版本仅包含其先前版本的增量，以实现高效。单个版本可以对应于树中的多个键。</p>
<p>键值对的关键是3元组（major, sub, type）。Major是持有key的存储版本。Sub在同一版本中的键之间进行区分。Type是特殊值的可选后缀。键值对的值包含先前版本的修改，因此是先前版本的一个增量。b+树按词汇顺序，字节顺序排序。对版本增量的远程查找很快; 这样可以快速找到从一个特定版本到另一个版本，压缩删除过时的键值对。</p>
<p>etcd还保留了辅助内存中的<code>btree</code>索引，以加快对key的范围查询。btree索引中的键是向用户公开的存储的键。该值是指向持久性b+树的修改的指针。压缩删除死指针。</p>
<h3 id="关于WAL"><a href="#关于WAL" class="headerlink" title="关于WAL"></a>关于WAL</h3><p>WAL(Write Ahead Log)预写式日志，是etcd的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引外，etcd就通过WAL进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照；Entry 表示存储的具体日志内容。</p>
<p>在 WAL 的体系中，所有的数据在提交之前都会进行日志记录。在 etcd 的持久化存储目录中，有两个子目录。一个是 WAL，存储着所有事务的变化记录；另一个则是 snapshot，用于存储某一个时刻 etcd 所有目录的数据。通过 WAL 和 snapshot 相结合的方式，etcd 可以有效的进行数据存储和节点故障恢复等操作。</p>
<p>既然有了 WAL 实时存储了所有的变更，为什么还需要 snapshot 呢？随着使用量的增加，WAL 存储的数据会暴增，为了防止磁盘很快就爆满，etcd 默认每 10000 条记录做一次 snapshot，经过 snapshot 以后的 WAL 文件就可以删除。</p>
<h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><p>在 etcd 的数据目录中，WAL 文件以$seq-$index.wal的格式存储。最初始的 WAL 文件是0000000000000000-0000000000000000.wal，表示是所有 WAL 文件中的第 0 个，初始的 Raft 状态编号为 0。运行一段时间后可能需要进行日志切分，把新的条目放到一个新的 WAL 文件中。</p>
<p>假设，当集群运行到 Raft 状态为 20 时，需要进行 WAL 文件的切分时，下一份 WAL 文件就会变为0000000000000001-0000000000000021.wal。如果在 10 次操作后又进行了一次日志切分，那么后一次的 WAL 文件名会变为0000000000000002-0000000000000031.wal。可以看到-符号前面的数字是每次切分后自增 1，而-符号后面的数字则是根据实际存储的 Raft 起始状态来定。</p>
<p>snapshot 的存储命名则比较容易理解，以$term-$index.wal格式进行命名存储。term 和 index 就表示存储 snapshot 时数据所在的 raft 节点状态，当前的任期编号以及数据项位置信息。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><blockquote>
<p><a href="https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="noopener">https://www.infoq.cn/article/etcd-interpretation-application-scenario-implement-principle</a></p>
</blockquote>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s之etcd基本操作</title>
    <url>/k8s%E4%B9%8Betcd-%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以参考etcd的github </p>
<blockquote>
<p><a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">https://github.com/etcd-io/etcd</a></p>
</blockquote>
<p>如果是mac的话，简单的方式应该是运行如下命令</p>
<blockquote>
<p>brew install etcd</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>etcd是一个分布式键值存储，旨在可靠，快速地保存和提供对关键数据的访问。它通过分布式锁定，领导者选举和写入障碍实现可靠的分布式协调。etcd集群旨在实现高可用性和永久数据存储和检索。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>可以使用<code>goreman</code>来在本地启动多个节点</p>
<a id="more"></a>


<p><a href="https://github.com/mattn/goremam" target="_blank" rel="noopener">goreman</a> 是一个go写的多进程管理，是foreman的go版本，运行如下代码进行下载</p>
<blockquote>
<p>go get github.com/mattn/goreman</p>
</blockquote>
<p>启动goreman</p>
<blockquote>
<p>goreman start</p>
</blockquote>
<p>启动的时候需要提供一个Procfile文件可以使用-f参数，默认是使用当前目录下的Procfile文件</p>
<p>我们来创建一个Procfile文件，然后写入如下内容</p>
<pre><code> # Use goreman to run `go get github.com/mattn/goreman`
etcd1: etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster &apos;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&apos; --initial-cluster-state new --enable-pprof
etcd2: etcd --name infra2 --listen-client-urls http://127.0.0.1:22379 --advertise-client-urls http://127.0.0.1:22379 --listen-peer-urls http://127.0.0.1:22380 --initial-advertise-peer-urls http://127.0.0.1:22380 --initial-cluster-token etcd-cluster-1 --initial-cluster &apos;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&apos; --initial-cluster-state new --enable-pprof
etcd3: etcd --name infra3 --listen-client-urls http://127.0.0.1:32379 --advertise-client-urls http://127.0.0.1:32379 --listen-peer-urls http://127.0.0.1:32380 --initial-advertise-peer-urls http://127.0.0.1:32380 --initial-cluster-token etcd-cluster-1 --initial-cluster &apos;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&apos; --initial-cluster-state new --enable-pprof
#proxy: etcd grpc-proxy start --endpoints=127.0.0.1:2379,127.0.0.1:22379,127.0.0.1:32379 --listen-addr=127.0.0.1:23790 --advertise-client-url=127.0.0.1:23790 --enable-pprof</code></pre><p>然后保存在启动goreman</p>
<p>上面的内容我们是定义了3个etcd的节点</p>
<pre><code>etcd1: etcd --name infra1 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --listen-peer-urls http://127.0.0.1:12380 --initial-advertise-peer-urls http://127.0.0.1:12380 --initial-cluster-token etcd-cluster-1 --initial-cluster &apos;infra1=http://127.0.0.1:12380,infra2=http://127.0.0.1:22380,infra3=http://127.0.0.1:32380&apos; --initial-cluster-state new --enable-pprof</code></pre><p>我们来看一下这些参数</p>
<ul>
<li>name  节点的名称</li>
<li>listen-client-urls 指定etcd服务器绑定的本地地址以接受传入连接。要侦听所有接口的端口，请指定0.0.0.0侦听IP地址。</li>
<li>advertise-client-urls 建议用于客户端通信的url列表，该值用于etcd代理或etcd成员与节点通信,不可以使用localhost这种，因为这种地址无法从远程计算机进行访问</li>
<li>listen-peer-urls 指定etcd服务器绑定的本地地址以接受传入连接。要侦听所有接口的端口，请指定0.0.0.0侦听IP地址。</li>
<li>initial-advertise-peer-urls 建议用于节点之间通信的url列表，不可以使用localhost这种，因为这种地址无法从远程计算机进行访问</li>
<li>initial-cluster-token 集群的token值，用来区分不同的集群</li>
<li>initial-cluster 集群中所有initial-advertise-peer-urls的合集</li>
<li>initial-cluster-state 集群状态 new是新建</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="使用etcdctl工具进行操作"><a href="#使用etcdctl工具进行操作" class="headerlink" title="使用etcdctl工具进行操作"></a>使用etcdctl工具进行操作</h2><p>etcdctl默认是v2,我们先调整到v3</p>
<blockquote>
<p>export ETCDCTL_API=3</p>
</blockquote>
<h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>etcdctl version</p>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>写入使用put指令，put后面跟键值对</p>
<blockquote>
<p>etcdctl put foo bar</p>
</blockquote>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>使用get指令读取，get后面跟要读取的键</p>
<blockquote>
<p>etcdctl get foo</p>
</blockquote>
<p>如果想读取十六进制，使用–hex参数</p>
<blockquote>
<p>etcdctl get foo –hex</p>
</blockquote>
<p>如果想只读取值，使用–print-value-only参数</p>
<blockquote>
<p>etcdctl get foo –print-value-only</p>
</blockquote>
<p>如果想根据前缀获取，使用–prefix</p>
<blockquote>
<p>etcdctl get foo –prefix</p>
</blockquote>
<p>还可以使用limit参数限制数量</p>
<blockquote>
<p>etcdctl get foo –prefix –liimit=2</p>
</blockquote>
<h4 id="读取之前版本的记录"><a href="#读取之前版本的记录" class="headerlink" title="读取之前版本的记录"></a>读取之前版本的记录</h4><p>可以使用–rev参数来获取之前操作时候的值,比如</p>
<pre><code>etcdctl put foo bar
etcdctl put foo bar1
etcdctl put foo bar2</code></pre><p>这个时候我们读取，给我们的值肯定是bar2</p>
<blockquote>
<p>etcdctl get foo</p>
</blockquote>
<p>我们可以通过–rev=3参数来获取之前的bar1值，–rev=2来获取bar值</p>
<blockquote>
<p>etcdctl get foo –rev=3</p>
</blockquote>
<h4 id="读取大于等于给定键的键值对"><a href="#读取大于等于给定键的键值对" class="headerlink" title="读取大于等于给定键的键值对"></a>读取大于等于给定键的键值对</h4><p>可以使用参数 –from-key来获取大于等于给定键的键值，这个参数是使用键的字节进行比较</p>
<blockquote>
<p>etcdctl get foo –from-key</p>
</blockquote>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用del指令删除键值对</p>
<blockquote>
<p>etcdctl del foo</p>
</blockquote>
<p>可以使用上面提到的–prefix来删除所有这个前缀的键值，还有–from-key参数也可以使用。这里面有一个新参数–prev-kv，这个参数返回删除的键值</p>
<blockquote>
<p>etcdctl del foo –prev-kv</p>
</blockquote>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>使用watch指令可以观测指定键的操作，注意这个应该在另外一个终端中进行，而且同样要改变成v3版本，不然默认v2是监测不到改变的</p>
<blockquote>
<p>etcdctl watch foo</p>
</blockquote>
<p>可以是使用-i参数进入交互模式</p>
<blockquote>
<p>etcdctl watch -i<br>然后输入你要监测的键<br>watch foo</p>
</blockquote>
<h4 id="观察历史记录"><a href="#观察历史记录" class="headerlink" title="观察历史记录"></a>观察历史记录</h4><p>这个操作也可以使用上面的–rev参数，它会把之前的历史操作都显示出来，也会继续观察之后的操作</p>
<blockquote>
<p>etcdctl watch foo –rev=1</p>
</blockquote>
<h1 id="关于通信"><a href="#关于通信" class="headerlink" title="关于通信"></a>关于通信</h1><p>etcd本身使用grpc作为其消息传递协议，也就是我们在项目中使用的时候，使用grpc进行和etcd的通信。对于没有grpc支持的语言，或者你不想使用grpc的话，etcd也提供了json grpc网关。此网关提供restful代理，将http/json请求转换为grpc消息。<br>详细使用方法，直接去github上面看吧</p>
<blockquote>
<p><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/dev-guide/api_grpc_gateway.md" target="_blank" rel="noopener">https://github.com/etcd-io/etcd/blob/master/Documentation/dev-guide/api_grpc_gateway.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>素数对猜想</title>
    <url>/%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3.html</url>
    <content><![CDATA[<h1 id="素数对猜想"><a href="#素数对猜想" class="headerlink" title="素数对猜想"></a>素数对猜想</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数<code>N</code>(&lt;10<sup>5</sup>)，请计算不超过N的满足猜想的素数对的个数。</p>
<h2 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h2><pre><code>20</code></pre><h2 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h2><pre><code>4</code></pre><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个比较简单，看题目，能确定一点，一个素数对，有两个相差 2 的素数组成。那么接下来就可以用 <code>n</code>除以<code>2</code>到<code>根号n</code>之中的任意一个数，如果能被整除，那么就不是素数，如果不能被整除，那么就是一个素数。如果发现了一个素数，那么就用这个素数相差2的数再去判断，如果还是素数，那么就有了一个素数对。</p>
<a id="more"></a>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断是不是一个素数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;int&#125; $num</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span><span class="params">($num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果 n &lt; 2 那么它不是一个素数</span></span><br><span class="line">    <span class="keyword">if</span> ($num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 n 能整除 2 到 根号n 之中的任意一个数 那么他就不是 素数</span></span><br><span class="line">    <span class="comment">//sqrt 函数 用来 开平方根</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">2</span>; $i &lt;= intval(sqrt($num)); $i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($num % $i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ($i = $num; $i &gt;= <span class="number">5</span>; $i--) &#123;</span><br><span class="line">        <span class="comment">//如果 n 和 n - 2 都是素数，那么就有一个素数对</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isPrime($i) &amp;&amp; <span class="keyword">$this</span>-&gt;isPrime($i - <span class="number">2</span>)) &#123;</span><br><span class="line">            ++$count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf($count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>打印沙漏</title>
    <url>/%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F.html</url>
    <content><![CDATA[<h1 id="打印沙漏"><a href="#打印沙漏" class="headerlink" title="打印沙漏"></a>打印沙漏</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>顾名思义，就是要输出一个<code>沙漏</code>，那么什么是沙漏呢，就是下面的样子了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>也就是要给我们n个<code>*</code>，这个沙漏每一行的 符号 数量都是奇数，因此是有规律的。</p>
<a id="more"></a>


<h2 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h2><p>  19 //多少个符号 *</p>
<h2 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;打印出一个沙漏</span><br><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">***** </span><br><span class="line">2 &#x2F;&#x2F;剩余没有用掉的符号数量</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个解题思路是我在网上看到的，他把这个沙漏 具像化，*号用坐标来显示，那么上面的例子就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（0，0）（0，1）（0，2）（0，3）（0，4）</span><br><span class="line">       （1，1）（1，2）（1，3）</span><br><span class="line">              （2，2）</span><br><span class="line">       （3，1）（3，2）（3，3）</span><br><span class="line">（4，0）（4，1）（4，2）（4，3）（4，4）</span><br></pre></td></tr></table></figure>

<p>这样的话，继续观察一下，发现他可以上下对折，左右对折变成下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（0，0）（0，1）（0，2）</span><br><span class="line">       （1，1）（1，2）</span><br><span class="line">              （2，2）</span><br></pre></td></tr></table></figure>

<p>发现了什么，列 &gt;= 行，然后接下来左右对称，上下对称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 行坐标 &gt; 行数 &#x2F; 2 也就是过半的时候， 这时的行坐标 &#x3D; 总行数 - 当前行数 - 1，比如下一行 行坐标 3 &#x3D; 5 - 3 -1 &#x3D; 1 所以 行坐标 3 的行和行坐标 1 的行对称。</span><br></pre></td></tr></table></figure>

<p>列也是一样 因为列数 = 行数 所以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当 列坐标 &gt; 行数 &#x2F; 2 也就是过半的时候， 这时的列坐标 &#x3D; 总行数 - 当前列数 - 1，比如下一列 列坐标 3 &#x3D; 5 - 3 - 1 &#x3D; 1 所以列坐标 3 的列和列坐标 1 的列对称。</span><br></pre></td></tr></table></figure>

<p>当然了，中间那一行（列）没有对称</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面是 我用 <code>php</code> 实现的代码，任何语言都大同小异。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($count, $symbol)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $maxRow = <span class="number">1</span>; <span class="comment">//最大行 即 最小行</span></span><br><span class="line">        $maxCount = <span class="number">1</span>; <span class="comment">//最大个数 即 最小个数</span></span><br><span class="line">        <span class="comment">//先判断 数量 如果是小于 最小个数 那么输出 数量</span></span><br><span class="line">        <span class="keyword">if</span> ($count &lt; $maxCount) &#123;</span><br><span class="line">            printf($count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//循环 算出 最大行数 统计最大个数 后面用来算剩余个数</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//可以输出</span></span><br><span class="line">                <span class="comment">//下一行的数量 = 之前的数量 + 下一行所需的数量（（行数 + 2） 是下一行的数量，但是沙漏需要上下两行，所以 * 2）</span></span><br><span class="line">                $nextCount = ($maxRow + <span class="number">2</span>) * <span class="number">2</span> + $maxCount;</span><br><span class="line">                <span class="comment">//判断不够了 结束</span></span><br><span class="line">                <span class="keyword">if</span> ($count &lt; $nextCount) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">elseif</span> ($count == $nextCount) &#123;</span><br><span class="line">                    <span class="comment">//刚好够 数量增加 行增加</span></span><br><span class="line">                    $maxRow += <span class="number">2</span>;</span><br><span class="line">                    $maxCount = $nextCount;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//完全够 数量增加 行增加 然后继续循环</span></span><br><span class="line">                    $maxRow += <span class="number">2</span>;</span><br><span class="line">                    $maxCount = $nextCount;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始输出</span></span><br><span class="line">            <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $maxRow; $i++) &#123;</span><br><span class="line">                <span class="comment">//循环所有行</span></span><br><span class="line">                $row = $i; <span class="comment">//当前行</span></span><br><span class="line">                <span class="comment">//判断 当前行 到一半了，那么把行数倒过来，让它向上跑</span></span><br><span class="line">                <span class="keyword">if</span> ($i &gt; $maxRow / <span class="number">2</span>) &#123;</span><br><span class="line">                    $row = $maxRow - $row - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $maxRow; $j++) &#123;</span><br><span class="line">                    <span class="comment">//循环所有列</span></span><br><span class="line">                    $col = $j;</span><br><span class="line">                    <span class="comment">//列和行一样 做个判断</span></span><br><span class="line">                    <span class="keyword">if</span> ($col &gt; $maxRow / <span class="number">2</span>) &#123;</span><br><span class="line">                        $col = $maxRow - $col - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果 当前列 &lt; 当前行</span></span><br><span class="line">                    <span class="keyword">if</span> ($col &lt; $row) &#123;</span><br><span class="line">                        <span class="comment">//如果 到了 最后 就要换行 在 前面 则输出 空格</span></span><br><span class="line">                        <span class="keyword">if</span> ($j &gt; $maxRow / <span class="number">2</span>) &#123;</span><br><span class="line">                            printf(<span class="string">"\n"</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            printf(<span class="string">" "</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//列 &gt; 行 直接输出 符号</span></span><br><span class="line">                        printf($symbol);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//输出完 最后一个符号后 换行 当列 = 最后一行的时候</span></span><br><span class="line">                    <span class="keyword">if</span> ($j == $maxRow - <span class="number">1</span>) &#123;</span><br><span class="line">                        printf(<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出 剩余的 符号数量</span></span><br><span class="line">            printf($count - $maxCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>我只是略作更改，最小使用1个*，和一些变量使用上的微调 下面原文c语言的链接</p>
<blockquote>
<p><a href="https://blog.csdn.net/hcy2319964421/article/details/53103641" target="_blank" rel="noopener">https://blog.csdn.net/hcy2319964421/article/details/53103641</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>node-xlsx 使用node.js导出excel</title>
    <url>/node-xlsx-%E4%BD%BF%E7%94%A8node-js%E5%AF%BC%E5%87%BAexcel.html</url>
    <content><![CDATA[<h1 id="导出excel"><a href="#导出excel" class="headerlink" title="导出excel"></a>导出excel</h1><p>关于excel，相信这玩意大家都用过，我们这边，主要运营那边，对这些数据导出很有需要，之前拿php做过，因为现在改用node了，所以这边要用node来搞。</p>
<h2 id="export-xlsx"><a href="#export-xlsx" class="headerlink" title="export-xlsx"></a>export-xlsx</h2><p><code>excel-export</code> 这个库你们也可以用用，简单实用，我一开始用的这个，只不过后来不满足我的需求了，所以改用了<code>node-xlsx</code></p>
<blockquote>
<p><a href="https://github.com/functionscope/Node-Excel-Export" target="_blank" rel="noopener">https://github.com/functionscope/Node-Excel-Export</a></p>
</blockquote>
<h2 id="node-xlsx"><a href="#node-xlsx" class="headerlink" title="node-xlsx"></a>node-xlsx</h2><p>来说说<code>node-xlsx</code>这个东西吧，非常简单上手，我这种node新人也可以用明白，不容易啊，哈哈。</p>
<a id="more"></a>


<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install node-xlsx</span><br></pre></td></tr></table></figure>
<p>或者</p>
<blockquote>
<p><a href="https://github.com/mgcrea/node-xlsx" target="_blank" rel="noopener">https://github.com/mgcrea/node-xlsx</a></p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>直接安装该模块，然后进入代码阶段，其实这个也很简单，使用起来简单粗暴</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   import nodeExcel from &#39;node-xlsx&#39;</span><br><span class="line">   import fs from &#39;fs&#39;</span><br><span class="line">   import path from &#39;path&#39;</span><br><span class="line"></span><br><span class="line">   const EXPORT_PATH &#x3D; &#39;..&#x2F;..&#x2F;static&#39;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;创建一个buffer name是你的sheet的名称，data是你的内容，一个二维数组，我是把数据库查询出来的转成了二维数组</span><br><span class="line">   &#x2F;&#x2F;data &#x3D; [[name,age][章三,11]]</span><br><span class="line">let buffer &#x3D; nodeExcel.build([&#123; name: &#39;mySheetName&#39;, data: arr &#125;])</span><br><span class="line">&#x2F;&#x2F;写入一个文件</span><br><span class="line">   &#x2F;&#x2F;filePath 是你的文件路径，自己定义一下就好了</span><br><span class="line">   &#x2F;&#x2F;fileName 是你的文件名，带后缀xlsx的哦</span><br><span class="line">   let filePath &#x3D; path.resolve(__dirname, EXPORT_PATH, fileName)</span><br><span class="line">fs.writeFileSync(filePath, buffer, &#39;binary&#39;)</span><br></pre></td></tr></table></figure>

<p>这样就完成转换成这个文件了，接下来你可以把文件路径返回给前端，或者把文件流返回给前端</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>node-xlsx</tag>
      </tags>
  </entry>
  <entry>
    <title>git 命令行简写</title>
    <url>/git-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%80%E5%86%99.html</url>
    <content><![CDATA[<p>常用的 <code>git</code> 命令不多，反正我就是那几个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git branch</span><br><span class="line">git checkout</span><br><span class="line">git commit</span><br><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>虽然看起来也不长，但是我还是喜欢简写，哈哈，说一下怎么配置</p>
<a id="more"></a>


<blockquote>
<p>vim ~/.gitconfig    打开配置文件</p>
</blockquote>
<p>输入如下</p>
<pre><code>[alias]
        br = branch
        st = status
        co = checkout
        cm = commit
        df = diff
        dt = difftool
[diff]
        tool = vimdiff

[user]
        name = xxx
        email = xxx</code></pre><p><code>alias</code> 就是简写啦，这样的话，使用就方便多了，<code>diff</code> 和 <code>user</code> 大家可以不用管，哈哈</p>
<h2 id="推荐个小工具"><a href="#推荐个小工具" class="headerlink" title="推荐个小工具"></a>推荐个小工具</h2><p>给大家安利个小工具 <code>gitbash</code> , 用起来很方便，他会在你的命令行里面直接显示出你的分支。下面是 github 的地址，操作简单,大家照着弄一下就好了</p>
<blockquote>
<p><a href="https://github.com/mocheng/gitbash" target="_blank" rel="noopener">https://github.com/mocheng/gitbash</a></p>
</blockquote>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>评论来啦 -- 关于 hexo next 集成 gitment</title>
    <url>/%E8%AF%84%E8%AE%BA%E6%9D%A5%E5%95%A6.html</url>
    <content><![CDATA[<h1 id="全新的gitment-评论上线啦！"><a href="#全新的gitment-评论上线啦！" class="headerlink" title="全新的gitment 评论上线啦！"></a>全新的gitment 评论上线啦！</h1><p>小伙伴们可以评论啦，开不开心，惊不惊喜，本来看网上说用 多说 的，结果发现 多说 没了？ 没了？ 没了？ excuse me?<br>然后，苦逼的我只能继续找，就发现了这个 gitment ，感觉不错，来用一用，瞬间高大上啊，这个 next 主题 好像已经集成好 gitment 了，<br>我们只用简单设置一下就能用了，舒服。</p>
<h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><pre><code>https://github.com/settings/applications/new</code></pre><p>上面的连接，点击注册，会让你输入4个东西</p>
<pre><code>Application name
Homepage URL
Application description
Authorization callback URL</code></pre><p>最后 这个东西 要填你 博客的 url ，点进去之后 都会有说明。弄完之后 会出现两个东西</p>
<pre><code>Client ID
Client Secret</code></pre><p>这两个东西 大家 要记住了。接下来配置的时候会用到。</p>
<h3 id="配置-next"><a href="#配置-next" class="headerlink" title="配置 next"></a>配置 next</h3><p>打开我们的站点配置文件 _config.yml 然后找到 gitment。</p>
<pre><code>enable: true
mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway
count: true # Show comments count in post meta area
lazy: false # Comments lazy loading with a button
cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more
language: 语言
github_user: 你的 github 名
github_repo: 你的仓库名
client_id: 刚刚的 Client ID
client_secret: 刚刚的 Client Secret</code></pre><p>配置完之后 就可以 看一下效果了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>来看一下 这玩意有哪些坑吧<br>在配置的时候 blog/themes/next/layout/_third-party/comments/gitment.swig 这个文件的时候，下面这些取得都是配置里面设置的，一定要一一对应哦</p>
<pre><code>{% set owner = theme.gitment.github_user %}
{% set repo = theme.gitment.github_repo %}
{% set cid = theme.gitment.client_id %}
{% set cs = theme.gitment.client_secret %}</code></pre><p>错误</p>
<pre><code>error:not found</code></pre><p>这个错误的话，你就要仔细检查上面的参数啦，一定是owner 和 repo 这两个参数有问题，和你github上面的用户名和仓库名 不一样导致的</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>关于初始化，这个评论是需要初始化的，嗯，每个文章你都要去初始化，很麻烦。对于我这种没几个文章的来说，还行。<br>在 gitment.swig 这个文件里面 有这样一处代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">    id: <span class="string">'&#123;&#123;page.article&#125;&#125;'</span>,</span><br><span class="line">    owner: <span class="string">'&#123;&#123;owner&#125;&#125;'</span>,</span><br><span class="line">    repo: <span class="string">'&#123;&#123;repo&#125;&#125;'</span>,</span><br><span class="line">    oauth: &#123;</span><br><span class="line">        client_id: <span class="string">'&#123;&#123;cid&#125;&#125;'</span>,</span><br><span class="line">        client_secret: <span class="string">'&#123;&#123;cs&#125;&#125;'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个里面 有个 id 的设置 他默认的是 <code>location.href</code>，这个时候大家注意了，因为这个东西 本质是创建一个 issue,然后他创建的时候，会有一个 label 传过去，来区分你每个文章的评论，他传的是什么呢，是一个数组, 最最重要的是，这tm有长度限制，你用 href 的话，基本是超出的，反正我是，然后我试了一下 pathname ，依然超出。</p>
<p>网上有人用的是时间，也有标题，我就不一样了，我给每个文章加了个 article 来区分他们。使用方法就是上面那样。我也用过时间，然后他告诉我 不是 string or object ，晕，标题，万一没控制好超长了就不好玩了。大家根据需求来就行了，有问题的欢迎评论。</p>
<pre><code>[
    gitment,
    你写的id
]</code></pre>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>gitment</tag>
      </tags>
  </entry>
  <entry>
    <title>window php 环境搭建一</title>
    <url>/window%20php%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%80.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="开始写博客了，激动ing–此处省略一万字……"><a href="#开始写博客了，激动ing–此处省略一万字……" class="headerlink" title="开始写博客了，激动ing–此处省略一万字……"></a>开始写博客了，激动ing–此处省略一万字……</h3><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>直接说环境吧，每次到一个公司，配置环境是最烦的，嗯，博主比较菜，这个配置完n久都不在用的，一会就忘了，所以，你懂的。。环境清单如下：</p>
<pre><code>php
nginx
mysql
redis
mongo
rabbitMq队列</code></pre><p>下载 没什么好说的，百度官网，直接下载就行了，我相信大家都知道。</p>
<p><code>php</code> 下载之后 直接复制 一个 php.ini-development 或者 php.ini-production 然后改名成 php.ini，你们猜的没错，这就是我们的配置啦。扩展之类的 从 Pecl下载好 ，然后在配置里面打开就好了。<br>下载 nginx 同上，一样官网下载，然后在你下载之后，里面有 conf 文件夹 里面的 nginx.conf 就是 nginx 的配置文件了。暂时什么都不用改，启动 nginx 然后访问 localhost 就会出现 nginx 的欢迎页面了。</p>
<p><code>mysql</code> 下载是一样的，在安装的时候 要注意选择需要的东西安装就好了，博主只用了server and bench。安装的时候会设置 root 用户的密码。</p>
<p><code>redis</code> 同样官网下载，之后咋们主要看 2个东西 redis-server.exe and redis-cli.exe ，一个服务器一个客户端。然后还有一个隐藏小boss，redis.windows.conf 启动 redis 服务的时候要带上这玩意，所以我们就要用 cmd 了， 打开 cmd 输入如下：</p>
<blockquote>
<p>路径\redis-server.exe redis.windows.conf</p>
</blockquote>
<p>好了，然后点击 <code>redis-cli.exe</code> 就可以用了。完美。</p>
<p><code>mongo</code> 同上，下载完之后 在 <code>bin</code> 文件夹里面 有 <code>mongod.exe</code> and <code>mongo.exe</code> 也是 服务器和客户端，对于 <code>mongo</code> 我们要建一个 <code>data\db</code> 这两个文件夹</p>
<p>最后到了 <code>rabbitMq</code> 了, 安装这个之前，要先安装 <code>erlang</code> ，直接下载安装， 然后就可以安装 <code>rabbitMq</code> 了，然后 我们 安装 <code>rabbitMq-plugins</code> 打开 cmd 输入</p>
<blockquote>
<p>路径\rabbitMq_server\sbin\rabbitmq-plugins enable rabbitmq_management</p>
</blockquote>
<p>然后就会安装成功了。</p>
<p>说一下问题。<br>首先这些 环境变量 一定要弄上。<br>然后 <code>rabbitmq</code> 要先启动 在安装 <code>rabbitmq-plugins</code> ，我也忘了是不是了，你们根据情况来吧。</p>
<blockquote>
<p>安装完之后 进入浏览器 localhost:15672 就能访问管理页面了。</p>
</blockquote>
<p>哈哈，其实还是有一些坑的，只不过写的时候想不起来了，所以这篇没什么干货。。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote>
<p>想起来一个东西，所有的命令输入 绝对路径 或者 进入相应文件夹 用 .*.exe 的命令来执行</p>
</blockquote>
<p>如果有什么想问的 欢迎加博主的qq and 微信</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>php</tag>
        <tag>nginx</tag>
        <tag>redis</tag>
        <tag>mongo</tag>
        <tag>rabbitMq</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
